<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Adaboost算法</title>
    <url>/2019/09/19/adaboost/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了集成学习领域中基于boosting思想的Adaboost算法</p>
</blockquote>
<a id="more"></a>

<h3 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="1. 基本思想"></a>1. 基本思想</h3><p>在二分类问题中，通过采用 re-weighting 即更新权重的方式给每个基学习器的训练样本赋予不同的权重，以满足基学习器的多样性</p>
<p>具体来说，将更新后的权重应用于上一个基学习器的训练样本中时，其基学习器误差为0.5，即<br>已知：<br>$$\epsilon_t = \frac {\sum_{n}u_{t}^{n}\delta(f_{t}(x^n) \neq \hat y^n)}{Z_t} \tag{1}$$<br>$$\frac{\sum_{n}u_{t+1}^{n}\delta(f_{t}(x^n) \neq \hat y^n)}{Z_{t+1}} = \frac{1}{2} \tag{2}$$<br>其中：<br>$$Z_t = \sum_{n}u_{t}^{n}$$<br>$$Z_{t+1} = \sum_{n}u_{t+1}^{n}$$</p>
<h3 id="2-表达形式1"><a href="#2-表达形式1" class="headerlink" title="2. 表达形式1"></a>2. 表达形式1</h3><p>已知：</p>
<p>(1) 分类标签：<br>$$Y \in \{1, -1\}$$</p>
<p>(2) 权重更新方法：<br>$$<br>u_{t+1}^n =<br>\begin{cases}<br>u_t^n \cdot d_t,  &amp;\text{if $f_{t}(x^n) \neq \hat y^n$} \\<br>u_t^n / d_t,  &amp;\text{if $f_{t}(x^n) = \hat y^n$}<br>\end{cases}<br>\tag{3}<br>$$</p>
<p>由(1)(2)(3)解得：<br>$$d_t = \sqrt{\frac{1 - \epsilon_t}{\epsilon_t}} \tag{4}$$</p>
<p>引入：<br>$$\alpha_t = lnd_t \tag{5}$$</p>
<p>将(4)(5)代入(3)中，则有：<br>$$u_{t+1}^n = u_t^n \cdot exp(-\hat y^nf_t(x^n)\alpha_t)$$</p>
<p>最终学习器：<br>$$H(x) = sign(\sum_{t=1}^T\alpha_tf_t(x))$$</p>
<h3 id="3-表达形式2"><a href="#3-表达形式2" class="headerlink" title="3. 表达形式2"></a>3. 表达形式2</h3><p>已知：</p>
<p>(1) 分类标签：<br>$$Y \in \{1, 0\}$$</p>
<p>(2) 权重更新方法：<br>$$<br>u_{t+1}^n =<br>\begin{cases}<br>u_t^n / \beta_t,  &amp; \text{if $f_{t}(x^n) \neq \hat y^n$} \\<br>u_t^n, &amp; \text{if $f_{t}(x^n) = \hat y^n$}<br>\end{cases}<br>\tag{6}<br>$$</p>
<p>由(1)(2)(6)解得：<br>$$\beta_t = \frac{\epsilon_t}{1 - \epsilon_t} \tag{7}$$</p>
<p>将(7)代入(6)中，则有：<br>$$u_{t+1}^n = u_t^n \cdot \beta_t^{-|f_t(x^n) - \hat y^n|}$$</p>
<p>最终学习器：<br>$$<br>H(x) =<br>\begin{cases}<br>1,  &amp;\text{if $\sum_{t=1}^Tf_t(x)ln(1/\beta_t) \ge \frac12\cdot\sum_{t=1}^Tln(1/\beta_t)$} \\[2ex]<br>0,  &amp;\text{otherwise}<br>\end{cases}<br>$$</p>
<h3 id="4-基学习器生成过程"><a href="#4-基学习器生成过程" class="headerlink" title="4. 基学习器生成过程"></a>4. 基学习器生成过程</h3><p>$u_1 \to f_1 \to \epsilon_1 \to d_1 \to u_2 \to f_2 \to \epsilon_2 \to \cdots$</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>集成学习</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找法总结</title>
    <url>/2020/05/01/binarySearch/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了二分查找法的基本框架以及leetcode上的有关习题</p>
<a id="more"></a>
</blockquote>
<h3 id="1-基本框架"><a href="#1-基本框架" class="headerlink" title="1. 基本框架"></a>1. 基本框架</h3><h4 id="0-内容来源"><a href="#0-内容来源" class="headerlink" title="(0) 内容来源:"></a>(0) 内容来源:</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485044&idx=1&sn=e6b95782141c17abe206bfe2323a4226&chksm=9bd7f87caca0716aa5add0ddddce0bfe06f1f878aafb35113644ebf0cf0bfe51659da1c1b733&scene=21#wechat_redirect" target="_blank" rel="noopener">链接</a></p>
<h4 id="1-寻找一个数"><a href="#1-寻找一个数" class="headerlink" title="(1) 寻找一个数"></a>(1) 寻找一个数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 这里为闭区间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( left &lt;= right ) &#123; <span class="comment">// 这里为小于等于号；等于时，区间不为空(闭区间)，所以也要检查</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( nums[mid] == target ) <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( nums[mid] &lt; target ) left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( target &lt; nums[mid] ) right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-寻找左边界"><a href="#2-寻找左边界" class="headerlink" title="(2) 寻找左边界"></a>(2) 寻找左边界</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>(); <span class="comment">// 这里为左闭右开区间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( left &lt; right ) &#123; <span class="comment">// 这里为小于号；等于时，区间为空(左闭右开)，所以不用检查</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( nums[mid] == target ) right = mid; <span class="comment">// 关键</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( nums[mid] &lt; target ) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( target &lt; nums[mid]) right = mid; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查越界</span></span><br><span class="line">    <span class="comment">// left 的取值范围为[0, nums.size()]</span></span><br><span class="line">    <span class="comment">// 当left == nums.size()时，返回值 left 越界</span></span><br><span class="line">    <span class="keyword">if</span> ( left == nums.<span class="built_in">size</span>() ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums[left] == target ? left : <span class="number">-1</span>; <span class="comment">// 注意！返回 left</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-寻找右边界"><a href="#3-寻找右边界" class="headerlink" title="(3) 寻找右边界"></a>(3) 寻找右边界</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>(); <span class="comment">// 这里为左闭右开区间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( left &lt; right ) &#123; <span class="comment">// 这里为小于号；等于时，区间为空(左闭右开)，所以不用检查</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) left = mid + <span class="number">1</span>; <span class="comment">// 关键</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) right = mid; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查越界</span></span><br><span class="line">    <span class="comment">// left 的取值范围为[0, nums.size()]</span></span><br><span class="line">    <span class="comment">// 当left == 0时，返回值 left - 1 越界</span></span><br><span class="line">    <span class="keyword">if</span> ( left == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nums[left<span class="number">-1</span>] == target ? (left - <span class="number">1</span>) : <span class="number">-1</span>; <span class="comment">// 注意！返回 left - 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-leetcode上的相关题目"><a href="#2-leetcode上的相关题目" class="headerlink" title="2. leetcode上的相关题目"></a>2. leetcode上的相关题目</h3><h4 id="1-寻找一个数-1"><a href="#1-寻找一个数-1" class="headerlink" title="(1) 寻找一个数"></a>(1) 寻找一个数</h4><table>
<thead>
<tr>
<th>题号</th>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>33</td>
<td><a href="https://shuoshuo666.github.io/2020/03/31/leetcode33/">搜索旋转排序数组</a></td>
<td>中等</td>
</tr>
<tr>
<td>35</td>
<td><a href="https://shuoshuo666.github.io/2020/02/28/leetcode35/">搜索插入位置</a></td>
<td>简单</td>
</tr>
<tr>
<td>69</td>
<td><a href="https://shuoshuo666.github.io/2020/03/02/leetcode69/">x的平方根</a></td>
<td>简单</td>
</tr>
<tr>
<td>74</td>
<td><a href="https://shuoshuo666.github.io/2020/04/19/leetcode74/">搜索二维矩阵</a></td>
<td>中等</td>
</tr>
<tr>
<td>81</td>
<td><a href="https://shuoshuo666.github.io/2020/04/22/leetcode81/">搜索旋转排序数组II</a></td>
<td>中等</td>
</tr>
</tbody></table>
<h4 id="2-寻找左右边界"><a href="#2-寻找左右边界" class="headerlink" title="(2) 寻找左右边界"></a>(2) 寻找左右边界</h4><table>
<thead>
<tr>
<th>题号</th>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>34</td>
<td><a href="https://shuoshuo666.github.io/2020/03/31/leetcode34/">在排序数组中查找元素的第一个和最后一个位置</a></td>
<td>中等</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的拷贝构造函数</title>
    <url>/2019/11/25/copy-constructor/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了C++中的拷贝构造函数</p>
</blockquote>
<a id="more"></a>

<h3 id="1-什么时候调用拷贝构造函数"><a href="#1-什么时候调用拷贝构造函数" class="headerlink" title="1. 什么时候调用拷贝构造函数"></a>1. 什么时候调用拷贝构造函数</h3><p>(1) 复制对象，通过使用另一个同类型的对象来初始化新创建的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassExample</span>&#123;</span>&#125;;  <span class="comment">//定义类ClassExample</span></span><br><span class="line">ClassExample B = A;  <span class="comment">//ClassExample B(A); 是一样的</span></span><br></pre></td></tr></table></figure>

<p>(2) 复制对象，把它作为参数传递给函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ClassExample C;  <span class="comment">//类ClassExample实例化对象C</span></span><br><span class="line">Fun(C);  <span class="comment">//将对象C通过值传递，作为参数传递给函数Fun</span></span><br></pre></td></tr></table></figure>

<p>(3) 复制对象，并从函数返回这个对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ClassExample <span class="title">Fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">ClassExample D;</span><br><span class="line"><span class="keyword">return</span> D;  <span class="comment">//函数Fun将对象D返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-什么时候必须自定义拷贝构造函数"><a href="#2-什么时候必须自定义拷贝构造函数" class="headerlink" title="2. 什么时候必须自定义拷贝构造函数"></a>2. 什么时候必须自定义拷贝构造函数</h3><p>(1) 类中带有指针变量<br>(2) 并且，类中有动态内存分配</p>
<blockquote>
<p>此时，自定义拷贝构造函数应使用深拷贝，而默认拷贝构造函数使用的浅拷贝</p>
</blockquote>
<h3 id="3-拷贝构造函数的常见定义形式"><a href="#3-拷贝构造函数的常见定义形式" class="headerlink" title="3. 拷贝构造函数的常见定义形式"></a>3. 拷贝构造函数的常见定义形式</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">classname (<span class="keyword">const</span> classname &amp;obj)&#123;</span><br><span class="line">    <span class="comment">//拷贝构造函数主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc的简单命令</title>
    <url>/2019/08/21/gcc/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍了gcc的简单命令</p>
</blockquote>
<a id="more"></a>

<p>命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc main.c                <span class="comment"># 一步到位编译，生成a.exe文件</span></span><br><span class="line">$ gcc main.c --save-temps   <span class="comment"># 一步到位编译，保留中间文件</span></span><br><span class="line">$ gcc -E main.c -o main.i   <span class="comment"># 预编译，生成main.i文件</span></span><br><span class="line">$ gcc -S main.i -o main.s   <span class="comment"># 编译为汇编代码，生成main.s文件</span></span><br><span class="line">$ gcc -c main.s -o main.o   <span class="comment"># 汇编，生成main.o文件</span></span><br><span class="line">$ gcc main.o                <span class="comment"># 连接，生成a.exe文件</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>git的常用命令</title>
    <url>/2020/02/28/git/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍了git的常用命令</p>
</blockquote>
<a id="more"></a>

<p>命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init  <span class="comment"># 初始化一个git仓库</span></span><br><span class="line"></span><br><span class="line">git add &lt;filename&gt;  <span class="comment"># 将文件添加到暂存区</span></span><br><span class="line"></span><br><span class="line">git commit -m &lt;message&gt;  <span class="comment"># 将暂存区中的文件提交到当前分支</span></span><br><span class="line"></span><br><span class="line">git status  <span class="comment"># 掌握工作区状态</span></span><br><span class="line"></span><br><span class="line">git diff &lt;filename&gt;  <span class="comment"># 查看修改文件的改动</span></span><br><span class="line"></span><br><span class="line">git reset --hard commit_id  <span class="comment"># 版本回退</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span>  <span class="comment"># 查看提交历史</span></span><br><span class="line"></span><br><span class="line">git reflog  <span class="comment"># 查看命令历史</span></span><br><span class="line"></span><br><span class="line">git restore &lt;filename&gt;  <span class="comment"># 丢弃工作区的改动</span></span><br><span class="line"></span><br><span class="line">git restore --staged &lt;filename&gt;  <span class="comment"># 丢弃暂存区的改动</span></span><br><span class="line"></span><br><span class="line">git rm &lt;filename&gt;  <span class="comment"># 删除文件</span></span><br><span class="line"></span><br><span class="line">git remote add origin git@server-name:path/repo-name.git  <span class="comment"># 关联一个远程库</span></span><br><span class="line"></span><br><span class="line">git push -u origin master  <span class="comment"># 第一次推送master分支的所有内容</span></span><br><span class="line"></span><br><span class="line">git push origin master  <span class="comment"># 推送master分支中的所有内容</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> &lt;address&gt;  <span class="comment"># 把远程库克隆到本地</span></span><br><span class="line"></span><br><span class="line">git branch  <span class="comment"># 查看分支</span></span><br><span class="line"></span><br><span class="line">git branch &lt;name&gt;  <span class="comment"># 创建分支</span></span><br><span class="line"></span><br><span class="line">git branch -d &lt;name&gt;  <span class="comment"># 删除分支</span></span><br><span class="line"></span><br><span class="line">git switch &lt;name&gt;  <span class="comment"># 切换分支</span></span><br><span class="line"></span><br><span class="line">git switch -c &lt;name&gt;  <span class="comment"># 创建+切换分支</span></span><br><span class="line"></span><br><span class="line">git merge &lt;name&gt;  <span class="comment"># 合并分支到当前分支</span></span><br><span class="line"></span><br><span class="line">git merge --no-ff -m &lt;message&gt; &lt;name&gt;  <span class="comment"># 禁用Fast-Forward合并分支，并提交</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中变量的默认初始化</title>
    <url>/2020/02/13/init-var/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了C++中内置类型、数组类型、标准库类型等类型变量的默认初始化</p>
<a id="more"></a>
</blockquote>
<h3 id="1-内置类型"><a href="#1-内置类型" class="headerlink" title="1.内置类型"></a>1.内置类型</h3><p>(1)函数体外定义的变量初始成0；<br>(2)函数体内定义的变量不进行自动初始化；<br>(3)局部静态变量若没有显式初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。</p>
<h3 id="2-数组类型"><a href="#2-数组类型" class="headerlink" title="2.数组类型"></a>2.数组类型</h3><p>(1)若没有提供初始化列表，其自动初始化规则与内置类型一样：函数体外初始化为0；函数体内不进行自动初始化；<br>(2)若提供了部分初始化列表，剩下的数组元素，若为内置类型不论在哪定义，均初始化为0；若为类类型，则调用默认构造函数进行初始化</p>
<h3 id="3-vector类型"><a href="#3-vector类型" class="headerlink" title="3.vector类型"></a>3.vector类型</h3><p>若仅提供元素数量而没有提供初始值，若为内置类型则值初始化为0；若为类类型，调用默认构造函数进行初始化。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的初始化列表</title>
    <url>/2019/11/27/initialization-list/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了C++中的初始化列表</p>
<a id="more"></a>
</blockquote>
<h3 id="1-什么是初始化列表"><a href="#1-什么是初始化列表" class="headerlink" title="1.什么是初始化列表"></a>1.什么是初始化列表</h3><p>(1) 构造函数除了有名字，参数列表外，还可以有初始化列表；</p>
<p>(2) 初始化列表在构造函数头之后、大括号之前，以冒号开头，后面跟一系列以逗号分隔的初始化字段。</p>
<p>看一个例子，下面的代码定义了CExample类，使用了初始化列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    CExample() : a(<span class="number">6</span>), b(<span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//a = 6;</span></span><br><span class="line">        <span class="comment">//b = 6;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-构造函数的两个执行阶段"><a href="#2-构造函数的两个执行阶段" class="headerlink" title="2.构造函数的两个执行阶段"></a>2.构造函数的两个执行阶段</h3><blockquote>
<p>构造函数的执行可以分成两个阶段，初始化阶段和计算阶段，初始化阶段先于计算阶段 </p>
</blockquote>
<h4 id="1-初始化阶段"><a href="#1-初始化阶段" class="headerlink" title="(1) 初始化阶段"></a>(1) 初始化阶段</h4><p> 所有数据成员（包括类类型的成员）都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中 </p>
<h4 id="2-计算阶段"><a href="#2-计算阶段" class="headerlink" title="(2) 计算阶段"></a>(2) 计算阶段</h4><p>一般用于执行构造函数体内的赋值操作 </p>
<p>看一个例子，下面的代码定义了Test类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    CExample e;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    Test(<span class="keyword">int</span> M, <span class="keyword">int</span> N, CExample&amp; K) : c(M), d(N), e(K)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//c = M;</span></span><br><span class="line">        <span class="comment">//d = N;</span></span><br><span class="line">        <span class="comment">//e = K;  将调用赋值运算符重载函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行如下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CExample aaa;</span><br><span class="line">    <span class="function">Test <span class="title">bbb</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, aaa)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行至<code>Test bbb(1, 2, aaa)</code>时，将调用Test类的构造函数。</p>
<p>第一个阶段（即初始化阶段），不使用初始化列表（即代码中注释的部分）与使用初始化列表，将发生：</p>
<style>
table th:first-of-type {
    width: 100px;
}
table th:nth-of-type(2) {
    width: 225px;
}
</style>
<table>
<thead>
<tr>
<th align="center">数据成员</th>
<th align="center">不使用初始化列表</th>
<th align="center">使用初始化列表</th>
</tr>
</thead>
<tbody><tr>
<td align="center">内置类型</td>
<td align="center">int c, d;//变量的定义</td>
<td align="center">int c = 1;int d = 2;//变量的初始化</td>
</tr>
<tr>
<td align="center">类类型</td>
<td align="center">CExample e;//调用构造函数</td>
<td align="center">CExample bbb = aaa;//调用拷贝构造函数</td>
</tr>
</tbody></table>
<p>第二个阶段（即计算阶段），不使用初始化列表（即代码中注释的部分）与使用初始化列表，将发生：</p>
<table>
<thead>
<tr>
<th align="center">数据成员</th>
<th align="center">不使用初始化列表</th>
<th align="center">使用初始化列表</th>
</tr>
</thead>
<tbody><tr>
<td align="center">内置类型</td>
<td align="center">c = 1;d = 2;//变量的赋值</td>
<td align="center">–</td>
</tr>
<tr>
<td align="center">类类型</td>
<td align="center">e = k;//调用赋值运算符重载函数</td>
<td align="center">–</td>
</tr>
</tbody></table>
<p>综合两张表可以看出：</p>
<p>(1) 对内置类型的数据成员，不使用初始化列表是先定义、再赋值；而使用初始化列表则是直接初始化。这二者在结果和性能上并无太大区别</p>
<p>(2) 对于类类型的数据成员，不使用初始化列表是先调用构造函数创建对象、再调用赋值运算符重载函数进行对其进行赋值；而使用初始化列表则是直接调用拷贝构造函数进行初始化。显然，二者结果上没有区别，但是后者的性能要好于前者，因为后者少了一次调用构造函数的过程</p>
<p>所以一个好的原则是，能使用初始化列表的时候尽量使用初始化列表 </p>
<h3 id="3-什么时候必须使用初始化列表"><a href="#3-什么时候必须使用初始化列表" class="headerlink" title="3.什么时候必须使用初始化列表"></a>3.什么时候必须使用初始化列表</h3><p>(1)  数据成员常量成员(const)，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 </p>
<p>(2)  数据成员是引用类型(&amp;)，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 </p>
<p>(3)  数据成员是没有默认构造函数（即无参构造函数）的类类型，看一个例子</p>
<p>若将类CExample的定义改为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    CExample(<span class="keyword">int</span> M, <span class="keyword">int</span> N) : a(M), b(N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//a = M;</span></span><br><span class="line">        <span class="comment">//b = N;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码重载了构造函数，重载后的构造函数需要两个参数，而系统将不再自动生成无参的默认构造函数</p>
<p>若不使用初始化列表，当执行至<code>Test bbb(1, 2, aaa)</code>时，将调用Test类的构造函数</p>
<p>在第一阶段（即初始化阶段）时，将调用CExample类的构造函数（<code>CExample e;</code>），而类CExample的构造函数需要两个参数M和N，而代码<code>CExample e;</code>却没未提供，因此调用CExample类的构造函数将出现编译错误</p>
<p>因此当数据成员是没有默认构造函数的类类型时，必须使用初始化列表</p>
<h3 id="4-成员变量的初始化顺序"><a href="#4-成员变量的初始化顺序" class="headerlink" title="4.成员变量的初始化顺序"></a>4.成员变量的初始化顺序</h3><p>成员是按照他们在<code>类中出现的顺序</code>进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的 </p>
<p>看一个例子，若类CExample的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    CExample(<span class="keyword">int</span> M) : a(M), b(a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//a = M;</span></span><br><span class="line">        <span class="comment">//b = N;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok，先初始化a，后初始化b</p>
<p>若类CExample的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    CExample(<span class="keyword">int</span> M) : b(M), a(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//a = M;</span></span><br><span class="line">        <span class="comment">//b = N;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误！由于类定义中，a出现在b前面，所以无论初始化列表的顺序怎样，都是先初始化a，再初始化b</p>
<p>然而用<code>a(b)</code>初始化a时，b还没有定义，所以编译错误</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#1--两数之和</title>
    <url>/2020/02/21/leetcode1/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#1–两数之和题解</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：两数之和（简单）"><a href="#1-题目：两数之和（简单）" class="headerlink" title="1.题目：两数之和（简单）"></a>1.题目：两数之和（简单）</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-暴力解法"><a href="#1-暴力解法" class="headerlink" title="(1)暴力解法"></a>(1)暴力解法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; ++i ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); ++j ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( nums[i] + nums[j] == target ) &#123;</span><br><span class="line">                    res.push_back(i);</span><br><span class="line">                    res.push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行用时：452ms<br>消耗内存：9.4M</p>
<h4 id="2-使用哈希表"><a href="#2-使用哈希表" class="headerlink" title="(2)使用哈希表"></a>(2)使用哈希表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>( hash.find(temp) != hash.end() )</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(hash[temp]);</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                hash[nums[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行用时：8ms<br>消耗内存：12.5M</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#100--相同的树</title>
    <url>/2020/03/10/leetcode100/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#100–相同的树</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：相同的树（简单）"><a href="#1-题目：相同的树（简单）" class="headerlink" title="1.题目：相同的树（简单）"></a>1.题目：相同的树（简单）</h3><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ( p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;val !=  q-&gt;val ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ( isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#101--对称二叉树</title>
    <url>/2020/03/10/leetcode101/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#101–对称二叉树</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：对称二叉树（简单）"><a href="#1-题目：对称二叉树（简单）" class="headerlink" title="1.题目：对称二叉树（简单）"></a>1.题目：对称二叉树（简单）</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p><strong>示例:</strong></p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="(1) 递归"></a>(1) 递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ( p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;val != q-&gt;val ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isMirror(p-&gt;left, q-&gt;right) &amp;&amp; isMirror(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-BFS"><a href="#2-BFS" class="headerlink" title="(2) BFS"></a>(2) BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="built_in">size</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i ) &#123;</span><br><span class="line">                root = q.front(); q.pop();</span><br><span class="line">                v[i] = root ? root-&gt;val : INT32_MIN;</span><br><span class="line">                <span class="keyword">if</span> ( root != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                    q.push(root-&gt;left);</span><br><span class="line">                    q.push(root-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否回文</span></span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span> / <span class="number">2</span>; ++i ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( v[i] != v[<span class="built_in">size</span> - <span class="number">1</span> - i] ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#102--二叉树的层序遍历</title>
    <url>/2020/04/30/leetcode102/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#102–二叉树的层序遍历</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：二叉树的层序遍历（中等）"><a href="#1-题目：二叉树的层序遍历（中等）" class="headerlink" title="1.题目：二叉树的层序遍历（中等）"></a>1.题目：二叉树的层序遍历（中等）</h3><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="(1) 递归"></a>(1) 递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        helper(root, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* node, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( res.<span class="built_in">size</span>() == level ) res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        res[level].push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;left != <span class="literal">nullptr</span> ) helper(node-&gt;left, res, level + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;right != <span class="literal">nullptr</span> ) helper(node-&gt;right, res, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-BFS"><a href="#2-BFS" class="headerlink" title="(2) BFS"></a>(2) BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; order;</span><br><span class="line">        order.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( !order.empty() ) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; save;</span><br><span class="line">            <span class="keyword">size_t</span> count = order.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i ) &#123;</span><br><span class="line">                TreeNode* node = order.front();</span><br><span class="line">                order.pop();</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;left != <span class="literal">nullptr</span> ) order.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;right != <span class="literal">nullptr</span> ) order.push(node-&gt;right);</span><br><span class="line">                save.push_back(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(save);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#103--二叉树的锯齿形层次遍历</title>
    <url>/2020/04/30/leetcode103/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#103–二叉树的锯齿形层次遍历</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：二叉树的锯齿形层次遍历（中等）"><a href="#1-题目：二叉树的锯齿形层次遍历（中等）" class="headerlink" title="1.题目：二叉树的锯齿形层次遍历（中等）"></a>1.题目：二叉树的锯齿形层次遍历（中等）</h3><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<h3 id="2-题解-BFS"><a href="#2-题解-BFS" class="headerlink" title="2.题解(BFS)"></a>2.题解(BFS)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">zigzagLevelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; order;</span><br><span class="line">        order.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( !order.empty() ) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; save;</span><br><span class="line">            <span class="keyword">size_t</span> count = order.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i ) &#123;</span><br><span class="line">                TreeNode* node = order.front();</span><br><span class="line">                order.pop();</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;left != <span class="literal">nullptr</span> ) order.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;right != <span class="literal">nullptr</span> ) order.push(node-&gt;right);</span><br><span class="line">                save.push_back(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( res.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span> ) reverse(save.<span class="built_in">begin</span>(), save.<span class="built_in">end</span>());</span><br><span class="line">            res.push_back(save);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#104--二叉树的最大深度</title>
    <url>/2020/03/11/leetcode104/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#104–二叉树的最大深度</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树的最大深度（简单）"><a href="#1-题目：二叉树的最大深度（简单）" class="headerlink" title="1.题目：二叉树的最大深度（简单）"></a>1.题目：二叉树的最大深度（简单）</h3><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#107--二叉树的层次遍历2</title>
    <url>/2020/03/11/leetcode107/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#107–二叉树的层次遍历2</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树的层次遍历2（简单）"><a href="#1-题目：二叉树的层次遍历2（简单）" class="headerlink" title="1.题目：二叉树的层次遍历2（简单）"></a>1.题目：二叉树的层次遍历2（简单）</h3><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<h3 id="2-题解-队列"><a href="#2-题解-队列" class="headerlink" title="2.题解(队列)"></a>2.题解(队列)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrderBottom</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; order;</span><br><span class="line">        order.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( !order.empty() ) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; save;</span><br><span class="line">            <span class="keyword">size_t</span> count = order.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i ) &#123;</span><br><span class="line">                TreeNode* node = order.front();</span><br><span class="line">                order.pop();</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;left != <span class="literal">nullptr</span> ) order.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;right != <span class="literal">nullptr</span> ) order.push(node-&gt;right);</span><br><span class="line">                save.push_back(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(save);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>()); <span class="comment">// 逆序</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#108--将有序数组转化为二叉搜索树</title>
    <url>/2020/03/12/leetcode108/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#108–将有序数组转化为二叉搜索树</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：将有序数组转化为二叉搜索树（简单）"><a href="#1-题目：将有序数组转化为二叉搜索树（简单）" class="headerlink" title="1.题目：将有序数组转化为二叉搜索树（简单）"></a>1.题目：将有序数组转化为二叉搜索树（简单）</h3><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums, <span class="number">0</span>, nums.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( begin == end ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root-&gt;left = sortedArrayToBST(nums, begin, mid);</span><br><span class="line">        root-&gt;right = sortedArrayToBST(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#11--盛水最多的容器</title>
    <url>/2020/03/23/leetcode11/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#11–盛水最多的容器</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：盛水最多的容器（中等）"><a href="#1-题目：盛水最多的容器（中等）" class="headerlink" title="1.题目：盛水最多的容器（中等）"></a>1.题目：盛水最多的容器（中等）</h3><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49</p>
</blockquote>
<h3 id="2-题解-双指针法"><a href="#2-题解-双指针法" class="headerlink" title="2.题解(双指针法)"></a>2.题解(双指针法)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = height.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( i &lt; j ) &#123;</span><br><span class="line">            res = max(res, (j - i) * min(height[i], height[j]));</span><br><span class="line">            <span class="comment">//移动短板</span></span><br><span class="line">            <span class="keyword">if</span> ( height[i] &lt; height[j] ) ++i;</span><br><span class="line">            <span class="keyword">else</span> --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#110--平衡二叉树</title>
    <url>/2020/03/12/leetcode110/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#110–平衡二叉树</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：平衡二叉树（简单）"><a href="#1-题目：平衡二叉树（简单）" class="headerlink" title="1.题目：平衡二叉树（简单）"></a>1.题目：平衡二叉树（简单）</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><h4 id="1-自顶向下"><a href="#1-自顶向下" class="headerlink" title="(1)自顶向下"></a>(1)自顶向下</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">abs</span>(depth(root-&gt;left) - depth(root-&gt;right)) &gt; <span class="number">1</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span> </span>&#123;  <span class="comment">//返回子树高度</span></span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> max(depth(root-&gt;left), depth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-自底向上"><a href="#2-自底向上" class="headerlink" title="(2)自底向上"></a>(2)自底向上</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> depth(root) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span> </span>&#123;  <span class="comment">//返回子树高度，若不平衡，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> ( left == <span class="number">-1</span> ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = depth(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> ( right == <span class="number">-1</span> ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(left - right) &lt; <span class="number">2</span> ? max(left, right) + <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#111--二叉树的最小深度</title>
    <url>/2020/03/13/leetcode111/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#111–二叉树的最小深度</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树的最小深度（简单）"><a href="#1-题目：二叉树的最小深度（简单）" class="headerlink" title="1.题目：二叉树的最小深度（简单）"></a>1.题目：二叉树的最小深度（简单）</h3><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="(1) 递归"></a>(1) 递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;left == <span class="literal">nullptr</span> ) <span class="keyword">return</span> minDepth(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;right == <span class="literal">nullptr</span> ) <span class="keyword">return</span> minDepth(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(minDepth(root-&gt;left), minDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-BFS"><a href="#2-BFS" class="headerlink" title="(2) BFS"></a>(2) BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i ) &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right ==<span class="literal">nullptr</span> ) <span class="keyword">return</span> depth;</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;left != <span class="literal">nullptr</span> ) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;right != <span class="literal">nullptr</span> ) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ++depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#112--路径总和</title>
    <url>/2020/03/13/leetcode112/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#112–路径总和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：路径总和（简单）"><a href="#1-题目：路径总和（简单）" class="headerlink" title="1.题目：路径总和（简单）"></a>1.题目：路径总和（简单）</h3><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> )</span><br><span class="line">            <span class="keyword">return</span> (sum == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, sum) || hasPathSum(root-&gt;right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#118--杨辉三角</title>
    <url>/2020/03/14/leetcode118/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#118–杨辉三角</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：杨辉三角（简单）"><a href="#1-题目：杨辉三角（简单）" class="headerlink" title="1.题目：杨辉三角（简单）"></a>1.题目：杨辉三角（简单）</h3><p>给定一个非负整数 <em>numRows，*生成杨辉三角的前 *numRows</em> 行。</p>
<h3 id="2-题解-动态规划"><a href="#2-题解-动态规划" class="headerlink" title="2.题解(动态规划)"></a>2.题解(动态规划)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( numRows == <span class="number">0</span> ) <span class="keyword">return</span> &#123;&#125;;  <span class="comment">//输入为0的情况</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res = &#123;&#123;<span class="number">1</span>&#125;&#125;;  <span class="comment">//第一行</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numRows; ++i ) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">            temp.push_back(<span class="number">1</span>);  <span class="comment">//行首的1</span></span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j ) &#123;</span><br><span class="line">                temp.push_back(res[i - <span class="number">1</span>][j - <span class="number">1</span>] + res[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            temp.push_back(<span class="number">1</span>);  <span class="comment">//行尾的1</span></span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#119--杨辉三角2</title>
    <url>/2020/03/14/leetcode119/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#119–杨辉三角2</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：杨辉三角2（简单）"><a href="#1-题目：杨辉三角2（简单）" class="headerlink" title="1.题目：杨辉三角2（简单）"></a>1.题目：杨辉三角2（简单）</h3><p>给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="(1)递归"></a>(1)递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( rowIndex == <span class="number">0</span> ) <span class="keyword">return</span> &#123;<span class="number">1</span>&#125;;  <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">auto</span> last = getRow(rowIndex - <span class="number">1</span>);  <span class="comment">//上一行的结果</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.push_back(<span class="number">1</span>);  <span class="comment">//行首的1</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rowIndex; ++i ) &#123;</span><br><span class="line">            res.push_back(last[i - <span class="number">1</span>] + last[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(<span class="number">1</span>);  <span class="comment">//行尾的1</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-秀"><a href="#2-秀" class="headerlink" title="(2)秀"></a>(2)秀</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; ++i)&#123;  <span class="comment">//第i行的结果</span></span><br><span class="line">            result.push_back(<span class="number">1</span>);  <span class="comment">//行尾的1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span>; --j)&#123;  <span class="comment">//在同一个数组中产生下一行的结果</span></span><br><span class="line">                result[j] += result[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#12--整数转罗马数字</title>
    <url>/2020/03/24/leetcode12/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#12–整数转罗马数字</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：整数转罗马数字（中等）"><a href="#1-题目：整数转罗马数字（中等）" class="headerlink" title="1.题目：整数转罗马数字（中等）"></a>1.题目：整数转罗马数字（中等）</h3><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</p>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 1994<br>输出: “MCMXCIV”<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; sys&#123;<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( index &lt; <span class="number">13</span> ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( num &gt;= nums[index] ) &#123;</span><br><span class="line">                res.append(sys[index]);</span><br><span class="line">                num -= nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#121--买卖股票的最佳时机</title>
    <url>/2020/03/14/leetcode121/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#121–买卖股票的最佳时机</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：买卖股票的最佳时机（简单）"><a href="#1-题目：买卖股票的最佳时机（简单）" class="headerlink" title="1.题目：买卖股票的最佳时机（简单）"></a>1.题目：买卖股票的最佳时机（简单）</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-暴力双循环"><a href="#1-暴力双循环" class="headerlink" title="(1)暴力双循环"></a>(1)暴力双循环</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); ++i )&#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; prices.<span class="built_in">size</span>(); ++j ) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, prices[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="(2)动态规划"></a>(2)动态规划</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( prices.empty() ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(prices.<span class="built_in">size</span>())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i )&#123;</span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice, prices[i]);</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], prices[i] - minPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-动态规划-转化为最大子列和"><a href="#3-动态规划-转化为最大子列和" class="headerlink" title="(3)动态规划(转化为最大子列和)"></a>(3)动态规划(转化为最大子列和)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//转化为最大子列和问题</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( prices.<span class="built_in">size</span>() &lt;= <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//构造相邻元素求差数组</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(prices.<span class="built_in">size</span>() - <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>() - <span class="number">1</span>; ++i ) &#123;</span><br><span class="line">            diff[i] = prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构造DP数组</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(diff.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="built_in">max</span>(<span class="number">0</span>, diff[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> profit = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; diff.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(<span class="number">0</span>, dp[i<span class="number">-1</span>] + diff[i]);</span><br><span class="line">            profit = <span class="built_in">max</span>(profit, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#122--买卖股票的最佳时机2</title>
    <url>/2020/03/15/leetcode122/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#122–买卖股票的最佳时机2</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：买卖股票的最佳时机2（简单）"><a href="#1-题目：买卖股票的最佳时机2（简单）" class="headerlink" title="1.题目：买卖股票的最佳时机2（简单）"></a>1.题目：买卖股票的最佳时机2（简单）</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h3 id="2-题解-贪心算法"><a href="#2-题解-贪心算法" class="headerlink" title="2.题解(贪心算法)"></a>2.题解(贪心算法)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( prices.size() &lt; <span class="number">2</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//建立求差数组</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; diff;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i ) &#123;</span><br><span class="line">            diff.push_back(prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//累加求差数组中的正数</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j : diff ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( j &gt; <span class="number">0</span> ) res += j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>改进：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> ( diff &gt; <span class="number">0</span> ) res += diff;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#125--验证回文串</title>
    <url>/2020/03/15/leetcode125/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#125–验证回文串</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：验证回文串（简单）"><a href="#1-题目：验证回文串（简单）" class="headerlink" title="1.题目：验证回文串（简单）"></a>1.题目：验证回文串（简单）</h3><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p>说明：本题中，我们将空字符串定义为有效的回文串。</p>
<h3 id="2-题解-双指针"><a href="#2-题解-双指针" class="headerlink" title="2.题解(双指针)"></a>2.题解(双指针)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> left = <span class="number">0</span>, right = s.size() - <span class="number">1</span>; left &lt; right; ++left, --right ) &#123;</span><br><span class="line">            <span class="keyword">while</span>( !<span class="built_in">isalnum</span>(s[left]) &amp;&amp; left &lt; right ) ++left;</span><br><span class="line">            <span class="keyword">while</span>( !<span class="built_in">isalnum</span>(s[right]) &amp;&amp; left &lt; right ) --right;</span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">toupper</span>(s[left]) != <span class="built_in">toupper</span>(s[right]) ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#13--罗马数字转整数</title>
    <url>/2020/02/22/leetcode13/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#13–罗马数字转整数</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：罗马数字转整数（简单）"><a href="#1-题目：罗马数字转整数（简单）" class="headerlink" title="1.题目：罗马数字转整数（简单）"></a>1.题目：罗马数字转整数（简单）</h3><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>I</td>
<td>1</td>
</tr>
<tr>
<td>V</td>
<td>5</td>
</tr>
<tr>
<td>X</td>
<td>10</td>
</tr>
<tr>
<td>L</td>
<td>50</td>
</tr>
<tr>
<td>C</td>
<td>100</td>
</tr>
<tr>
<td>D</td>
<td>500</td>
</tr>
<tr>
<td>M</td>
<td>1000</td>
</tr>
</tbody></table>
<p>例如，罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。27 写做 XXVII ,即为 XX + V + II。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。</li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: “III”<br>输出: 3</p>
<p>输入: “IV”<br>输出: 4</p>
<p>输入: “IX”<br>输出: 9</p>
<p>输入: “LVIII”<br>输出: 58<br>解释: L = 50, V= 5, III = 3</p>
<p>输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; tras = &#123;&#123;<span class="string">'I'</span>, <span class="number">1</span>&#125;, &#123;<span class="string">'V'</span>, <span class="number">5</span>&#125;, &#123;<span class="string">'X'</span>, <span class="number">10</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'L'</span>, <span class="number">50</span>&#125;, &#123;<span class="string">'C'</span>, <span class="number">100</span>&#125;, &#123;<span class="string">'D'</span>, <span class="number">500</span>&#125;, &#123;<span class="string">'M'</span>, <span class="number">1000</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; s.size() - <span class="number">1</span> &amp;&amp; tras[s[i]] &lt; tras[s[i + <span class="number">1</span>]])</span><br><span class="line">            &#123;</span><br><span class="line">                res -= tras[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res += tras[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#136--只出现一次的数字</title>
    <url>/2020/03/16/leetcode136/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#136–只出现一次的数字</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：只出现一次的数字（简单）"><a href="#1-题目：只出现一次的数字（简单）" class="headerlink" title="1.题目：只出现一次的数字（简单）"></a>1.题目：只出现一次的数字（简单）</h3><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入: [2,2,1]<br>输出: 1</p>
<p>输入: [4,1,2,1,2]<br>输出: 4</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-使用集合"><a href="#1-使用集合" class="headerlink" title="(1)使用集合"></a>(1)使用集合</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; save;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> num : nums ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( save.find(num) == save.end() ) save.insert(num);</span><br><span class="line">            <span class="keyword">else</span> save.erase(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = *save.begin();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-使用哈希表"><a href="#2-使用哈希表" class="headerlink" title="(2)使用哈希表"></a>(2)使用哈希表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; save;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> num : nums ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( save.find(num) == save.end() ) save.insert(&#123;num, <span class="literal">true</span>&#125;);</span><br><span class="line">            <span class="keyword">else</span> save[num] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> iter = save.begin(); iter != save.end(); ++iter ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( iter-&gt;second == <span class="literal">true</span> ) <span class="keyword">return</span> iter-&gt;first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-排序后双指针"><a href="#3-排序后双指针" class="headerlink" title="(3)排序后双指针"></a>(3)排序后双指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort( nums.begin(), nums.end() );</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; j &lt; nums.size(); i += <span class="number">2</span>, j += <span class="number">2</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( nums[i] != nums[j] ) <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-异或"><a href="#4-异或" class="headerlink" title="(4)异或"></a>(4)异或</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> num : nums ) &#123;</span><br><span class="line">            res = res ^ num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#14--最长公共前缀</title>
    <url>/2020/02/23/leetcode14/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#14–最长公共前缀题解</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：最长公共前缀（简单）"><a href="#1-题目：最长公共前缀（简单）" class="headerlink" title="1.题目：最长公共前缀（简单）"></a>1.题目：最长公共前缀（简单）</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”</p>
<p>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><p><strong>方法:</strong></p>
<p>首先，我们将描述一种查找一组字符串的最长公共前缀LCP(S1…Sn)的简单方法。<br>我们将会用到这样的结论：<br>LCP(S1…Sn) = LCP(LCP(LCP(S1, S2), S3),…Sn)</p>
<p>为了运用这种思想，算法要依次遍历字符串{S1…Sn}，当遍历到第i个字符串的时候找到最长公共前缀LCP(S1…Si)。当LCP(S1…Si)是一个空串的时候，算法就结束了。否则，在执行了n次遍历之后，算法就会返回最终答案LCP(S1…Sn)。</p>
<img src="/2020/02/23/leetcode14/leetcode14.png">

<p><strong>实现:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> r = strs.size() ? strs[<span class="number">0</span>] : <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> s: strs)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s.substr(<span class="number">0</span>, r.size()) != r)&#123;</span><br><span class="line">                r = r.substr(<span class="number">0</span>, r.size() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(r == <span class="string">""</span>) <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#141--环形链表</title>
    <url>/2020/03/16/leetcode141/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#141–环形链表</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：环形链表（简单）"><a href="#1-题目：环形链表（简单）" class="headerlink" title="1.题目：环形链表（简单）"></a>1.题目：环形链表（简单）</h3><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-使用集合"><a href="#1-使用集合" class="headerlink" title="(1)使用集合"></a>(1)使用集合</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;ListNode*&gt; save;</span><br><span class="line">        <span class="keyword">auto</span> ptr = head;</span><br><span class="line">        <span class="keyword">while</span> ( ptr != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( save.find(ptr) != save.end() ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            save.insert(ptr);</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-快慢指针"><a href="#2-快慢指针" class="headerlink" title="(2)快慢指针"></a>(2)快慢指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> fast = head;</span><br><span class="line">        <span class="keyword">auto</span> slow = head;</span><br><span class="line">        <span class="keyword">while</span> ( fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> ( fast == slow ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#155--最小栈</title>
    <url>/2020/03/17/leetcode155/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#155–最小栈</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：最小栈（简单）"><a href="#1-题目：最小栈（简单）" class="headerlink" title="1.题目：最小栈（简单）"></a>1.题目：最小栈（简单）</h3><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) – 将元素 x 推入栈中。<br>pop() – 删除栈顶的元素。<br>top() – 获取栈顶元素。<br>getMin() – 检索栈中的最小元素。</p>
<h3 id="2-题解-辅助栈"><a href="#2-题解-辅助栈" class="headerlink" title="2.题解(辅助栈)"></a>2.题解(辅助栈)</h3><h4 id="1-两栈同步"><a href="#1-两栈同步" class="headerlink" title="(1)两栈同步"></a>(1)两栈同步</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MinStack() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>.push_back(x);</span><br><span class="line">        <span class="keyword">if</span> ( minNums.empty() ) minNums.push_back(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( x &lt; minNums.back() ) minNums.push_back(x);</span><br><span class="line">        <span class="keyword">else</span> minNums.push_back(minNums.back());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">stack</span>.empty() ) &#123;</span><br><span class="line">            <span class="built_in">stack</span>.pop_back();</span><br><span class="line">            minNums.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minNums.back();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minNums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-两栈不同步"><a href="#2-两栈不同步" class="headerlink" title="(2)两栈不同步"></a>(2)两栈不同步</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MinStack() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>.push_back(x);</span><br><span class="line">        <span class="keyword">if</span> ( minNums.empty() ) minNums.push_back(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( x &lt;= minNums.back() ) minNums.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">stack</span>.empty() ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">stack</span>.back() == minNums.back() ) minNums.pop_back();</span><br><span class="line">            <span class="built_in">stack</span>.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minNums.back();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minNums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#16--最接近的三数之和</title>
    <url>/2020/03/26/leetcode16/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#16–最接近的三数之和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：最接近的三数之和（中等）"><a href="#1-题目：最接近的三数之和（中等）" class="headerlink" title="1.题目：最接近的三数之和（中等）"></a>1.题目：最接近的三数之和（中等）</h3><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</p>
<p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p>
</blockquote>
<h3 id="2-题解-双指针"><a href="#2-题解-双指针" class="headerlink" title="2.题解(双指针)"></a>2.题解(双指针)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.size() &lt; <span class="number">3</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, minDiff = INT32_MAX;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">2</span>; ++i ) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">size_t</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ( left &lt; right ) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ( sum == target ) <span class="keyword">return</span> sum;</span><br><span class="line">                <span class="keyword">if</span> ( sum &gt; target ) &#123;</span><br><span class="line">                    diff = sum - target;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( sum &lt; target ) &#123;</span><br><span class="line">                    diff = target - sum;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( diff &lt; minDiff ) &#123;</span><br><span class="line">                    minDiff = diff;</span><br><span class="line">                    res = sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#15--三数之和</title>
    <url>/2020/03/24/leetcode15/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#15–三数之和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：三数之和（中等）"><a href="#1-题目：三数之和（中等）" class="headerlink" title="1.题目：三数之和（中等）"></a>1.题目：三数之和（中等）</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：<br>[ [-1, 0, 1],<br>[-1, -1, 2] ]</p>
</blockquote>
<h3 id="2-题解-双指针"><a href="#2-题解-双指针" class="headerlink" title="2.题解(双指针)"></a>2.题解(双指针)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> ( nums.size() &lt; <span class="number">3</span> ) <span class="keyword">return</span> ans;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">if</span>( nums[<span class="number">0</span>] &gt; <span class="number">0</span> ) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( i &lt; nums.size() )&#123;</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ( left &lt; right ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( nums[i] &gt; <span class="number">0</span> ) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 转换为long long避免加法过程中溢出</span></span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> y = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(nums[i]);</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(nums[left]);</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> z = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(nums[right]);</span><br><span class="line">                <span class="keyword">if</span> ( x + y &gt; <span class="number">0</span> - z )</span><br><span class="line">                    right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( x + y &lt; <span class="number">0</span> - z )</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.push_back(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 相同的left和right不应该再次出现，因此跳过</span></span><br><span class="line">                    <span class="keyword">while</span> ( left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>] ) left++;</span><br><span class="line">                    <span class="keyword">while</span> ( left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>] ) right--;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 避免nums[i]作为第一个数重复出现</span></span><br><span class="line">            <span class="keyword">while</span> ( i + <span class="number">1</span> &lt; nums.size() &amp;&amp; nums[i] == nums[i + <span class="number">1</span>] ) i++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#167--两数之和 II - 输入有序数组</title>
    <url>/2020/03/17/leetcode167/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#167–两数之和 II - 输入有序数组</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：两数之和-II-输入有序数组（简单）"><a href="#1-题目：两数之和-II-输入有序数组（简单）" class="headerlink" title="1.题目：两数之和 II - 输入有序数组（简单）"></a>1.题目：两数之和 II - 输入有序数组（简单）</h3><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<p>说明:</p>
<p>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p>
<h3 id="2-题解-双指针法"><a href="#2-题解-双指针法" class="headerlink" title="2.题解(双指针法)"></a>2.题解(双指针法)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = numbers.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( i &lt; j ) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[i] + numbers[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) ++i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) --j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> &#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#168--excel表列名称</title>
    <url>/2020/03/18/leetcode168/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#168–excel表列名称</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：excel表列名称"><a href="#1-题目：excel表列名称" class="headerlink" title="1.题目：excel表列名称"></a>1.题目：excel表列名称</h3><p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>1 -&gt; A<br>2 -&gt; B<br>3 -&gt; C<br>…<br>26 -&gt; Z<br>27 -&gt; AA<br>28 -&gt; AB<br>…</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span> ( n &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            res.push_back(<span class="string">'A'</span> + (n - <span class="number">1</span>) % <span class="number">26</span>);</span><br><span class="line">            n = (n - <span class="number">1</span>) / <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#160--相交链表</title>
    <url>/2020/03/17/leetcode160/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#160–相交链表</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：相交链表（简单）"><a href="#1-题目：相交链表（简单）" class="headerlink" title="1.题目：相交链表（简单）"></a>1.题目：相交链表（简单）</h3><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> ptrA = headA, ptrB = headB;</span><br><span class="line">        <span class="keyword">while</span> ( ptrA != ptrB ) &#123;</span><br><span class="line">            ptrA = ( ptrA == <span class="literal">nullptr</span> ) ? headB : ptrA-&gt;next;</span><br><span class="line">            ptrB = ( ptrB == <span class="literal">nullptr</span> ) ? headA : ptrB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptrA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#169--多数元素</title>
    <url>/2020/03/18/leetcode169/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#169–多数元素</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：多数元素"><a href="#1-题目：多数元素" class="headerlink" title="1.题目：多数元素"></a>1.题目：多数元素</h3><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="(1)哈希表"></a>(1)哈希表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; helper;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> num : nums ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( helper.find(num) == helper.end() ) helper.insert(&#123;num, <span class="number">1</span>&#125;);</span><br><span class="line">            <span class="keyword">else</span> ++helper[num];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> iter = helper.begin(); iter != helper.end(); ++iter ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( iter-&gt;second &gt; nums.size() / <span class="number">2</span> ) <span class="keyword">return</span> iter-&gt;first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-投票法"><a href="#2-投票法" class="headerlink" title="(2)投票法"></a>(2)投票法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> candidate = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == candidate)</span><br><span class="line">                ++count;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( --count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#17--电话号码的字母组合</title>
    <url>/2020/03/26/leetcode17/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#17–电话号码的字母组合</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：电话号码的字母组合（中等）"><a href="#1-题目：电话号码的字母组合（中等）" class="headerlink" title="1.题目：电话号码的字母组合（中等）"></a>1.题目：电话号码的字母组合（中等）</h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
</blockquote>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( digits.empty() ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">string</span> path; <span class="comment">//路径</span></span><br><span class="line">        backtrack(digits, res, path, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; key&#123;&#123;<span class="string">'2'</span>, <span class="string">"abc"</span>&#125;, &#123;<span class="string">'3'</span>, <span class="string">"def"</span>&#125;, &#123;<span class="string">'4'</span>, <span class="string">"ghi"</span>&#125;, &#123;<span class="string">'5'</span>, <span class="string">"jkl"</span>&#125;,</span><br><span class="line">                          &#123;<span class="string">'6'</span>, <span class="string">"mno"</span>&#125;, &#123;<span class="string">'7'</span>, <span class="string">"pqrs"</span>&#125;, &#123;<span class="string">'8'</span>, <span class="string">"tuv"</span>&#125;, &#123;<span class="string">'9'</span>, <span class="string">"wxyz"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; digits, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">string</span>&amp; path, <span class="keyword">size_t</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        <span class="keyword">if</span> ( index == digits.<span class="built_in">size</span>() ) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选择列表</span></span><br><span class="line">        <span class="built_in">string</span> alpha = key[digits[index]];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; alpha.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            path.push_back(alpha[i]); <span class="comment">// 做选择</span></span><br><span class="line">            backtrack(digits, res, path, index + <span class="number">1</span>);</span><br><span class="line">            path.pop_back(); <span class="comment">// 撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#171--excel表列序号</title>
    <url>/2020/03/19/leetcode171/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#171–excel表列序号</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：excel表列序号（简单）"><a href="#1-题目：excel表列序号（简单）" class="headerlink" title="1.题目：excel表列序号（简单）"></a>1.题目：excel表列序号（简单）</h3><p>给定一个Excel表格中的列名称，返回其相应的列序号。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>A -&gt; 1<br>B -&gt; 2<br>C -&gt; 3<br>…<br>Z -&gt; 26<br>AA -&gt; 27<br>AB -&gt; 28<br>…</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">char</span> c : s ) &#123;</span><br><span class="line">            res = res * <span class="number">26</span> + (c - <span class="string">'A'</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#172--阶乘后的0</title>
    <url>/2020/03/19/leetcode172/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#172–阶乘后的0</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：阶乘后的0（简单）"><a href="#1-题目：阶乘后的0（简单）" class="headerlink" title="1.题目：阶乘后的0（简单）"></a>1.题目：阶乘后的0（简单）</h3><p>给定一个整数 n，返回 n! 结果尾数中零的数量。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count += n / <span class="number">5</span>;</span><br><span class="line">            n = n / <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#18--四数之和</title>
    <url>/2020/03/27/leetcode18/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#18–四数之和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：四数之和（中等）"><a href="#1-题目：四数之和（中等）" class="headerlink" title="1.题目：四数之和（中等）"></a>1.题目：四数之和（中等）</h3><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p>注意：</p>
<p>答案中不可以包含重复的四元组。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</p>
<p>满足要求的四元组集合为：<br>[<br>[-1,  0, 0, 1],<br>[-2, -1, 1, 2],<br>[-2,  0, 0, 2]<br>]</p>
</blockquote>
<h3 id="2-题解-双指针"><a href="#2-题解-双指针" class="headerlink" title="2.题解(双指针)"></a>2.题解(双指针)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> ( nums.size() &lt; <span class="number">4</span> ) <span class="keyword">return</span> res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> first = <span class="number">0</span>; first &lt; nums.size() - <span class="number">3</span>; ++first ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> second = first + <span class="number">1</span>; second &lt; nums.size() - <span class="number">2</span>; ++second ) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = second + <span class="number">1</span>, j = nums.size() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> ( i &lt; j ) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[first] + nums[second] + nums[i] + nums[j];</span><br><span class="line">                    <span class="keyword">if</span> ( sum &gt; target ) --j;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ( sum &lt; target ) ++i;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.push_back(&#123;nums[first], nums[second], nums[i], nums[j]&#125;);</span><br><span class="line">                        <span class="keyword">while</span> ( i &lt; j &amp;&amp; nums[i] == nums[i + <span class="number">1</span>] ) ++i;</span><br><span class="line">                        <span class="keyword">while</span> ( i &lt; j &amp;&amp; nums[j] == nums[j - <span class="number">1</span>] ) --j;</span><br><span class="line">                        ++i, --j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> ( second &lt; nums.size() - <span class="number">2</span> &amp;&amp; nums[second] == nums[second + <span class="number">1</span>] ) ++second;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ( first &lt; nums.size() - <span class="number">3</span> &amp;&amp; nums[first] == nums[first + <span class="number">1</span>] ) ++first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#19--删除链表的倒数第N个节点</title>
    <url>/2020/03/27/leetcode19/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#19–删除链表的倒数第N个节点</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：删除链表的倒数第N个节点（中等）"><a href="#1-题目：删除链表的倒数第N个节点（中等）" class="headerlink" title="1.题目：删除链表的倒数第N个节点（中等）"></a>1.题目：删除链表的倒数第N个节点（中等）</h3><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p>
<p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p>
</blockquote>
<h3 id="2-题解-双指针"><a href="#2-题解-双指针" class="headerlink" title="2.题解(双指针)"></a>2.题解(双指针)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* look = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        look-&gt;next = head;</span><br><span class="line">        <span class="keyword">auto</span> left = look;</span><br><span class="line">        <span class="keyword">auto</span> right = look;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; ++i ) &#123;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( right != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            left = left-&gt;next;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        left-&gt;next = left-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> look-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#2--两数相加</title>
    <url>/2020/03/20/leetcode2/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#2–两数相加</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：两数相加（中等）"><a href="#1-题目：两数相加（中等）" class="headerlink" title="1.题目：两数相加（中等）"></a>1.题目：两数相加（中等）</h3><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
</blockquote>
<h3 id="2-题解-链表"><a href="#2-题解-链表" class="headerlink" title="2.题解(链表)"></a>2.题解(链表)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> head = <span class="keyword">new</span> ListNode&#123;<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">auto</span> ptr = head;</span><br><span class="line">        <span class="keyword">int</span> temp&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> ( l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( l1 != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                temp += l1-&gt;val;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( l2 != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                temp += l2-&gt;val;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr-&gt;next = <span class="keyword">new</span> ListNode&#123;temp % <span class="number">10</span>&#125;;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">            temp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( temp == <span class="number">1</span> ) &#123;</span><br><span class="line">            ptr-&gt;next = <span class="keyword">new</span> ListNode&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#20--有效的括号</title>
    <url>/2020/02/23/leetcode20/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#20–有效的括号题解</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：有效的括号（简单）"><a href="#1-题目：有效的括号（简单）" class="headerlink" title="1.题目：有效的括号（简单）"></a>1.题目：有效的括号（简单）</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: “()”<br>输出: true</p>
<p>输入: “()[]{}”<br>输出: true</p>
<p>输入: “(]”<br>输出: false</p>
<p>输入: “([)]”<br>输出: false</p>
<p>输入: “{[]}”<br>输出: true</p>
</blockquote>
<h3 id="2-题解-栈"><a href="#2-题解-栈" class="headerlink" title="2.题解(栈)"></a>2.题解(栈)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">""</span>) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//s为空串</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//s长度为奇数</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; ss;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="string">'&#123;'</span> || i == <span class="string">'('</span> || i == <span class="string">'['</span>) ss.push(i);  <span class="comment">//左括号则压栈</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ss.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//无匹配的括号</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((i == <span class="string">'&#125;'</span> &amp;&amp; ss.top() != <span class="string">'&#123;'</span>) ||</span><br><span class="line">                         (i == <span class="string">']'</span> &amp;&amp; ss.top() != <span class="string">'['</span>) ||</span><br><span class="line">                         (i == <span class="string">')'</span> &amp;&amp; ss.top() != <span class="string">'('</span>) )  <span class="comment">//匹配错误</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ss.pop();  <span class="comment">//匹配成功，出栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ss.size() != <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//最后栈非空则错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>重点:</strong></p>
<p>栈的使用</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#21--合并两个有序链表</title>
    <url>/2020/02/23/leetcode21/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#21–合并两个有序链表题解</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：合并两个有序链表（简单）"><a href="#1-题目：合并两个有序链表（简单）" class="headerlink" title="1.题目：合并两个有序链表（简单）"></a>1.题目：合并两个有序链表（简单）</h3><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* first = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* ptr = first;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                ptr-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ptr-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr-&gt;next = l1 == <span class="literal">NULL</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#22--括号生成</title>
    <url>/2020/03/28/leetcode22/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#22–括号生成</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：括号生成（中等）"><a href="#1-题目：括号生成（中等）" class="headerlink" title="1.题目：括号生成（中等）"></a>1.题目：括号生成（中等）</h3><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p><strong>示例:</strong></p>
<p>例如，给出 n = 3，生成结果为：</p>
<p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( n == <span class="number">0</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">string</span> path; <span class="comment">// 路径</span></span><br><span class="line">        backtrack(n, n, res, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        <span class="keyword">if</span> ( left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span> ) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选择列表：'(' and ')'</span></span><br><span class="line">        <span class="keyword">if</span> ( left &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            path.push_back(<span class="string">'('</span>);</span><br><span class="line">            backtrack(left - <span class="number">1</span>, right, res, path);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( right &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( left == right ) <span class="keyword">return</span>; <span class="comment">// 剪枝</span></span><br><span class="line">            path.push_back(<span class="string">')'</span>);</span><br><span class="line">            backtrack(left, right - <span class="number">1</span>, res, path);</span><br><span class="line">            path.pop_back(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#24--两两交换链表中的节点</title>
    <url>/2020/03/28/leetcode24/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#24–两两交换链表中的节点</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：两两交换链表中的节点（中等）"><a href="#1-题目：两两交换链表中的节点（中等）" class="headerlink" title="1.题目：两两交换链表中的节点（中等）"></a>1.题目：两两交换链表中的节点（中等）</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><strong>示例:</strong></p>
<p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p>
<h3 id="2-题解-深度优先搜索"><a href="#2-题解-深度优先搜索" class="headerlink" title="2.题解(深度优先搜索)"></a>2.题解(深度优先搜索)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* sentry = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        sentry-&gt;next = head;</span><br><span class="line">        ListNode* ptr = sentry;</span><br><span class="line">        <span class="keyword">while</span> (ptr-&gt;next != <span class="literal">nullptr</span> &amp;&amp; ptr-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* temp = ptr-&gt;next;</span><br><span class="line">            ptr-&gt;next = ptr-&gt;next-&gt;next;</span><br><span class="line">            temp-&gt;next = ptr-&gt;next-&gt;next;</span><br><span class="line">            ptr-&gt;next-&gt;next = temp;</span><br><span class="line">            ptr = ptr-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sentry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#29--两数相除</title>
    <url>/2020/03/29/leetcode29/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#29–两数相除</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：两数相除（中等）"><a href="#1-题目：两数相除（中等）" class="headerlink" title="1.题目：两数相除（中等）"></a>1.题目：两数相除（中等）</h3><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数 dividend 除以除数 divisor 得到的商。</p>
<p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: dividend = 10, divisor = 3<br>输出: 3<br>解释: 10/3 = truncate(3.33333..) = truncate(3) = 3</p>
</blockquote>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (divisor == <span class="number">-1</span> &amp;&amp; dividend == INT_MIN) <span class="keyword">return</span> INT_MAX; <span class="comment">//溢出</span></span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((dividend &gt; <span class="number">0</span> &amp;&amp; divisor &lt; <span class="number">0</span>) || (dividend &lt; <span class="number">0</span> &amp;&amp; divisor &gt; <span class="number">0</span>)) sign = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (divisor == <span class="number">1</span>) <span class="keyword">return</span> dividend;</span><br><span class="line">        <span class="keyword">if</span> (divisor == <span class="number">-1</span>) <span class="keyword">return</span> -dividend;</span><br><span class="line">        <span class="keyword">int</span> a = dividend &gt; <span class="number">0</span> ? -dividend : dividend;</span><br><span class="line">        <span class="keyword">int</span> b = divisor &gt; <span class="number">0</span> ? -divisor : divisor;</span><br><span class="line">        <span class="keyword">int</span> ans = div(a, b);</span><br><span class="line">        <span class="keyword">return</span> sign == <span class="number">-1</span> ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tb = b;</span><br><span class="line">        <span class="keyword">while</span> (tb &gt;= INT_MIN - tb &amp;&amp; tb + tb &gt;= a)</span><br><span class="line">        &#123;</span><br><span class="line">            tb += tb;</span><br><span class="line">            count += count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count + div(a - tb, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#26--删除排序数组中的重复项</title>
    <url>/2020/02/27/leetcode26/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#26–删除排序数组中的重复项</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：删除排序数组中的重复项（简单）"><a href="#1-题目：删除排序数组中的重复项（简单）" class="headerlink" title="1.题目：删除排序数组中的重复项（简单）"></a>1.题目：删除排序数组中的重复项（简单）</h3><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>
<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-删除元素法-不好"><a href="#1-删除元素法-不好" class="headerlink" title="(1)删除元素法(不好)"></a>(1)删除元素法(不好)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.size() == <span class="number">0</span> )  <span class="comment">//处理边界情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> iter = nums.begin() + <span class="number">1</span>; iter != nums.end(); ++iter )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( *iter == *(iter - <span class="number">1</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                nums.erase(iter);  <span class="comment">//将该元素删除</span></span><br><span class="line">                --iter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行用时：352ms</p>
<p>vector将元素保存在<strong>连续</strong>的内存空间中，所以在vector的中间位置进行插入和删除元素将非常耗时：<br>在一次插入或删除操作后，需要移动插入/删除位置之后的所有元素，来保持连续存储。<br>因此双指针法是更好的选择。由于C++不推荐使用指针，所以用迭代器来代替指针。</p>
<h4 id="2-双指针法"><a href="#2-双指针法" class="headerlink" title="(2)双指针法"></a>(2)双指针法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">//先处理特殊情况，否则会产生执行错误</span></span><br><span class="line">    <span class="keyword">if</span> (nums.size() == <span class="number">0</span>)  <span class="comment">//所给数组为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> itr1&#123; nums.begin() &#125;;  <span class="comment">//指针1指向第一个元素</span></span><br><span class="line">    <span class="keyword">auto</span> itr2&#123; nums.begin() + <span class="number">1</span>&#125;;  <span class="comment">//指针2指向第二个元素</span></span><br><span class="line">    <span class="keyword">for</span> (; itr2 != nums.end(); ++itr2)  <span class="comment">//遍历数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*itr2 != * itr1)  <span class="comment">//发现和指针1不相同的数</span></span><br><span class="line">        &#123;</span><br><span class="line">            itr1 += <span class="number">1</span>;  <span class="comment">//指针1向后移动一个元素</span></span><br><span class="line">            *itr1 = *itr2;  <span class="comment">//修改指针1的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> itr1 - nums.begin() + <span class="number">1</span>;  <span class="comment">//返回数组长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行用时：28ms</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#27--移除元素</title>
    <url>/2020/02/27/leetcode27/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#27–移除元素</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：移除元素（简单）"><a href="#1-题目：移除元素（简单）" class="headerlink" title="1.题目：移除元素（简单）"></a>1.题目：移除元素（简单）</h3><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定 nums = [3,2,2,3], val = 3,<br>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>
<p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,<br>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>注意这五个元素可为任意顺序。<br>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.size() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> beg = nums.begin();</span><br><span class="line">        <span class="keyword">auto</span> bac = nums.end() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( beg != bac )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( *beg == val )</span><br><span class="line">            &#123;</span><br><span class="line">                swap(*beg, *bac);</span><br><span class="line">                --bac;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++beg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( *beg == val )</span><br><span class="line">        &#123;</span><br><span class="line">            --beg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beg - nums.begin() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>改进：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.size() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> beg = nums.begin();</span><br><span class="line">        <span class="keyword">auto</span> bac = nums.end() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( beg &lt;= bac )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( *beg == val )</span><br><span class="line">            &#123;</span><br><span class="line">                swap(*beg, *bac);</span><br><span class="line">                --bac;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++beg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bac - nums.begin() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#3--无重复字符的最长子串</title>
    <url>/2020/03/20/leetcode3/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#3–无重复字符的最长子串</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：无重复字符的最长子串（中等）"><a href="#1-题目：无重复字符的最长子串（中等）" class="headerlink" title="1.题目：无重复字符的最长子串（中等）"></a>1.题目：无重复字符的最长子串（中等）</h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串的长度</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
</blockquote>
<h3 id="2-题解-滑动窗口"><a href="#2-题解-滑动窗口" class="headerlink" title="2.题解(滑动窗口)"></a>2.题解(滑动窗口)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( s.size() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; lookup;</span><br><span class="line">        <span class="keyword">int</span> maxStr&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> left&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i&#123;<span class="number">0</span>&#125;; i &lt; s.size(); ++i )&#123;</span><br><span class="line">            <span class="keyword">while</span> ( lookup.find(s[i]) != lookup.end() )&#123;</span><br><span class="line">                lookup.erase(s[left]);</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            maxStr = max(maxStr, i - left + <span class="number">1</span>);</span><br><span class="line">            lookup.insert(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#31--下一个排列</title>
    <url>/2020/03/29/leetcode31/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#31–下一个排列</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：下一个排列（中等）"><a href="#1-题目：下一个排列（中等）" class="headerlink" title="1.题目：下一个排列（中等）"></a>1.题目：下一个排列（中等）</h3><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须原地修改，只允许使用额外常数空间。</p>
<p><strong>示例:</strong></p>
<p>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> left = nums.end();</span><br><span class="line">        --left;</span><br><span class="line">        <span class="keyword">while</span> ( left != nums.begin() &amp;&amp; *left &lt;= *(left - <span class="number">1</span>) ) --left;</span><br><span class="line">        <span class="keyword">if</span> ( left == nums.begin() ) sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> right = left + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ( right != nums.end() &amp;&amp; *right &gt; *(left - <span class="number">1</span>) ) ++right;</span><br><span class="line">            swap(*(left - <span class="number">1</span>), *(right - <span class="number">1</span>));</span><br><span class="line">            sort(left, nums.end());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#33--搜索旋转排序数组</title>
    <url>/2020/03/31/leetcode33/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#33–搜索旋转排序数组</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：搜索旋转排序数组（中等）"><a href="#1-题目：搜索旋转排序数组（中等）" class="headerlink" title="1.题目：搜索旋转排序数组（中等）"></a>1.题目：搜索旋转排序数组（中等）</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p><strong>示例:</strong></p>
<p>输入: nums = [4,5,6,7,0,1,2], target = 0<br>输出: 4</p>
<h3 id="2-题解-二分法"><a href="#2-题解-二分法" class="headerlink" title="2.题解(二分法)"></a>2.题解(二分法)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.empty() ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//闭区间</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( left &lt;= right ) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//若找到了</span></span><br><span class="line">            <span class="keyword">if</span> ( nums[mid] == target ) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">//若左面有序</span></span><br><span class="line">            <span class="keyword">if</span> ( nums[left] &lt;= nums[mid] ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( nums[left] &lt;= target &amp;&amp; target &lt; nums[mid] ) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若右面有序</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( nums[mid] &lt; target &amp;&amp; target &lt;= nums[right] ) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分法</tag>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#34--在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2020/03/31/leetcode34/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#34–在排序数组中查找元素的第一个和最后一个位置</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：在排序数组中查找元素的第一个和最后一个位置（中等）"><a href="#1-题目：在排序数组中查找元素的第一个和最后一个位置（中等）" class="headerlink" title="1.题目：在排序数组中查找元素的第一个和最后一个位置（中等）"></a>1.题目：在排序数组中查找元素的第一个和最后一个位置（中等）</h3><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<p><strong>示例:</strong></p>
<p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]</p>
<h3 id="2-题解-二分法"><a href="#2-题解-二分法" class="headerlink" title="2.题解(二分法)"></a>2.题解(二分法)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; searchRange(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty() ) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;searchLeftBound(nums, target), searchRightBound(nums, target)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchLeftBound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size();</span><br><span class="line">        <span class="keyword">while</span> ( left &lt; right ) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ( nums[mid] == target ) right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( nums[mid] &gt; target ) right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( nums[mid] &lt; target ) left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( left &gt; nums.size() - <span class="number">1</span> || nums[left] != target ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchRightBound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size();</span><br><span class="line">        <span class="keyword">while</span> ( left &lt; right ) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ( nums[mid] == target ) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( nums[mid] &gt; target ) right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( nums[mid] &lt; target ) left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( left == <span class="number">0</span> || nums[left - <span class="number">1</span>] != target ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分法</tag>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#28--实现strStr()</title>
    <url>/2020/02/27/leetcode28/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#28–实现strStr()</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：实现strStr-（简单）"><a href="#1-题目：实现strStr-（简单）" class="headerlink" title="1.题目：实现strStr()（简单）"></a>1.题目：实现strStr()（简单）</h3><p>实现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: haystack = “hello”, needle = “ll”<br>输出: 2</p>
<p>输入: haystack = “aaaaa”, needle = “bba”<br>输出: -1</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-标准库法"><a href="#1-标准库法" class="headerlink" title="(1)标准库法"></a>(1)标准库法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( needle.empty() ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = haystack.find(needle);</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用string的成员函数find()</p>
<h4 id="2-BF解法，双指针法"><a href="#2-BF解法，双指针法" class="headerlink" title="(2)BF解法，双指针法"></a>(2)BF解法，双指针法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( needle.empty() ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( haystack[i] != <span class="string">'\0'</span> &amp;&amp; needle[j] != <span class="string">'\0'</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( haystack[i] == needle[j] )</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i = i - j + <span class="number">1</span>;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( needle[j] == <span class="string">'\0'</span> ) <span class="keyword">return</span> i - j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#35--搜索插入位置</title>
    <url>/2020/02/28/leetcode35/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#35–搜索插入位置</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：搜索插入位置（简单）"><a href="#1-题目：搜索插入位置（简单）" class="headerlink" title="1.题目：搜索插入位置（简单）"></a>1.题目：搜索插入位置（简单）</h3><p>实现 strStr() 函数。<br>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: [1,3,5,6], 5<br>输出: 2</p>
<p>输入: [1,3,5,6], 2<br>输出: 1</p>
<p>输入: [1,3,5,6], 7<br>输出: 4</p>
<p>输入: [1,3,5,6], 0<br>输出: 0</p>
</blockquote>
<h3 id="2-题解-二分法"><a href="#2-题解-二分法" class="headerlink" title="2.题解(二分法)"></a>2.题解(二分法)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( left &lt;= right ) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ( target == nums[mid] ) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( target &lt; nums[mid] ) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( nums[mid] &lt; target ) left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分法</tag>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#36--有效的数独</title>
    <url>/2020/04/08/leetcode36/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#36–有效的数独</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：有效的数独（中等）"><a href="#1-题目：有效的数独（中等）" class="headerlink" title="1.题目：有效的数独（中等）"></a>1.题目：有效的数独（中等）</h3><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>
<p><strong>示例:</strong></p>
<p>输入:<br>[<br>  [“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>输出: true</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 整个board有9行，第二维的维数10是为了让下标有9，和数独中的数字9对应。</span></span><br><span class="line">        <span class="keyword">int</span> row[<span class="number">9</span>][<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 哈希表存储每一行的每个数是否出现过，默认初始情况下，每一行每一个数都没有出现过</span></span><br><span class="line">        <span class="keyword">int</span> col[<span class="number">9</span>][<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 存储每一列的每个数是否出现过，默认初始情况下，每一列的每一个数都没有出现过</span></span><br><span class="line">        <span class="keyword">int</span> box[<span class="number">9</span>][<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 存储每一个box的每个数是否出现过，默认初始情况下，在每个box中，每个数都没有出现过。整个board有9个box。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 遍历到第i行第j列的那个数,我们要判断这个数在其所在的行有没有出现过，</span></span><br><span class="line">                <span class="comment">// 同时判断这个数在其所在的列有没有出现过</span></span><br><span class="line">                <span class="comment">// 同时判断这个数在其所在的box中有没有出现过</span></span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> curNumber = board[i][j] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span> (row[i][curNumber]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (col[j][curNumber]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (box[j / <span class="number">3</span> + (i / <span class="number">3</span>) * <span class="number">3</span>][curNumber]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 之前都没出现过，现在出现了，就给它置为1，下次再遇见就能够直接返回false了。</span></span><br><span class="line">                row[i][curNumber] = <span class="number">1</span>;</span><br><span class="line">                col[j][curNumber] = <span class="number">1</span>;</span><br><span class="line">                box[j / <span class="number">3</span> + (i / <span class="number">3</span>) * <span class="number">3</span>][curNumber] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#38--外观数列</title>
    <url>/2020/02/28/leetcode38/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#38–外观数列</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：外观数列（简单）"><a href="#1-题目：外观数列（简单）" class="headerlink" title="1.题目：外观数列（简单）"></a>1.题目：外观数列（简单）</h3><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p>
<ol>
<li>1</li>
<li>11</li>
<li>21</li>
<li>1211</li>
<li>111221</li>
</ol>
<p>1 被读作  “one 1”  (“一个一”) , 即 11。<br>11 被读作 “two 1s” (“两个一”）, 即 21。<br>21 被读作 “one 2”,  “one 1” （”一个二” ,  “一个一”) , 即 1211。</p>
<p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。</p>
<p>注意：整数序列中的每一项将表示为一个字符串。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 1<br>输出: “1”<br>解释：这是一个基本样例。</p>
<p>输入: 4<br>输出: “1211”<br>解释：当 n = 3 时，序列是 “21”，其中我们有 “2” 和 “1” 两组，”2” 可以读作 “12”，也就是出现频次 = 1 而 值 = 2；类似 “1” 可以读作 “11”。所以答案是 “12” 和 “11” 组合在一起，也就是 “1211”。</p>
</blockquote>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( n == <span class="number">1</span> ) <span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="built_in">string</span> last = countAndSay(n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; last.size(); ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( last[i] == last[i + <span class="number">1</span>] ) ++count;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// res.push_back(count + '0');</span></span><br><span class="line">                <span class="comment">// res.push_back(last[i]);</span></span><br><span class="line">                res += to_string(count) + last[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#39--组合总和</title>
    <url>/2020/04/09/leetcode39/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#39–组合总和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：组合总和（中等）"><a href="#1-题目：组合总和（中等）" class="headerlink" title="1.题目：组合总和（中等）"></a>1.题目：组合总和（中等）</h3><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。</p>
<p><strong>示例:</strong></p>
<p>输入: candidates = [2,3,5], target = 8,<br>所求解集为:<br>[<br>  [2,2,2,2],<br>  [2,3,3],<br>  [3,5]<br>]</p>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( candidates.empty() ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 路径</span></span><br><span class="line">        sort(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        backtrack(candidates, target, res, path, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        <span class="keyword">if</span> ( target == <span class="number">0</span> ) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可选列表</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = start; i &lt; candidates.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( candidates[i] &gt; target ) <span class="keyword">continue</span>; <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="comment">// 操作</span></span><br><span class="line">            path.push_back(candidates[i]);</span><br><span class="line">            backtrack(candidates, target - candidates[i], res, path, i);</span><br><span class="line">            <span class="comment">// 撤销操作</span></span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#40--组合总和2</title>
    <url>/2020/04/09/leetcode40/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#40–组合总和2</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：组合总和（中等）"><a href="#1-题目：组合总和（中等）" class="headerlink" title="1.题目：组合总和（中等）"></a>1.题目：组合总和（中等）</h3><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>说明：</p>
<p>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。</p>
<p><strong>示例:</strong></p>
<p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]</p>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( candidates.empty() ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 路径</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(candidates.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        sort(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        backtrack(candidates, target, res, path, <span class="number">0</span>, visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        <span class="keyword">if</span> ( target == <span class="number">0</span> ) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可选列表</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = start; i &lt; candidates.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( candidates[i] &gt; target ) <span class="keyword">continue</span>; <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="keyword">if</span> ( i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; visited[i - <span class="number">1</span>] == <span class="literal">false</span>) <span class="keyword">continue</span>; <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="comment">// 操作</span></span><br><span class="line">            path.push_back(candidates[i]);</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            backtrack(candidates, target - candidates[i], res, path, i + <span class="number">1</span>, visited);</span><br><span class="line">            <span class="comment">// 撤销操作</span></span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#43--字符串相乘</title>
    <url>/2020/04/09/leetcode43/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#43–字符串相乘</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：字符串相乘（中等）"><a href="#1-题目：字符串相乘（中等）" class="headerlink" title="1.题目：字符串相乘（中等）"></a>1.题目：字符串相乘（中等）</h3><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<p><strong>示例:</strong></p>
<p>输入: num1 = “123”, num2 = “456”<br>输出: “56088”</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">if</span> ( num1 == <span class="string">"0"</span> || num2 == <span class="string">"0"</span> ) <span class="keyword">return</span> res;</span><br><span class="line">        reverse(num2.begin(), num2.end());</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num2.size(); ++i ) &#123;</span><br><span class="line">            <span class="built_in">string</span> temp = mul(num1, num2[i]);</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j ) temp.push_back(<span class="string">'0'</span>);</span><br><span class="line">            res = add(res, temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">mul</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> x = c - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = num.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i ) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = num[i] - <span class="string">'0'</span>;</span><br><span class="line">            temp += x * y;</span><br><span class="line">            res.push_back(temp % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">            temp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( temp != <span class="number">0</span> ) res.push_back(temp + <span class="string">'0'</span>);</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = num1.size() - <span class="number">1</span>, j = num2.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>; --i, --j ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( i &gt;= <span class="number">0</span> ) temp += num1[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> ( j &gt;= <span class="number">0</span> ) temp += num2[j] - <span class="string">'0'</span>;</span><br><span class="line">            res.push_back(temp % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">            temp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( temp != <span class="number">0</span> ) res.push_back(temp + <span class="string">'0'</span>);</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#46--全排列</title>
    <url>/2020/04/10/leetcode46/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#46–全排列</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：全排列（中等）"><a href="#1-题目：全排列（中等）" class="headerlink" title="1.题目：全排列（中等）"></a>1.题目：全排列（中等）</h3><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<p><strong>示例:</strong></p>
<p>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.empty() ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 路径</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(nums.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        backtrack(nums, res, path, visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        <span class="keyword">if</span> ( path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>() ) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可选列表</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( visited[i] == <span class="literal">true</span> ) <span class="keyword">continue</span>; <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="comment">// 操作</span></span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            backtrack(nums, res, path, visited);</span><br><span class="line">            <span class="comment">// 撤销操作</span></span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#47--全排列2</title>
    <url>/2020/04/10/leetcode47/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#47–全排列2</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：全排列2（中等）"><a href="#1-题目：全排列2（中等）" class="headerlink" title="1.题目：全排列2（中等）"></a>1.题目：全排列2（中等）</h3><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p><strong>示例:</strong></p>
<p>输入: [1,1,2]<br>输出:<br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]</p>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.empty() ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 路径</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(nums.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        backtrack(nums, res, path, visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        <span class="keyword">if</span> ( path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>() ) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可选列表</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( visited[i] == <span class="literal">true</span> ) <span class="keyword">continue</span>; <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="keyword">if</span> ( i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; visited[i - <span class="number">1</span>] == <span class="literal">false</span> ) <span class="keyword">continue</span>; <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="comment">// 操作</span></span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            backtrack(nums, res, path, visited);</span><br><span class="line">            <span class="comment">// 撤销操作</span></span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#48--旋转图像</title>
    <url>/2020/04/11/leetcode48/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#48–旋转图像</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：旋转图像（中等）"><a href="#1-题目：旋转图像（中等）" class="headerlink" title="1.题目：旋转图像（中等）"></a>1.题目：旋转图像（中等）</h3><p>给定一个 n × n 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p>说明：</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<p><strong>示例:</strong></p>
<p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( matrix.size() &lt; <span class="number">2</span> )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; matrix.size(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( i != j )</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> &amp;v : matrix )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = matrix.size() - <span class="number">1</span>; i &lt; j; ++i, --j)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(v[i], v[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#49--字母异位词分组</title>
    <url>/2020/04/11/leetcode49/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#49–字母异位词分组</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：字母异位词分组（中等）"><a href="#1-题目：字母异位词分组（中等）" class="headerlink" title="1.题目：字母异位词分组（中等）"></a>1.题目：字母异位词分组（中等）</h3><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p><strong>示例:</strong></p>
<p>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>输出:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;strs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; save;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> s = str;</span><br><span class="line">            sort(s.begin(), s.end());</span><br><span class="line">            <span class="keyword">if</span> (save.find(s) == save.end())</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;());</span><br><span class="line">                res[num].push_back(str);</span><br><span class="line">                save.insert(&#123;s, num&#125;);</span><br><span class="line">                ++num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res[save[s]].push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#5--最长回文子串</title>
    <url>/2020/03/21/leetcode5/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#5–最长回文子串</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：最长回文子串（中等）"><a href="#1-题目：最长回文子串（中等）" class="headerlink" title="1.题目：最长回文子串（中等）"></a>1.题目：最长回文子串（中等）</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="(1) 动态规划"></a>(1) 动态规划</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( s.<span class="built_in">size</span>() &lt; <span class="number">2</span> ) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(s.<span class="built_in">size</span>()))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>; <span class="comment">// 记录最长回文子串的起始位置</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>; <span class="comment">// 记录最长回文子串的长度</span></span><br><span class="line">        <span class="comment">// l为子串左侧边界索引，r为子串右侧边界索引</span></span><br><span class="line">        <span class="comment">// 遍历所有子串，判断其是否是回文子串，并记录最长回文子串</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> r = <span class="number">1</span>; r &lt; s.<span class="built_in">size</span>(); ++r ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> l = <span class="number">0</span>; l &lt; r; ++l ) &#123;</span><br><span class="line">                <span class="comment">// 判断是否是回文子串(动态规划)</span></span><br><span class="line">                <span class="keyword">if</span> ( s[l] == s[r] ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( r - l &lt; <span class="number">3</span> ) dp[l][r] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[l][r] = dp[l + <span class="number">1</span>][r - <span class="number">1</span>]; <span class="comment">// 状态转移方程</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dp[l][r] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最长回文子串</span></span><br><span class="line">                <span class="keyword">if</span> ( dp[l][r] == <span class="literal">true</span> ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( r - l + <span class="number">1</span> &gt; maxLen ) &#123;</span><br><span class="line">                        maxLen = r - l + <span class="number">1</span>;</span><br><span class="line">                        start = l;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-中心扩散"><a href="#2-中心扩散" class="headerlink" title="(2) 中心扩散"></a>(2) 中心扩散</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( s.<span class="built_in">size</span>() &lt; <span class="number">2</span> ) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> maxLen&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i&#123;<span class="number">0</span>&#125;; i &lt; s.<span class="built_in">size</span>() - <span class="number">1</span>; ++i ) &#123;</span><br><span class="line">            <span class="built_in">string</span> oddStr = helper(s, i, i);</span><br><span class="line">            <span class="built_in">string</span> evenStr = helper(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">string</span> subStr = oddStr.<span class="built_in">size</span>() &gt; evenStr.<span class="built_in">size</span>() ? oddStr : evenStr;</span><br><span class="line">            <span class="keyword">if</span> ( subStr.<span class="built_in">size</span>() &gt;= maxLen ) &#123;</span><br><span class="line">                res = subStr;</span><br><span class="line">                maxLen = res.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ( i &gt;= <span class="number">0</span> &amp;&amp; j &lt; s.<span class="built_in">size</span>() ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( s[i] == s[j] ) --i, ++j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(i + <span class="number">1</span>, j - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#50--Pow(x,n)</title>
    <url>/2020/04/12/leetcode50/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#50–Pow(x,n)</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：Pow-x-n-（中等）"><a href="#1-题目：Pow-x-n-（中等）" class="headerlink" title="1.题目：Pow(x,n)（中等）"></a>1.题目：Pow(x,n)（中等）</h3><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>
<p><strong>示例:</strong></p>
<p>输入: 2.00000, 10<br>输出: 1024.00000</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> half = fastPow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> half * half;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> half * half * x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            N = -N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastPow(x, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#53--最大子序和</title>
    <url>/2020/03/02/leetcode53/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#53–最大子序和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：最大子序和（简单）"><a href="#1-题目：最大子序和（简单）" class="headerlink" title="1.题目：最大子序和（简单）"></a>1.题目：最大子序和（简单）</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-暴力双循环-不好"><a href="#1-暴力双循环-不好" class="headerlink" title="(1)暴力双循环(不好)"></a>(1)暴力双循环(不好)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值</span></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = INT32_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="built_in">max</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">max</span> = sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="(2)动态规划"></a>(2)动态规划</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]表示nums中以nums[i]结尾的最大子序和</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = dp[<span class="number">0</span>]; <span class="comment">// 记录最大子序和</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + nums[i], nums[i]); <span class="comment">// 状态转移方程</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-贪心算法"><a href="#3-贪心算法" class="headerlink" title="(3)贪心算法"></a>(3)贪心算法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值</span></span><br><span class="line">        <span class="keyword">int</span> result = INT32_MIN;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            result = <span class="built_in">max</span>(result, sum);</span><br><span class="line">            <span class="comment">//如果sum &lt; 0，重新开始找子序串</span></span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#54--螺旋矩阵</title>
    <url>/2020/04/12/leetcode54/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#54–螺旋矩阵</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：螺旋矩阵（中等）"><a href="#1-题目：螺旋矩阵（中等）" class="headerlink" title="1.题目：螺旋矩阵（中等）"></a>1.题目：螺旋矩阵（中等）</h3><p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>
<p><strong>示例:</strong></p>
<p>输入:<br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]<br>输出: [1,2,3,6,9,8,7,4,5]</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; spiralOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty()) <span class="keyword">return</span> ans; <span class="comment">//若数组为空，直接返回答案</span></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>; <span class="comment">//赋值上下左右边界</span></span><br><span class="line">        <span class="keyword">int</span> d = matrix.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; ++i) ans.push_back(matrix[u][i]); <span class="comment">//向右移动直到最右</span></span><br><span class="line">            <span class="keyword">if</span>(++ u &gt; d) <span class="keyword">break</span>; <span class="comment">//重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = u; i &lt;= d; ++i) ans.push_back(matrix[i][r]); <span class="comment">//向下</span></span><br><span class="line">            <span class="keyword">if</span>(-- r &lt; l) <span class="keyword">break</span>; <span class="comment">//重新设定有边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &gt;= l; --i) ans.push_back(matrix[d][i]); <span class="comment">//向左</span></span><br><span class="line">            <span class="keyword">if</span>(-- d &lt; u) <span class="keyword">break</span>; <span class="comment">//重新设定下边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = d; i &gt;= u; --i) ans.push_back(matrix[i][l]); <span class="comment">//向上</span></span><br><span class="line">            <span class="keyword">if</span>(++ l &gt; r) <span class="keyword">break</span>; <span class="comment">//重新设定左边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#55--跳跃游戏</title>
    <url>/2020/04/13/leetcode55/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#55–跳跃游戏</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：跳跃游戏（中等）"><a href="#1-题目：跳跃游戏（中等）" class="headerlink" title="1.题目：跳跃游戏（中等）"></a>1.题目：跳跃游戏（中等）</h3><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<p><strong>示例:</strong></p>
<p>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastPos = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= lastPos) &#123;</span><br><span class="line">                lastPos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastPos == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#56--合并区间</title>
    <url>/2020/04/13/leetcode56/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#56–合并区间</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：合并区间（中等）"><a href="#1-题目：合并区间（中等）" class="headerlink" title="1.题目：合并区间（中等）"></a>1.题目：合并区间（中等）</h3><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p><strong>示例:</strong></p>
<p>输入: [[1,3],[2,6],[8,10],[15,18]]<br>输出: [[1,6],[8,10],[15,18]]<br>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; merge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( intervals.empty() ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        sort(intervals.begin(), intervals.end(),</span><br><span class="line">            [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; x, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; y) &#123; <span class="keyword">return</span> x[<span class="number">0</span>] &lt; y[<span class="number">0</span>]; &#125;);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(<span class="number">1</span>, intervals[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( intervals[i][<span class="number">0</span>] &gt; res.back()[<span class="number">1</span>] ) res.push_back(intervals[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( intervals[i][<span class="number">1</span>] &gt; res.back()[<span class="number">1</span>] ) res.back()[<span class="number">1</span>] = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#58--最后一个单词的长度</title>
    <url>/2020/03/02/leetcode58/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#58–最后一个单词的长度</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：外观数列（简单）"><a href="#1-题目：外观数列（简单）" class="headerlink" title="1.题目：外观数列（简单）"></a>1.题目：外观数列（简单）</h3><p>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串 s，返回其最后一个单词的长度。</p>
<p>如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。</p>
<p>如果不存在最后一个单词，请返回 0 。</p>
<p>说明：一个单词是指仅由字母组成、不包含任何空格的 最大子字符串。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: “Hello World”<br>输出: 5</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-使用sstream正序遍历-不好"><a href="#1-使用sstream正序遍历-不好" class="headerlink" title="(1)使用sstream正序遍历(不好)"></a>(1)使用sstream正序遍历(不好)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">in</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (in &gt;&gt; res)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-逆序遍历"><a href="#2-逆序遍历" class="headerlink" title="(2)逆序遍历"></a>(2)逆序遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( s[i] == <span class="string">' '</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( count == <span class="number">0</span> ) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ( count &gt; <span class="number">0</span> ) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#6--Z字形变换</title>
    <url>/2020/03/22/leetcode6/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#6–Z字形变换</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：Z字形变换（中等）"><a href="#1-题目：Z字形变换（中等）" class="headerlink" title="1.题目：Z字形变换（中等）"></a>1.题目：Z字形变换（中等）</h3><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: s = “LEETCODEISHIRING”, numRows = 4<br>输出: “LDREOEIIECIHNTSG”<br>解释:</p>
<p>L     D     R<br>E   O E   I I<br>E C   I H   N<br>T     S     G</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( numRows &lt; <span class="number">2</span> ) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; save(numRows);</span><br><span class="line">        <span class="keyword">int</span> i&#123;<span class="number">0</span>&#125;, flag&#123;<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> c : s ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( i == <span class="number">0</span> || i == numRows - <span class="number">1</span> ) flag = -flag;</span><br><span class="line">            save[i].push_back(c);</span><br><span class="line">            i = i + flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> s : save ) &#123;</span><br><span class="line">            res += s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#59--螺旋矩阵2</title>
    <url>/2020/04/14/leetcode59/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#59–螺旋矩阵2</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：螺旋矩阵2（中等）"><a href="#1-题目：螺旋矩阵2（中等）" class="headerlink" title="1.题目：螺旋矩阵2（中等）"></a>1.题目：螺旋矩阵2（中等）</h3><p>给定一个正整数 <em>n</em>，生成一个包含 1 到 <em>n</em>2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
<p><strong>示例:</strong></p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 输入: 3</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 输出:</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  [ 1, 2, 3 ],</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  [ 8, 9, 4 ],</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  [ 7, 6, 5 ]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ]</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( n == <span class="number">0</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">0</span>, down = n - <span class="number">1</span>, left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( num &lt;= n * n ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = left; i &lt;= right; ++i ) res[up][i] = num++;</span><br><span class="line">            up++;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = up; i &lt;= down; ++i ) res[i][right] = num++;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = right; i &gt;= left; --i ) res[down][i] = num++;</span><br><span class="line">            down--;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = down; i &gt;= up; --i ) res[i][left] = num++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>#### </p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#60--第K个排列</title>
    <url>/2020/04/14/leetcode60/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#60–第K个排列</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：第K个排列（中等）"><a href="#1-题目：第K个排列（中等）" class="headerlink" title="1.题目：第K个排列（中等）"></a>1.题目：第K个排列（中等）</h3><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p>
<p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>给定 n 和 k，返回第 k 个排列。</p>
<p>说明：</p>
<p>给定 n 的范围是 [1, 9]。<br>给定 k 的范围是[1,  n!]。</p>
<p><strong>示例:</strong></p>
<blockquote>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">n</span> = <span class="number">3</span>, <span class="attr">k</span> = <span class="number">3</span></span><br><span class="line">输出: <span class="string">"213"</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">// 将 n! 种排列分为：n 组，每组有 (n - 1)! 种排列</span></span><br><span class="line">        <span class="keyword">return</span> recursive(n, factorial(n - <span class="number">1</span>), k, visited);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param n 剩余的数字个数，递减</span></span><br><span class="line"><span class="comment">     * @param f 每组的排列个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">recursive</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> f, <span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 计算组别与偏移量</span></span><br><span class="line">        <span class="keyword">int</span> offset = (k - <span class="number">1</span>) % f; <span class="comment">// 组内偏移量，从0开始计数</span></span><br><span class="line">        <span class="keyword">int</span> groupIndex = (k - <span class="number">1</span>) / f; <span class="comment">// 第几组，从0开始计数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据组别找到第一个数字</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; visited.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( visited[i] == <span class="literal">false</span> ) --groupIndex;</span><br><span class="line">            <span class="keyword">if</span> ( groupIndex &lt; <span class="number">0</span> ) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i] = <span class="literal">true</span>;<span class="comment">// 标记为已访问</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归求解</span></span><br><span class="line">        <span class="keyword">if</span> ( n &gt; <span class="number">1</span> ) <span class="keyword">return</span> to_string(i + <span class="number">1</span>) + recursive(n - <span class="number">1</span>, factorial(n - <span class="number">2</span>), offset + <span class="number">1</span>, visited);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> to_string(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求 n!</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">            res *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#61--旋转链表</title>
    <url>/2020/04/15/leetcode61/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#61–旋转链表</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：旋转链表（中等）"><a href="#1-题目：旋转链表（中等）" class="headerlink" title="1.题目：旋转链表（中等）"></a>1.题目：旋转链表（中等）</h3><p>给定一个链表，旋转链表，将链表每个节点向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
<p><strong>示例:</strong></p>
<blockquote>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">&gt; 输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL, k = <span class="number">2</span></span><br><span class="line">&gt; 输出: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;NULL</span><br><span class="line">&gt; 解释:</span><br><span class="line">&gt; 向右旋转 <span class="number">1</span> 步: <span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br><span class="line">&gt; 向右旋转 <span class="number">2</span> 步: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;NULL</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base cases</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// close the linked list into the ring</span></span><br><span class="line">    ListNode* old_tail = head;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">for</span>(n = <span class="number">1</span>; old_tail-&gt;next != <span class="literal">nullptr</span>; n++)</span><br><span class="line">      old_tail = old_tail-&gt;next;</span><br><span class="line">    old_tail-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find new tail : (n - k % n - 1)th node</span></span><br><span class="line">    <span class="comment">// and new head : (n - k % n)th node</span></span><br><span class="line">    ListNode* new_tail = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k % n - <span class="number">1</span>; i++)</span><br><span class="line">      new_tail = new_tail-&gt;next;</span><br><span class="line">    ListNode* new_head = new_tail-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// break the ring</span></span><br><span class="line">    new_tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#62--不同路径</title>
    <url>/2020/04/15/leetcode62/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#62–不同路径</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：不同路径（中等）"><a href="#1-题目：不同路径（中等）" class="headerlink" title="1.题目：不同路径（中等）"></a>1.题目：不同路径（中等）</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><strong>示例:</strong></p>
<blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 <span class="number">3</span> 条路径可以到达右下角。</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line"><span class="number">3.</span> 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-题解-动态规划"><a href="#2-题解-动态规划" class="headerlink" title="2.题解 (动态规划)"></a>2.题解 (动态规划)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">        <span class="comment">// 计算dp数组第一行</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i ) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算dp数组第一列</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i ) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算dp数组其余位置</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j ) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j]; <span class="comment">// 状态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#63--不同路径2</title>
    <url>/2020/04/16/leetcode63/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#63–不同路径2</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：不同路径2（中等）"><a href="#1-题目：不同路径2（中等）" class="headerlink" title="1.题目：不同路径2（中等）"></a>1.题目：不同路径2（中等）</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><strong>示例:</strong></p>
<blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释:</span><br><span class="line"><span class="number">3</span>x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 <span class="number">2</span> 条不同的路径：</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-题解-动态规划"><a href="#2-题解-动态规划" class="headerlink" title="2.题解(动态规划)"></a>2.题解(动态规划)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || obstacleGrid.back().back() == <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt; <span class="title">dp</span><span class="params">(obstacleGrid.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;(obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>()))</span></span>;</span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算dp数组第一行</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span> ) dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算dp数组第二行</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; obstacleGrid.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span> ) dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算dp数组其余位置</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; obstacleGrid.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( obstacleGrid[i][j] == <span class="number">1</span> ) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]; <span class="comment">// 状态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back().back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#64--最小路径和</title>
    <url>/2020/04/16/leetcode64/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#63–最小路径和</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：最小路径和（中等）"><a href="#1-题目：最小路径和（中等）" class="headerlink" title="1.题目：最小路径和（中等）"></a>1.题目：最小路径和（中等）</h3><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<p><strong>示例:</strong></p>
<blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 因为路径 <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> 的总和最小。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-题解-动态规划"><a href="#2-题解-动态规划" class="headerlink" title="2.题解(动态规划)"></a>2.题解(动态规划)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span> ) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( i == <span class="number">0</span> ) grid[i][j] += grid[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( j == <span class="number">0</span> ) grid[i][j] += grid[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] += <span class="built_in">min</span>(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]); <span class="comment">//状态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid.back().back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#66--加1</title>
    <url>/2020/03/02/leetcode66/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#66–加1</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：加1（简单）"><a href="#1-题目：加1（简单）" class="headerlink" title="1.题目：加1（简单）"></a>1.题目：加1（简单）</h3><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。</p>
<p>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。</p>
</blockquote>
<h3 id="2-题解-倒序遍历"><a href="#2-题解-倒序遍历" class="headerlink" title="2.题解(倒序遍历)"></a>2.题解(倒序遍历)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        digits.back() += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = digits.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i )</span><br><span class="line">        &#123;</span><br><span class="line">            digits[i] += flag;</span><br><span class="line">            <span class="keyword">if</span> ( digits[i] == <span class="number">10</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( digits[<span class="number">0</span>] == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            digits.insert(digits.cbegin(), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#67--二进制求和</title>
    <url>/2020/03/02/leetcode67/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#67–二进制求和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二进制求和（简单）"><a href="#1-题目：二进制求和（简单）" class="headerlink" title="1.题目：二进制求和（简单）"></a>1.题目：二进制求和（简单）</h3><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p>
<p>输入为非空字符串且只包含数字 1 和 0。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: a = “11”, b = “1”<br>输出: “100”</p>
<p>输入: a = “1010”, b = “1011”<br>输出: “10101”</p>
</blockquote>
<h3 id="2-题解-倒序遍历"><a href="#2-题解-倒序遍历" class="headerlink" title="2.题解(倒序遍历)"></a>2.题解(倒序遍历)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="keyword">int</span>(a.size() - <span class="number">1</span>), j = <span class="keyword">int</span>(b.size() - <span class="number">1</span>); i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>; --i, --j )</span><br><span class="line">        &#123;</span><br><span class="line">            temp += i &gt;= <span class="number">0</span> ? a[i] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            temp += j &gt;= <span class="number">0</span> ? b[j] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            res.push_back( temp % <span class="number">2</span> + <span class="string">'0'</span>);</span><br><span class="line">            temp = temp / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( temp == <span class="number">1</span> ) res.push_back(<span class="string">'1'</span>);</span><br><span class="line">        reverse( res.begin(), res.end() );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#69--x的平方根</title>
    <url>/2020/03/02/leetcode69/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#69–x的平方根</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：x的平方根（简单）"><a href="#1-题目：x的平方根（简单）" class="headerlink" title="1.题目：x的平方根（简单）"></a>1.题目：x的平方根（简单）</h3><p>实现 int sqrt(int x) 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 4<br>输出: 2</p>
<p>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。</p>
</blockquote>
<h3 id="2-题解-二分法"><a href="#2-题解-二分法" class="headerlink" title="2.题解(二分法)"></a>2.题解(二分法)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> right = x;</span><br><span class="line">        <span class="keyword">while</span> ( left &lt;= right ) &#123;</span><br><span class="line">            <span class="keyword">long</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ( mid * mid == x ) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( mid * mid &gt; x ) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( mid * mid &lt; x ) left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分法</tag>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#7--整数反转</title>
    <url>/2020/02/22/leetcode7/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#7–整数反转题解</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：整数反转（简单）"><a href="#1-题目：整数反转（简单）" class="headerlink" title="1.题目：整数反转（简单）"></a>1.题目：整数反转（简单）</h3><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 123<br>输出: 321</p>
<p>输入: -123<br>输出: -321</p>
<p>输入: 120<br>输出: 21</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( x != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> ( ans &gt; INT32_MAX / <span class="number">10</span> || (ans == INT32_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>) )</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> ( ans &lt; INT32_MIN / <span class="number">10</span> || (ans == INT32_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>) )</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            ans = ans * <span class="number">10</span> + pop;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主要处理int类型溢出问题<br>其中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> == INT32_MAX % <span class="number">10</span></span><br><span class="line"><span class="number">-8</span> == INT32_MIN % <span class="number">10</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#70--爬楼梯</title>
    <url>/2020/03/03/leetcode70/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#70–爬楼梯</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：爬楼梯（简单）"><a href="#1-题目：爬楼梯（简单）" class="headerlink" title="1.题目：爬楼梯（简单）"></a>1.题目：爬楼梯（简单）</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。<br>(1) 1 阶 + 1 阶<br>(2) 2 阶</p>
<p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。<br>(1) 1 阶 + 1 阶 + 1 阶<br>(2) 1 阶 + 2 阶<br>(3) 2 阶 + 1 阶</p>
</blockquote>
<h3 id="2-题解-动态规划"><a href="#2-题解-动态规划" class="headerlink" title="2.题解(动态规划)"></a>2.题解(动态规划)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( n == <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">        dp.push_back(<span class="number">1</span>);</span><br><span class="line">        dp.push_back(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            dp.push_back( dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>] ); <span class="comment">// 状态转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#71--简化路径</title>
    <url>/2020/04/17/leetcode71/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#71–简化路径</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：简化路径（中等）"><a href="#1-题目：简化路径（中等）" class="headerlink" title="1.题目：简化路径（中等）"></a>1.题目：简化路径（中等）</h3><p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。</p>
<p>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入：”/a/../../b/../c//.//“<br>输出：”/c”</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">simplifyPath</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">is</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">        <span class="built_in">string</span> res, tmp;</span><br><span class="line">        <span class="keyword">while</span> ( getline(is, tmp, <span class="string">'/'</span>) ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( tmp == <span class="string">""</span> || tmp == <span class="string">"."</span> )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( tmp == <span class="string">".."</span> &amp;&amp; !strs.empty() )</span><br><span class="line">                strs.pop_back();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( tmp != <span class="string">".."</span> )</span><br><span class="line">                strs.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">string</span> str : strs )</span><br><span class="line">            res +=  <span class="string">"/"</span> + str;</span><br><span class="line">        <span class="keyword">if</span> ( res.empty() )</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"/"</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#73--矩阵置0</title>
    <url>/2020/04/17/leetcode73/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#73–矩阵置0</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：矩阵置0（中等）"><a href="#1-题目：矩阵置0（中等）" class="headerlink" title="1.题目：矩阵置0（中等）"></a>1.题目：矩阵置0（中等）</h3><p>给定一个 <em>m</em> x <em>n</em> 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用<strong><a href="http://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a></strong>算法<strong>。</strong></p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:<br>[<br>  [1,1,1],<br>  [1,0,1],<br>  [1,1,1]<br>]<br>输出:<br>[<br>  [1,0,1],<br>  [0,0,0],<br>  [1,0,1]<br>]</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( matrix.empty() ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; row, col;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].size(); ++j ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( matrix[i][j] == <span class="number">0</span> ) &#123;</span><br><span class="line">                    row.insert(i);</span><br><span class="line">                    col.insert(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i : row ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].size(); ++j ) &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i : col ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix.size(); ++j ) &#123;</span><br><span class="line">                matrix[j][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#78--子集</title>
    <url>/2020/04/20/leetcode78/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#78–子集</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：子集（中等）"><a href="#1-题目：子集（中等）" class="headerlink" title="1.题目：子集（中等）"></a>1.题目：子集（中等）</h3><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p>
<p><strong>说明：</strong>解集不能包含重复的子集。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: nums = [1,2,3]<br>输出:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p>
</blockquote>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.empty() ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 路径</span></span><br><span class="line">        <span class="comment">// sort(nums.begin(), nums.end());</span></span><br><span class="line">        backtrack(nums, res, path, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        res.push_back(path);</span><br><span class="line">        <span class="comment">// 可选列表</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            backtrack(nums, res, path, i + <span class="number">1</span>);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#79--单词搜索</title>
    <url>/2020/04/21/leetcode79/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#79–单词搜索</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：单词搜索（中等）"><a href="#1-题目：单词搜索（中等）" class="headerlink" title="1.题目：单词搜索（中等）"></a>1.题目：单词搜索（中等）</h3><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>board =<br>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]</p>
<p>给定 word = “ABCCED”, 返回 true<br>给定 word = “SEE”, 返回 true<br>给定 word = “ABCB”, 返回 false</p>
</blockquote>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;board = board;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="keyword">word</span> = <span class="keyword">word</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( dfs(i, j, <span class="number">0</span>, visited) ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; board;</span><br><span class="line">    <span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( index == <span class="keyword">word</span>.<span class="built_in">size</span>() - <span class="number">1</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">word</span>[index] == board[x][y];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( <span class="keyword">word</span>[index] == board[x][y] ) &#123;</span><br><span class="line">            visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i ) &#123;</span><br><span class="line">                <span class="keyword">int</span> new_x = x + dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> new_y = y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ( new_x &gt;= <span class="number">0</span> &amp;&amp; new_x &lt; board.<span class="built_in">size</span>() &amp;&amp; new_y &gt;= <span class="number">0</span> &amp;&amp; new_y &lt; board[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; !visited[new_x][new_y] )</span><br><span class="line">                    <span class="keyword">if</span> ( dfs(new_x, new_y, index + <span class="number">1</span>, visited) ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[x][y] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#8--字符串转换整数</title>
    <url>/2020/03/22/leetcode8/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#8–字符串转换整数</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：字符串转换整数（中等）"><a href="#1-题目：字符串转换整数（中等）" class="headerlink" title="1.题目：字符串转换整数（中等）"></a>1.题目：字符串转换整数（中等）</h3><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( str.empty() ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//处理空格</span></span><br><span class="line">        <span class="keyword">while</span> ( str[i] == <span class="string">' '</span> &amp;&amp; i &lt; str.size() ) &#123; ++i; &#125;</span><br><span class="line">        <span class="keyword">if</span> ( i == str.size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//处理正负号</span></span><br><span class="line">        <span class="keyword">int</span> flag&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> ( str[i] == <span class="string">'-'</span> ) &#123;</span><br><span class="line">            flag = <span class="number">-1</span>;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( str[i] == <span class="string">'+'</span> ) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> ( i &lt; str.size() &amp;&amp; <span class="built_in">isdigit</span>(str[i]) ) &#123;</span><br><span class="line">            <span class="comment">//判断溢出</span></span><br><span class="line">            <span class="keyword">int</span> dig = flag * (str[i] - <span class="string">'1'</span> + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ( res &gt; INT32_MAX / <span class="number">10</span> || ( res == INT32_MAX / <span class="number">10</span> &amp;&amp; dig &gt; INT32_MAX % <span class="number">10</span> ) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT32_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( res &lt; INT32_MIN / <span class="number">10</span> || ( res == INT32_MIN / <span class="number">10</span> &amp;&amp; dig &lt; INT32_MIN % <span class="number">10</span> ) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT32_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="number">10</span> * res + dig;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#80--删除排序数组中的重复项II</title>
    <url>/2020/04/21/leetcode80/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#80–删除排序数组中的重复项II</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：删除排序数组中的重复项II（中等）"><a href="#1-题目：删除排序数组中的重复项II（中等）" class="headerlink" title="1.题目：删除排序数组中的重复项II（中等）"></a>1.题目：删除排序数组中的重复项II（中等）</h3><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定 nums = [1,1,1,2,2,3],</p>
<p>函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.size() &lt; <span class="number">2</span> ) <span class="keyword">return</span> nums.size();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>, count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) count++;</span><br><span class="line">            <span class="keyword">else</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">2</span>) nums[j++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#81--搜索旋转排序数组II</title>
    <url>/2020/04/22/leetcode81/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#81–搜索旋转排序数组II</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：搜索旋转排序数组II（中等）"><a href="#1-题目：搜索旋转排序数组II（中等）" class="headerlink" title="1.题目：搜索旋转排序数组II（中等）"></a>1.题目：搜索旋转排序数组II（中等）</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p>
<p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: nums = [2,5,6,0,0,1,2], target = 0<br>输出: true</p>
</blockquote>
<h3 id="2-题解-二分法"><a href="#2-题解-二分法" class="headerlink" title="2.题解(二分法)"></a>2.题解(二分法)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.empty() ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( left &lt;= right ) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ( nums[mid] == target ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> ( nums[mid] == nums[left] ) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( nums[left] &lt; nums[mid] ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( target &gt;= nums[left] &amp;&amp; target &lt; nums[mid] ) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( target &gt; nums[mid] &amp;&amp; target &lt;= nums[right] ) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分法</tag>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#82--删除排序链表中的重复元素II</title>
    <url>/2020/04/22/leetcode82/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#82–删除排序链表中的重复元素II</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：删除排序链表中的重复元素II（中等）"><a href="#1-题目：删除排序链表中的重复元素II（中等）" class="headerlink" title="1.题目：删除排序链表中的重复元素II（中等）"></a>1.题目：删除排序链表中的重复元素II（中等）</h3><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 <em>没有重复出现</em> 的数字。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>输出: 1-&gt;2-&gt;5</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( head == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* first = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        first-&gt;next = head;</span><br><span class="line">        ListNode* ptr = first;</span><br><span class="line">        <span class="keyword">while</span> ( ptr-&gt;next != <span class="literal">nullptr</span> &amp;&amp; ptr-&gt;next-&gt;next != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( ptr-&gt;next-&gt;next-&gt;val &gt; ptr-&gt;next-&gt;val ) &#123;</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ListNode* search = ptr-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">while</span> ( search-&gt;next != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( search-&gt;next-&gt;val == search-&gt;val ) &#123;</span><br><span class="line">                        search = search-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ptr-&gt;next = search-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#83--删除排序链表中的重复元素</title>
    <url>/2020/03/03/leetcode83/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#83–删除排序链表中的重复元素</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：删除排序链表中的重复元素（简单）"><a href="#1-题目：删除排序链表中的重复元素（简单）" class="headerlink" title="1.题目：删除排序链表中的重复元素（简单）"></a>1.题目：删除排序链表中的重复元素（简单）</h3><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2</p>
<p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p>
</blockquote>
<h3 id="2-题解-链表"><a href="#2-题解-链表" class="headerlink" title="2.题解(链表)"></a>2.题解(链表)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* ptr = head;</span><br><span class="line">        <span class="keyword">while</span> ( ptr != <span class="literal">nullptr</span> &amp;&amp; ptr-&gt;next != <span class="literal">nullptr</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( ptr-&gt;val == ptr-&gt;next-&gt;val )</span><br><span class="line">            &#123;</span><br><span class="line">                ptr-&gt;next = ptr-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#86--分隔链表</title>
    <url>/2020/04/23/leetcode86/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#86–分隔链表</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：分隔链表（中等）"><a href="#1-题目：分隔链表（中等）" class="headerlink" title="1.题目：分隔链表（中等）"></a>1.题目：分隔链表（中等）</h3><p>给定一个链表和一个特定值 <em>x</em>，对链表进行分隔，使得所有小于 <em>x</em> 的节点都在大于或等于 <em>x</em> 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode* smallBeforeHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* small = smallBeforeHead;</span><br><span class="line">        ListNode* bigAfterHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* big = bigAfterHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val &lt; x) &#123;</span><br><span class="line">                small-&gt;next = head;</span><br><span class="line">                small = small-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                big-&gt;next = head;</span><br><span class="line">                big = big-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        big-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        small-&gt;next = bigAfterHead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> smallBeforeHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#88--合并两个有序数组</title>
    <url>/2020/03/03/leetcode88/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#88–合并两个有序数组</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：合并两个有序数组（简单）"><a href="#1-题目：合并两个有序数组（简单）" class="headerlink" title="1.题目：合并两个有序数组（简单）"></a>1.题目：合并两个有序数组（简单）</h3><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p>
<p>说明:</p>
<p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p>
<p>输出: [1,2,2,3,5,6]</p>
</blockquote>
<h3 id="2-题解-倒序遍历"><a href="#2-题解-倒序遍历" class="headerlink" title="2.题解(倒序遍历)"></a>2.题解(倒序遍历)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( nums1[i] &gt; nums2[j] )</span><br><span class="line">            &#123;</span><br><span class="line">                nums1[len] = nums1[i];</span><br><span class="line">                --i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nums1[len] = nums2[j];</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            --len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( i &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> ( j &gt;= <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                nums1[j] = nums2[j];</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#89--格雷编码</title>
    <url>/2020/04/23/leetcode89/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#89–格雷编码</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：格雷编码（中等）"><a href="#1-题目：格雷编码（中等）" class="headerlink" title="1.题目：格雷编码（中等）"></a>1.题目：格雷编码（中等）</h3><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p>
<p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 2<br>输出: [0,1,3,2]<br>解释:<br>00 - 0<br>01 - 1<br>11 - 3<br>10 - 2</p>
<p>对于给定的 n，其格雷编码序列并不唯一。<br>例如，[0,2,3,1] 也是一个有效的格雷编码序列。</p>
<p>00 - 0<br>10 - 2<br>11 - 3<br>01 - 1</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; grayCode(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.push_back(<span class="number">0</span>); <span class="comment">//初始的G(0)</span></span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = res.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j ) &#123; <span class="comment">//作为镜像翻转需倒序操作</span></span><br><span class="line">                <span class="keyword">int</span> t = res[j] | head; <span class="comment">//进行或逻辑运算。在他们的首位进1</span></span><br><span class="line">                res.push_back(t);</span><br><span class="line">            &#125;</span><br><span class="line">            head &lt;&lt;= <span class="number">1</span>; <span class="comment">//进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#9--回文数</title>
    <url>/2020/02/22/leetcode9/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#9–回文数题解</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：回文数（简单）"><a href="#1-题目：回文数（简单）" class="headerlink" title="1.题目：回文数（简单）"></a>1.题目：回文数（简单）</h3><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 121<br>输出: true</p>
<p>输入: -121<br>输出: false<br>解释: 从左向右读,为-121。从右向左读,为121-。因此它不是一个回文数。</p>
<p>输入: 10<br>输出: false<br>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-转化成字符串"><a href="#1-转化成字符串" class="headerlink" title="(1)转化成字符串"></a>(1)转化成字符串</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> rev;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//排除负数</span></span><br><span class="line">        <span class="built_in">string</span> str_x = to_string(x);  <span class="comment">//转换成字符串</span></span><br><span class="line">        reverse(str_x.begin(), str_x.end());  <span class="comment">//进行反转</span></span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(str_x)</span></span>;</span><br><span class="line">        in &gt;&gt; rev;  <span class="comment">//结果写入rev</span></span><br><span class="line">        <span class="keyword">return</span> x == rev;  <span class="comment">//比较得出结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-反转一半数字"><a href="#2-反转一半数字" class="headerlink" title="(2)反转一半数字"></a>(2)反转一半数字</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> midrev = <span class="number">0</span>;  <span class="comment">//存储后半部分数字的反转结果</span></span><br><span class="line">        <span class="comment">//排除负数和最后一位数字为0的数字</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; midrev)</span><br><span class="line">        &#123;</span><br><span class="line">            midrev = midrev * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> midrev == x || midrev / <span class="number">10</span> == x;  <span class="comment">//数字个数为偶数和奇数分两种情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#90--子集2</title>
    <url>/2020/04/24/leetcode90/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#90–子集2</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：子集2（中等）"><a href="#1-题目：子集2（中等）" class="headerlink" title="1.题目：子集2（中等）"></a>1.题目：子集2（中等）</h3><p>给定一个可能包含重复元素的整数数组 <strong><em>nums</em></strong>，返回该数组所有可能的子集（幂集）。</p>
<p><strong>说明：</strong>解集不能包含重复的子集。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: [1,2,2]<br>输出:<br>[<br>  [2],<br>  [1],<br>  [1,2,2],<br>  [2,2],<br>  [1,2],<br>  []<br>]</p>
</blockquote>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsetsWithDup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.empty() ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 路径</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(nums.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        backtrack(nums, res, path, <span class="number">0</span>, visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        res.push_back(path);</span><br><span class="line">        <span class="comment">// 可选列表</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; visited[i - <span class="number">1</span>] == <span class="literal">false</span> ) <span class="keyword">continue</span>; <span class="comment">// 剪枝</span></span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            backtrack(nums, res, path, i + <span class="number">1</span>, visited);</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#91--解码方法</title>
    <url>/2020/04/24/leetcode91/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#91–解码方法</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：解码方法（中等）"><a href="#1-题目：解码方法（中等）" class="headerlink" title="1.题目：解码方法（中等）"></a>1.题目：解码方法（中等）</h3><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>给定一个只包含数字的非空字符串，请计算解码方法的总数。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: “12”<br>输出: 2<br>解释: 它可以解码为 “AB”（1 2）或者 “L”（12）。</p>
</blockquote>
<h3 id="2-题解-动态规划"><a href="#2-题解-动态规划" class="headerlink" title="2.题解(动态规划)"></a>2.题解(动态规划)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( s[<span class="number">0</span>] == <span class="string">'0'</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.<span class="built_in">size</span>() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt; s.<span class="built_in">size</span>() + <span class="number">1</span>; ++i ) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 1. s[j]不能单独译码</span></span><br><span class="line">            <span class="keyword">if</span> ( s[j] == <span class="string">'0'</span> )</span><br><span class="line">                <span class="comment">// 1.1 s[j]能与s[j - 1]合并译码</span></span><br><span class="line">                <span class="keyword">if</span> (s[j - <span class="number">1</span>] == <span class="string">'1'</span> || s[j - <span class="number">1</span>] == <span class="string">'2'</span>) dp[i] = dp[i - <span class="number">2</span>]; <span class="comment">// 状态转移方程</span></span><br><span class="line">                <span class="comment">// 1.2 无法译码</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 2. s[j]可以单独译码，也可以与s[j - 1]合并译码</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[j - <span class="number">1</span>] == <span class="string">'1'</span> || (s[j - <span class="number">1</span>] == <span class="string">'2'</span> &amp;&amp; s[j] &gt;= <span class="string">'1'</span> &amp;&amp; s[j] &lt;= <span class="string">'6'</span>))</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]; <span class="comment">// 状态转移方程</span></span><br><span class="line">            <span class="comment">// 3. s[j]只能单独译码</span></span><br><span class="line">            <span class="keyword">else</span> dp[i] = dp[i - <span class="number">1</span>]; <span class="comment">// 状态转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#92--反转链表2</title>
    <url>/2020/04/25/leetcode92/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#92–反转链表2</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：反转链表2（中等）"><a href="#1-题目：反转链表2（中等）" class="headerlink" title="1.题目：反转链表2（中等）"></a>1.题目：反转链表2（中等）</h3><p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。</p>
<p><strong>说明:</strong><br>1 ≤ <em>m</em> ≤ <em>n</em> ≤ 链表长度。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//思路：head表示需要反转的头节点，pre表示需要反转头节点的前驱节点</span></span><br><span class="line">    <span class="comment">//我们需要反转n-m次，我们将head的next节点移动到需要反转链表部分的首部，需要反转链表部分剩余节点依旧保持相对顺序即可</span></span><br><span class="line">    <span class="comment">//比如1-&gt;2-&gt;3-&gt;4-&gt;5,m=1,n=5</span></span><br><span class="line">    <span class="comment">//第一次反转：1(head) 2(next) 3 4 5 反转为 2 1 3 4 5</span></span><br><span class="line">    <span class="comment">//第二次反转：2 1(head) 3(next) 4 5 反转为 3 2 1 4 5</span></span><br><span class="line">    <span class="comment">//第三次发转：3 2 1(head) 4(next) 5 反转为 4 3 2 1 5</span></span><br><span class="line">    <span class="comment">//第四次反转：4 3 2 1(head) 5(next) 反转为 5 4 3 2 1</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *pre = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) pre = pre-&gt;next;</span><br><span class="line">        head = pre-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; n; ++i) &#123;</span><br><span class="line">            ListNode *nxt = head-&gt;next;</span><br><span class="line">            <span class="comment">//head节点连接nxt节点之后链表部分，也就是向后移动一位</span></span><br><span class="line">            head-&gt;next = nxt-&gt;next;</span><br><span class="line">            <span class="comment">//nxt节点移动到需要反转链表部分的首部</span></span><br><span class="line">            nxt-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = nxt;<span class="comment">//pre继续为需要反转头节点的前驱节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#93--复原IP地址</title>
    <url>/2020/04/25/leetcode93/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#93–复原IP地址</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：复原IP地址（中等）"><a href="#1-题目：复原IP地址（中等）" class="headerlink" title="1.题目：复原IP地址（中等）"></a>1.题目：复原IP地址（中等）</h3><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: “25525511135”<br>输出: [“255.255.11.135”, “255.255.111.35”]</p>
</blockquote>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="comment">//字符串s长度</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">restoreIpAddresses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        n = s.<span class="built_in">size</span>();</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="string">""</span>, s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param start 当前开始的位置</span></span><br><span class="line"><span class="comment">     * @param depth 当前选出了几个段</span></span><br><span class="line"><span class="comment">     * @param path 传递的路径(一般字符串问题都将路径作为传递，可以解决回溯弹出问题)</span></span><br><span class="line"><span class="comment">     * @param s 给出的需要分割的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> depth, <span class="built_in">string</span> path, <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        <span class="keyword">if</span> ( depth == <span class="number">4</span> ) &#123;</span><br><span class="line">            path.pop_back(); <span class="comment">//除去传递参数时最后一次多加的'.'</span></span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可选列表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// endMin 表示最短可以在哪里结束, endMax 表示最长可以在哪里结束</span></span><br><span class="line">        <span class="comment">// 3 - depth 表示剩余的 ip 段个数 (EG.当depth=0,现在正在处理第一段,还剩3段)</span></span><br><span class="line">        <span class="comment">// n - (3 - depth) * 3 表示剩余的 ip 段如果都是 3 位数，当前 ip 段的结束位置（取不到）</span></span><br><span class="line">        <span class="comment">// start + 1 也是因为取不到</span></span><br><span class="line">        <span class="keyword">int</span> endMin = <span class="built_in">max</span>(start + <span class="number">1</span>, n - (<span class="number">3</span> - depth) * <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// n - (3 - depth) * 1 表示剩余的 ip 段如果都是 1 位数，当前 ip 段的结束位置（取不到）</span></span><br><span class="line">        <span class="keyword">int</span> endMax = <span class="built_in">min</span>(start + <span class="number">3</span>, n - (<span class="number">3</span> - depth));</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> <span class="built_in">end</span> = endMin; <span class="built_in">end</span> &lt;= endMax; ++<span class="built_in">end</span> ) &#123;</span><br><span class="line">            <span class="built_in">string</span> split = s.substr(start, <span class="built_in">end</span> - start); <span class="comment">// end - start 表示截取长度</span></span><br><span class="line">            <span class="comment">// 剪枝；当长度&gt;1时, 第一位不能为0；每一段不能多于255</span></span><br><span class="line">            <span class="keyword">if</span> ( split.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; split[<span class="number">0</span>] == <span class="string">'0'</span> || stoi(split) &gt; <span class="number">255</span> ) <span class="keyword">break</span>;</span><br><span class="line">            dfs(<span class="built_in">end</span>, depth + <span class="number">1</span>, path + (split + <span class="string">'.'</span>), s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#94--二叉树的中序遍历</title>
    <url>/2020/04/30/leetcode94/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#94–二叉树的中序遍历</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：二叉树的中序遍历（中等）"><a href="#1-题目：二叉树的中序遍历（中等）" class="headerlink" title="1.题目：二叉树的中序遍历（中等）"></a>1.题目：二叉树的中序遍历（中等）</h3><p>给定一个二叉树，返回它的中序遍历。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="(1) 递归"></a>(1) 递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">		helper(root, res);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( root-&gt;left != <span class="literal">nullptr</span> ) helper(root-&gt;left, res);</span><br><span class="line">		res.push_back(root-&gt;val);</span><br><span class="line">		<span class="keyword">if</span> ( root-&gt;right != <span class="literal">nullptr</span> ) helper(root-&gt;right, res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-迭代"><a href="#2-迭代" class="headerlink" title="(2) 迭代"></a>(2) 迭代</h4><h5 id="a-模拟递归调用栈"><a href="#a-模拟递归调用栈" class="headerlink" title="(a) 模拟递归调用栈"></a>(a) 模拟递归调用栈</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">		<span class="built_in">stack</span>&lt;TreeNode*&gt; auxStack;</span><br><span class="line">		TreeNode* node = root;</span><br><span class="line">		<span class="keyword">while</span> ( !auxStack.empty() || node != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">			<span class="keyword">if</span> ( node != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">				auxStack.push(node);</span><br><span class="line">				node = node-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				node = auxStack.top();</span><br><span class="line">				auxStack.pop();</span><br><span class="line">				res.push_back(node-&gt;val);</span><br><span class="line">				node = node-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="b-颜色标记法"><a href="#b-颜色标记法" class="headerlink" title="(b) 颜色标记法"></a>(b) 颜色标记法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">		<span class="keyword">int</span> WHITE = <span class="number">0</span>, GRAY = <span class="number">1</span>;  <span class="comment">//白色代表遍历过0次，灰色代表遍历过1次</span></span><br><span class="line">		<span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, TreeNode*&gt;&gt; auxStack;  <span class="comment">//辅助栈</span></span><br><span class="line">		auxStack.push(make_pair(WHITE, root));</span><br><span class="line">		<span class="keyword">while</span> ( !auxStack.empty() )</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">int</span> color = auxStack.top().first;</span><br><span class="line">			TreeNode* node = auxStack.top().second;</span><br><span class="line">			auxStack.pop();</span><br><span class="line">			<span class="keyword">if</span> ( node == <span class="literal">nullptr</span> ) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> ( color == WHITE )</span><br><span class="line">			&#123;</span><br><span class="line">				auxStack.push(make_pair(WHITE, node-&gt;right));</span><br><span class="line">				auxStack.push(make_pair(GRAY, node));</span><br><span class="line">				auxStack.push(make_pair(WHITE, node-&gt;left));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> res.push_back(node-&gt;val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#95--不同的二叉搜索树2</title>
    <url>/2020/04/30/leetcode95/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#95–不同的二叉搜索树2</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：不同的二叉搜索树2（中等）"><a href="#1-题目：不同的二叉搜索树2（中等）" class="headerlink" title="1.题目：不同的二叉搜索树2（中等）"></a>1.题目：不同的二叉搜索树2（中等）</h3><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; generateTrees(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( n == <span class="number">0</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">        res = helper(<span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; helper(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( start &gt; end ) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = start; i &lt;= end; ++i ) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; lTreeSet = helper(start, i - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; rTreeSet = helper(i + <span class="number">1</span>, end);</span><br><span class="line">            <span class="keyword">for</span> ( TreeNode* lTree : lTreeSet ) &#123;</span><br><span class="line">                <span class="keyword">for</span> ( TreeNode* rTree : rTreeSet ) &#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root-&gt;left = lTree;</span><br><span class="line">                    root-&gt;right = rTree;</span><br><span class="line">                    ans.push_back(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#96--不同的二叉搜索树</title>
    <url>/2020/04/30/leetcode96/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#95–不同的二叉搜索树</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：不同的二叉搜索树（中等）"><a href="#1-题目：不同的二叉搜索树（中等）" class="headerlink" title="1.题目：不同的二叉搜索树（中等）"></a>1.题目：不同的二叉搜索树（中等）</h3><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<h3 id="2-题解-动态规划"><a href="#2-题解-动态规划" class="headerlink" title="2.题解(动态规划)"></a>2.题解(动态规划)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i ) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j ) &#123; <span class="comment">// 状态转移方程</span></span><br><span class="line">                num += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#98--验证二叉搜索树</title>
    <url>/2020/04/30/leetcode98/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#98–验证二叉搜索树</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：验证二叉搜索树（中等）"><a href="#1-题目：验证二叉搜索树（中等）" class="headerlink" title="1.题目：验证二叉搜索树（中等）"></a>1.题目：验证二叉搜索树（中等）</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="(1) 递归"></a>(1) 递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, INT64_MIN, INT64_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由顶自下，节点的取值范围逐渐缩小</span></span><br><span class="line"><span class="comment">     * 左儿子的上限变为父节点值</span></span><br><span class="line"><span class="comment">     * 右儿子的下限变为父节点值</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param node : 待检测节点</span></span><br><span class="line"><span class="comment">     * @param lowerLimit : 待检测节点的下限</span></span><br><span class="line"><span class="comment">     * @param upperLimit : 待检测节点的上限</span></span><br><span class="line"><span class="comment">     * @return : 以root为根节点的树是否是二叉搜索树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* node, <span class="keyword">long</span> lowerLimit, <span class="keyword">long</span> upperLimit)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//若树根节点为空，认为是二叉搜索树</span></span><br><span class="line">        <span class="keyword">if</span> ( node == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//判断树的根节点是否满足上下限</span></span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;val &lt;= lowerLimit ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;val &gt;= upperLimit ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断左子树和右子树是否是二叉搜索树</span></span><br><span class="line">        <span class="keyword">return</span> helper(node-&gt;left, lowerLimit, node-&gt;val) &amp;&amp; helper(node-&gt;right, node-&gt;val, upperLimit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-中序遍历-迭代"><a href="#2-中序遍历-迭代" class="headerlink" title="(2) 中序遍历(迭代)"></a>(2) 中序遍历(迭代)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//利用二叉搜索树中序遍历的结果是一个递增序列来判断</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; auxStack;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="keyword">long</span> order = INT64_MIN;</span><br><span class="line">        <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> || !auxStack.empty() ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( node != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                auxStack.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                node = auxStack.top();</span><br><span class="line">                auxStack.pop();</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;val &lt;= order ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                order = node-&gt;val;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Linux系统下printf函数的输出问题</title>
    <url>/2019/08/21/linux-printf/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍了linux系统中，C语言调试过程中，printf函数中的内容不能及时输出的原因和解决方案</p>
</blockquote>
<a id="more"></a>

<h3 id="1-原因"><a href="#1-原因" class="headerlink" title="1. 原因"></a>1. 原因</h3><p>unix上标准输入输出都是带有缓存的，一般是行缓存。</p>
<p>对于标准输出，需要输出的数据并不是直接输出到终端上，而是首先缓存到某个地方，当遇到行刷新标志或者该缓存已满的情况下，才会把缓存的数据显示到终端设备上。</p>
<p>ANSI C中定义换行符’\n’可以认为是行刷新标志。所以，printf函数没有带’\n’是不会自动刷新输出流，直至缓存被填满。</p>
<h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h3><p>(1) 在printf里加”\n”</p>
<p>(2) 刷新标准输出缓冲区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ fflush(stdout);               <span class="comment"># 在printf 之后调用它,刷新一下缓冲区,让它马上输出。</span></span><br><span class="line">$ setvbuf(stdout,NULL,_IONBF,0);</span><br><span class="line">$ setbuf(stdout,NULL);          <span class="comment"># 直接将缓冲区禁止了. 它就直接输出了。</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下常用命令</title>
    <url>/2019/09/19/linux/</url>
    <content><![CDATA[<blockquote>
<p>本文收集了一些在linux系统中常用的命令</p>
</blockquote>
<a id="more"></a>

<h3 id="1-查看文件"><a href="#1-查看文件" class="headerlink" title="1. 查看文件"></a>1. 查看文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls        <span class="comment"># 查看文件，只显示文件名</span></span><br><span class="line">$ ls -a     <span class="comment"># 不忽略隐藏文件（以.开头）</span></span><br><span class="line">$ ls -l     <span class="comment"># 显示文件属性</span></span><br></pre></td></tr></table></figure>

<h3 id="2-终端控制符"><a href="#2-终端控制符" class="headerlink" title="2. 终端控制符"></a>2. 终端控制符</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ctrl + c  <span class="comment"># 强制中断程序的执行,进程已经终止</span></span><br><span class="line">$ ctrl + z  <span class="comment"># 将任务中止（暂停的意思）</span></span><br><span class="line">$ ctrl + d  <span class="comment"># 表示一个特殊的二进制值，表示 EOF；在shell中，ctrl-d表示推出当前shell</span></span><br></pre></td></tr></table></figure>

<p>ctrl + z 表示此任务并没有结束,他仍然在进程中他只是维持挂起的状态,用户可以使用fg/bg操作继续前台或后台的任务,fg命令重新启动前台被中断的任务,bg命令把被中断的任务放在后台执行.<br>例如:当你vi一个文件时,如果需要用shell执行别的操作,但是你又不打算关闭vi,因为你得存盘推出,你可以简单的按下ctrl+z,shell会将vi进程挂起,当你结束了那个shell操作之后,你可以用fg命令继续vi你的文件。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++动态申请内存</title>
    <url>/2019/11/25/new-array/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了C++中动态申请内存的方法</p>
</blockquote>
<a id="more"></a>

<h3 id="1-动态申请一个值的内存"><a href="#1-动态申请一个值的内存" class="headerlink" title="1. 动态申请一个值的内存"></a>1. 动态申请一个值的内存</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">//这样可以动态分配一个int型变量的内存</span></span><br></pre></td></tr></table></figure>

<h3 id="2-动态申请一个一维数组的内存"><a href="#2-动态申请一个一维数组的内存" class="headerlink" title="2. 动态申请一个一维数组的内存"></a>2. 动态申请一个一维数组的内存</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];  <span class="comment">//这样可以动态分配一个int型一维数组的内存</span></span><br></pre></td></tr></table></figure>

<h3 id="3-动态申请一个二维数组的内存"><a href="#3-动态申请一个二维数组的内存" class="headerlink" title="3. 动态申请一个二维数组的内存"></a>3. 动态申请一个二维数组的内存</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>** ptr = <span class="keyword">new</span> <span class="keyword">int</span>* [row];  <span class="comment">//先申请一个一维数组，用来存放指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">    *(ptr + i) = <span class="keyword">new</span> <span class="keyword">int</span>[col];  <span class="comment">//为一维数组中的每个指针再次分配空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/25/new-array/二维数组.jpg">]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的赋值运算符重载函数</title>
    <url>/2019/11/25/operator/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了C++中的赋值运算符重载函数</p>
</blockquote>
<a id="more"></a>

<h3 id="1-什么时候调用赋值函数"><a href="#1-什么时候调用赋值函数" class="headerlink" title="1. 什么时候调用赋值函数"></a>1. 什么时候调用赋值函数</h3><p>当一个类的对象向该类的另一个对象赋值时，被赋值对象就会调用该类的赋值函数</p>
<blockquote>
<p>该类必须是已经存在的，不能是新创建的，否则将调用拷贝构造函数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ClassExample obj1;</span><br><span class="line">ClassExample obj2;</span><br><span class="line">obj2 = obj1;  <span class="comment">//obj2已存在，用obj1向obj2赋值，调用赋值函数</span></span><br><span class="line"></span><br><span class="line">ClassExample obj3 = obj2;  <span class="comment">//obj3不存在，用obj2初始化obj3，调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<h3 id="2-常见定义形式"><a href="#2-常见定义形式" class="headerlink" title="2. 常见定义形式"></a>2. 常见定义形式</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ClassExample&amp; <span class="keyword">operator</span>=（<span class="keyword">const</span> ClassExample&amp; obj)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;obj)&#123;</span><br><span class="line">        <span class="comment">// 赋值函数主体</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h3><p>(1) 避免自赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;obj)&#123;</span><br><span class="line">    <span class="comment">// 赋值函数主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 释放原对象申请的内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] ptr;</span><br></pre></td></tr></table></figure>

<p>(3) 申请新的内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ptr = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>(4) 将原对象的成员复制给被赋值对象</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下常用快捷键</title>
    <url>/2020/04/29/shortcut/</url>
    <content><![CDATA[<blockquote>
<p>本文收集了一些在linux系统中常用的快捷键</p>
</blockquote>
<a id="more"></a>

<h3 id="1-终端常用快捷键"><a href="#1-终端常用快捷键" class="headerlink" title="1. 终端常用快捷键"></a>1. 终端常用快捷键</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Tab</td>
<td>补全</td>
</tr>
<tr>
<td>Ctrl+Alt+T</td>
<td>启动终端</td>
</tr>
<tr>
<td>Ctrl+D</td>
<td>关闭终端</td>
</tr>
<tr>
<td>Ctrl+Shift+C</td>
<td>复制</td>
</tr>
<tr>
<td>Ctrl+Shift+V</td>
<td>粘贴</td>
</tr>
<tr>
<td>Ctrl+A</td>
<td>光标移到行的开头</td>
</tr>
<tr>
<td>Ctrl+E</td>
<td>光标移到行的结尾</td>
</tr>
<tr>
<td>Ctrl+Left-Arrow</td>
<td>光标移到上一个单词的词首</td>
</tr>
<tr>
<td>Ctrl+Right-Arrow</td>
<td>光标移到下一个单词的词尾</td>
</tr>
<tr>
<td>Ctrl+U</td>
<td>剪切此处至开始的所有内容</td>
</tr>
<tr>
<td>Ctrl+K</td>
<td>剪切此处至末尾的所有内容</td>
</tr>
<tr>
<td>Ctrl+Y</td>
<td>粘贴由Ctrl+U和Ctrl+K剪切的内容</td>
</tr>
<tr>
<td>Ctrl+L</td>
<td>清屏</td>
</tr>
</tbody></table>
<h3 id="2-vim常用快捷键"><a href="#2-vim常用快捷键" class="headerlink" title="2. vim常用快捷键"></a>2. vim常用快捷键</h3><h4 id="1-删除命令"><a href="#1-删除命令" class="headerlink" title="(1) 删除命令"></a>(1) 删除命令</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>dd</td>
<td>删除光标当前行</td>
</tr>
<tr>
<td>d$</td>
<td>删除本行光标后面的内容</td>
</tr>
<tr>
<td>d0</td>
<td>删除本行光标前面的内容</td>
</tr>
<tr>
<td>ndd</td>
<td>删除当前行以及其后的 n - 1 行</td>
</tr>
<tr>
<td>x</td>
<td>删除光标后的一个字符</td>
</tr>
</tbody></table>
<h4 id="2-指令模式"><a href="#2-指令模式" class="headerlink" title="(2) 指令模式"></a>(2) 指令模式</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>:q</td>
<td>一般退出</td>
</tr>
<tr>
<td>:q!</td>
<td>退出不保存</td>
</tr>
<tr>
<td>:wq</td>
<td>保存退出</td>
</tr>
<tr>
<td>:set nu</td>
<td>设置行号显示</td>
</tr>
<tr>
<td>:set nonu</td>
<td>取消行号显示</td>
</tr>
<tr>
<td>u</td>
<td>撤销</td>
</tr>
</tbody></table>
<h4 id="3-查找命令"><a href="#3-查找命令" class="headerlink" title="(3) 查找命令"></a>(3) 查找命令</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>/code</td>
<td>查找和code一样的内容，向后</td>
</tr>
<tr>
<td>?code</td>
<td>查找和code一样的内容，向前</td>
</tr>
<tr>
<td>n</td>
<td>查找下一处</td>
</tr>
<tr>
<td>N</td>
<td>查找上一处</td>
</tr>
</tbody></table>
<h4 id="4-光标操作"><a href="#4-光标操作" class="headerlink" title="(4) 光标操作"></a>(4) 光标操作</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>b</td>
<td>按单词向前移动，字首</td>
</tr>
<tr>
<td>e</td>
<td>按单词向后移动，字尾</td>
</tr>
<tr>
<td>G</td>
<td>移动到文档最后一行</td>
</tr>
<tr>
<td>gg</td>
<td>移动到文档第一行</td>
</tr>
<tr>
<td>0</td>
<td>移动到行首</td>
</tr>
<tr>
<td>$</td>
<td>移动到行尾</td>
</tr>
</tbody></table>
<h4 id="5-复制粘贴"><a href="#5-复制粘贴" class="headerlink" title="(5) 复制粘贴"></a>(5) 复制粘贴</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>v</td>
<td>进入可视模式</td>
</tr>
<tr>
<td>y</td>
<td>复制</td>
</tr>
<tr>
<td>yy</td>
<td>复制1行</td>
</tr>
<tr>
<td>nyy</td>
<td>复制n行</td>
</tr>
<tr>
<td>p</td>
<td>粘贴</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu中连接远程服务器</title>
    <url>/2020/04/30/ubuntu-ssh/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍了在ubuntu20.04中连接远程服务器的方法</p>
</blockquote>
<a id="more"></a>
<h3 id="1-使用Remmina连接远程服务器"><a href="#1-使用Remmina连接远程服务器" class="headerlink" title="1. 使用Remmina连接远程服务器"></a>1. 使用Remmina连接远程服务器</h3><p>（1）安装并打开Remmina远程桌面客户端，点击新建按钮；</p>
<img src="/2020/04/30/ubuntu-ssh/ubuntu-ssh1.png">

<p>（2）协议选择<strong>SSH-安全Shell连接</strong>，填入服务器地址(服务器IP:端口号)及用户名，并验证密码；</p>
<img src="/2020/04/30/ubuntu-ssh/ubuntu-ssh2.png">

<p>（3）成功连接服务器</p>
<img src="/2020/04/30/ubuntu-ssh/ubuntu-ssh3.png">

<h3 id="2-使用ssh连接远程服务器"><a href="#2-使用ssh连接远程服务器" class="headerlink" title="2. 使用ssh连接远程服务器"></a>2. 使用ssh连接远程服务器</h3><p>连接服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh zhangshuo@192.168.200.66  <span class="comment"># 内网直接连</span></span><br><span class="line">$ ssh zhangshuo@47.96.129.63 -p 6000 <span class="comment"># 从外网穿透 其中，-p 6000 为设置端口</span></span><br></pre></td></tr></table></figure>

<p>其中，zhangshuo为192.168.200.66机器上的用户，需要输入密码。</p>
<img src="/2020/04/30/ubuntu-ssh/ubuntu-ssh4.png">

<p>断开连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu通过Anaconda安装TensorFlow(CPU)的方法</title>
    <url>/2019/09/15/ubuntu-tensorflow/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍了在ubuntu16.04中通过anaconda安装tensorflow(CPU)的操作流程</p>
</blockquote>
<a id="more"></a>

<h3 id="1-安装anaconda"><a href="#1-安装anaconda" class="headerlink" title="1. 安装anaconda"></a>1. 安装anaconda</h3><p>（1）从清华镜像下载anaconda <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">链接</a></p>
<p>（2）在终端安装anaconda</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bash Anaconda3-5.2.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/u012318074/article/details/77074665" target="_blank" rel="noopener">参考</a></p>
<h3 id="2-从国内源建立虚拟环境tf"><a href="#2-从国内源建立虚拟环境tf" class="headerlink" title="2. 从国内源建立虚拟环境tf"></a>2. 从国内源建立虚拟环境tf</h3><p>（1）填加国内镜像源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge </span><br><span class="line">$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">$ conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure>

<p>（2）建立虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda create -n tf python=3.5</span><br></pre></td></tr></table></figure>

<p><a href="https://www.jianshu.com/p/6679cdeb3513" target="_blank" rel="noopener">参考</a></p>
<h3 id="3-激活tf环境"><a href="#3-激活tf环境" class="headerlink" title="3. 激活tf环境"></a>3. 激活tf环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> activate tf</span><br></pre></td></tr></table></figure>

<p>conda使用方法：<a href="https://www.jianshu.com/p/eaee1fadc1e9" target="_blank" rel="noopener">参考</a></p>
<h3 id="4-从国内源安装tensorflow"><a href="#4-从国内源安装tensorflow" class="headerlink" title="4. 从国内源安装tensorflow"></a>4. 从国内源安装tensorflow</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pip install -i https://pypi.tuna.tsinghua.edu.cn/simple tensorflow</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/qq_17854471/article/details/89299311" target="_blank" rel="noopener">参考</a></p>
<h3 id="5-可能出现的问题"><a href="#5-可能出现的问题" class="headerlink" title="5. 可能出现的问题"></a>5. 可能出现的问题</h3><p><a href="https://blog.csdn.net/weixin_42081389/article/details/98185411" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>TensorFlow</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#75--颜色分类</title>
    <url>/2020/04/19/leetcode75/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#75–颜色分类</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：颜色分类（中等）"><a href="#1-题目：颜色分类（中等）" class="headerlink" title="1.题目：颜色分类（中等）"></a>1.题目：颜色分类（中等）</h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对于所有 idx &lt; p0 : nums[idx &lt; p0] = 0</span></span><br><span class="line">        <span class="comment">// 对于所有 idx &gt; p2 : nums[idx &gt; p2] = 2</span></span><br><span class="line">        <span class="comment">// curr 是当前考虑元素的下标</span></span><br><span class="line">        <span class="keyword">int</span> p0 = <span class="number">0</span>, p2 = nums.size() - <span class="number">1</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( curr &lt;= p2 ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums[curr] == <span class="number">0</span> ) &#123;</span><br><span class="line">            swap(nums[curr++], nums[p0++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( nums[curr] == <span class="number">2</span> ) &#123;</span><br><span class="line">            swap(nums[curr], nums[p2--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> curr++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#74--搜索二维矩阵</title>
    <url>/2020/04/19/leetcode74/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#74–搜索二维矩阵</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：搜索二维矩阵（中等）"><a href="#1-题目：搜索二维矩阵（中等）" class="headerlink" title="1.题目：搜索二维矩阵（中等）"></a>1.题目：搜索二维矩阵（中等）</h3><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<p>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:<br>matrix = [<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]<br>target = 3<br>输出: true</p>
</blockquote>
<h3 id="2-题解-二分法"><a href="#2-题解-二分法" class="headerlink" title="2.题解(二分法)"></a>2.题解(二分法)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( matrix.empty() || matrix[<span class="number">0</span>].empty() ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = matrix.size() * matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( left &lt;= right ) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> num = matrix[mid / matrix[<span class="number">0</span>].size()][mid % matrix[<span class="number">0</span>].size()];</span><br><span class="line">            <span class="keyword">if</span> ( num == target ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( num &lt; target ) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( target &lt; num ) right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分法</tag>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu中用zjunet连接浙大有线网</title>
    <url>/2019/09/18/ubuntu-zjunet/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍了在ubuntu20.04中通过zjunet工具连接浙大校园有线网的方法</p>
</blockquote>
<a id="more"></a>

<h3 id="1-下载-zjunet"><a href="#1-下载-zjunet" class="headerlink" title="1. 下载 zjunet"></a>1. 下载 zjunet</h3><p>在有网的环境下，下载 <a href="https://github.com/QSCTech/zjunet/releases" target="_blank" rel="noopener">zjunet_0.3.2-2_all.deb</a>；</p>
<h3 id="2-安装-zjunet"><a href="#2-安装-zjunet" class="headerlink" title="2. 安装 zjunet"></a>2. 安装 zjunet</h3><p>进入root权限，在命令行中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dpkg -i zjunet_0.3.2-2_all.deb</span><br></pre></td></tr></table></figure>

<p>若存在依赖关系问题无法安装，则在命令行中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get -f -y install</span><br></pre></td></tr></table></figure>

<p>修复依赖关系问题后，再次安装deb文件</p>
<h3 id="3-输入校园vpn账号密码"><a href="#3-输入校园vpn账号密码" class="headerlink" title="3. 输入校园vpn账号密码"></a>3. 输入校园vpn账号密码</h3><p>在命令行中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ zjunet user add 学号</span><br></pre></td></tr></table></figure>

<p>然后按照提示输入vpn账号和密码；</p>
<h3 id="4-连接有线网"><a href="#4-连接有线网" class="headerlink" title="4. 连接有线网"></a>4. 连接有线网</h3><p>插入网线后，在命令行输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ zjunet vpn -c</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cc98.org/topic/4801518" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#77--组合</title>
    <url>/2020/04/20/leetcode77/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#77–组合</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：组合（中等）"><a href="#1-题目：组合（中等）" class="headerlink" title="1.题目：组合（中等）"></a>1.题目：组合（中等）</h3><p>给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: n = 4, k = 2<br>输出:<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p>
</blockquote>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 路径</span></span><br><span class="line">        backtrack(res, path, n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        <span class="keyword">if</span> ( path.<span class="built_in">size</span>() == k ) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可选列表</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = start; i &lt;= n; ++i ) &#123;</span><br><span class="line">            path.push_back(i);</span><br><span class="line">            backtrack(res, path, n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu中kworker占用CPU过高的问题</title>
    <url>/2020/05/02/ubuntu-kworker/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍了在ubuntu20.04中解决kworker占用CPU过高问题的方法</p>
</blockquote>
<a id="more"></a>
<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h3><h4 id="1-配置"><a href="#1-配置" class="headerlink" title="(1) 配置"></a>(1) 配置</h4><p>电脑： HUAWEI matebook x pro 2019 (集显版本)<br>CPU： Intel® Core™ i5-8265U CPU @ 1.60GHz × 8 (64位)<br>显卡： Mesa Intel® UHD Graphics 620 (WHL GT2)<br>内存： 8G<br>硬盘： 512G SSD<br>系统： Windows 10 / Ubuntu 20.04 LTS 双系统</p>
<h4 id="2-问题"><a href="#2-问题" class="headerlink" title="(2) 问题"></a>(2) 问题</h4><p>在安装ubuntu20.04双系统后出现电脑发热，风扇一直转。即使不运行任何程序也是如此</p>
<h4 id="3-原因"><a href="#3-原因" class="headerlink" title="(3) 原因"></a>(3) 原因</h4><p>在终端中输入 <code>top</code> 命令检查各个进程的资源占用情况，发现，一个叫做<strong>kworker</strong>的进程占用了80%的CPU资源</p>
<h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h3><p>在终端中输入 su 并输入密码进入root权限之后，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"disable"</span> &gt; /sys/firmware/acpi/interrupts/gpe6F</span><br></pre></td></tr></table></figure>

<p>即可解决问题，再使用 <code>top</code> 命令查看发现，<strong>kworker</strong>进程已经消失了</p>
<h3 id="3-设置开机自启动"><a href="#3-设置开机自启动" class="headerlink" title="3. 设置开机自启动"></a>3. 设置开机自启动</h3><p>为了避免每次开机都要进行上述的操作来kill掉<strong>kworker</strong>进程，可以通过将上述的命令设置为开机自启动命令<br>这样每次开机，系统就会自动帮我们执行上述命令，而无需手动操作</p>
<h4 id="1-建立-rc-local-service-文件"><a href="#1-建立-rc-local-service-文件" class="headerlink" title="(1) 建立 rc-local.service 文件"></a>(1) 建立 rc-local.service 文件</h4><p>在终端中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vi /etc/systemd/system/rc-local.service</span><br></pre></td></tr></table></figure>

<p>然后，复制以下内容到该文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=/etc/rc.local Compatibility</span><br><span class="line">ConditionPathExists=/etc/rc.local</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/etc/rc.local start</span><br><span class="line">TimeoutSec=0</span><br><span class="line">StandardOutput=tty</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">SysVStartPriority=99</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<h4 id="2-创建我们自定义的启动脚本"><a href="#2-创建我们自定义的启动脚本" class="headerlink" title="(2) 创建我们自定义的启动脚本"></a>(2) 创建我们自定义的启动脚本</h4><p>在终端中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vi /etc/rc.local</span><br></pre></td></tr></table></figure>

<p>在文件中写入需要自启动的命令<br><strong>注意：</strong> 所有的自启动命令都需要写在 <code>exit 0</code> 之前</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh -e</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># rc.local</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This script is executed at the end of each multiuser runlevel.</span></span><br><span class="line"><span class="comment"># Make sure that the script will "exit 0" on success or any other</span></span><br><span class="line"><span class="comment"># value on error.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In order to enable or disable this script just change the execution</span></span><br><span class="line"><span class="comment"># bits.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default this script does nothing.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"看到这行字，说明添加自启动脚本成功。"</span> &gt; /usr/<span class="built_in">local</span>/test.log <span class="comment"># 用于测试</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"disable"</span> &gt; /sys/firmware/acpi/interrupts/gpe6F</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<h4 id="3-使启动脚本有效"><a href="#3-使启动脚本有效" class="headerlink" title="(3) 使启动脚本有效"></a>(3) 使启动脚本有效</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo chmod +x /etc/rc.local &amp;&amp; sudo systemctl <span class="built_in">enable</span> rc-local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务并检查服务</span></span><br><span class="line">$ sudo systemctl start rc-local.service</span><br><span class="line">$ sudo systemctl status rc-local.service</span><br></pre></td></tr></table></figure>

<p>若出现绿色字样，则设置成功</p>
<p>重新启动，再次用 <code>top</code> 命令检查CPU占用情况，发现<strong>kworker</strong>进程已经没有了，问题解决！</p>
<h3 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h3><p><a href="https://blog.csdn.net/qq_35868811/article/details/99679185" target="_blank" rel="noopener">结束kworker进程</a><br><a href="https://www.cnblogs.com/schips/p/10318078.html" target="_blank" rel="noopener">设置开机自启动</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划题目总结</title>
    <url>/2020/05/02/dp/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了动态规划方法在leetcode上的有关习题</p>
<a id="more"></a>
</blockquote>
<h3 id="1-leetcode上的相关题目"><a href="#1-leetcode上的相关题目" class="headerlink" title="1. leetcode上的相关题目"></a>1. leetcode上的相关题目</h3><table>
<thead>
<tr>
<th>题号</th>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td><a href="https://shuoshuo666.github.io/2020/03/21/leetcode5/">最长回文子串</a></td>
<td>中等</td>
</tr>
<tr>
<td>53</td>
<td><a href="https://shuoshuo666.github.io/2020/03/02/leetcode53/">最大子序和</a></td>
<td>简单</td>
</tr>
<tr>
<td>62</td>
<td><a href="https://shuoshuo666.github.io/2020/04/15/leetcode62/">不同路径</a></td>
<td>中等</td>
</tr>
<tr>
<td>63</td>
<td><a href="https://shuoshuo666.github.io/2020/04/16/leetcode63/">不同路径II</a></td>
<td>中等</td>
</tr>
<tr>
<td>64</td>
<td><a href="https://shuoshuo666.github.io/2020/04/16/leetcode64/">最小路径和</a></td>
<td>中等</td>
</tr>
<tr>
<td>70</td>
<td><a href="https://shuoshuo666.github.io/2020/03/03/leetcode70/">爬楼梯</a></td>
<td>简单</td>
</tr>
<tr>
<td>91</td>
<td><a href="https://shuoshuo666.github.io/2020/04/24/leetcode91/">解码方法</a></td>
<td>中等</td>
</tr>
<tr>
<td>96</td>
<td><a href="https://shuoshuo666.github.io/2020/04/30/leetcode96/">不同的二叉搜索树</a></td>
<td>中等</td>
</tr>
<tr>
<td>121</td>
<td><a href="https://shuoshuo666.github.io/2020/03/14/leetcode121/">买卖股票的最佳时机</a></td>
<td>简单</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法总结</title>
    <url>/2020/05/03/backtrack/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了回溯算法的基本框架以及leetcode上的有关习题</p>
<a id="more"></a>
</blockquote>
<h3 id="1-基本框架"><a href="#1-基本框架" class="headerlink" title="1. 基本框架"></a>1. 基本框架</h3><h4 id="0-内容来源"><a href="#0-内容来源" class="headerlink" title="(0) 内容来源:"></a>(0) 内容来源:</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484709&idx=1&sn=1c24a5c41a5a255000532e83f38f2ce4&chksm=9bd7fb2daca0723be888b30345e2c5e64649fc31a00b05c27a0843f349e2dd9363338d0dac61&scene=21#wechat_redirect" target="_blank" rel="noopener">链接</a></p>
<h4 id="1-基本框架-1"><a href="#1-基本框架-1" class="headerlink" title="(1) 基本框架"></a>(1) 基本框架</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<h3 id="2-leetcode上的相关题目"><a href="#2-leetcode上的相关题目" class="headerlink" title="2. leetcode上的相关题目"></a>2. leetcode上的相关题目</h3><table>
<thead>
<tr>
<th>题号</th>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>17</td>
<td><a href="https://shuoshuo666.github.io/2020/03/26/leetcode17/">电话号码的字母组合</a></td>
<td>中等</td>
</tr>
<tr>
<td>22</td>
<td><a href="https://shuoshuo666.github.io/2020/03/28/leetcode22/">括号生成</a></td>
<td>中等</td>
</tr>
<tr>
<td>39</td>
<td><a href="https://shuoshuo666.github.io/2020/04/09/leetcode39/">组合总和</a></td>
<td>中等</td>
</tr>
<tr>
<td>40</td>
<td><a href="https://shuoshuo666.github.io/2020/04/09/leetcode40/">组合总和II</a></td>
<td>中等</td>
</tr>
<tr>
<td>46</td>
<td><a href="https://shuoshuo666.github.io/2020/04/10/leetcode46/">全排列</a></td>
<td>中等</td>
</tr>
<tr>
<td>47</td>
<td><a href="https://shuoshuo666.github.io/2020/04/10/leetcode47/">全排列II</a></td>
<td>中等</td>
</tr>
<tr>
<td>77</td>
<td><a href="https://shuoshuo666.github.io/2020/04/20/leetcode77/">组合</a></td>
<td>中等</td>
</tr>
<tr>
<td>78</td>
<td><a href="https://shuoshuo666.github.io/2020/04/20/leetcode78/">子集</a></td>
<td>中等</td>
</tr>
<tr>
<td>79</td>
<td><a href="https://shuoshuo666.github.io/2020/04/21/leetcode79/">单词搜索</a></td>
<td>中等</td>
</tr>
<tr>
<td>90</td>
<td><a href="https://shuoshuo666.github.io/2020/04/24/leetcode90/">子集II</a></td>
<td>中等</td>
</tr>
<tr>
<td>93</td>
<td><a href="https://shuoshuo666.github.io/2020/04/25/leetcode93/">复原IP地址</a></td>
<td>中等</td>
</tr>
<tr>
<td>113</td>
<td><a href="https://shuoshuo666.github.io/2020/05/09/leetcode113/">路径总和II</a></td>
<td>中等</td>
</tr>
<tr>
<td>129</td>
<td><a href="https://shuoshuo666.github.io/2020/05/12/leetcode129/">求根到叶子节点数字之和</a></td>
<td>中等</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>广度优先搜索总结</title>
    <url>/2020/05/04/bfs/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了广度优先搜索的基本框架以及leetcode上的有关习题</p>
<a id="more"></a>
</blockquote>
<h3 id="1-基本框架"><a href="#1-基本框架" class="headerlink" title="1. 基本框架"></a>1. 基本框架</h3><h4 id="0-内容来源"><a href="#0-内容来源" class="headerlink" title="(0) 内容来源:"></a>(0) 内容来源:</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485134&idx=1&sn=fd345f8a93dc4444bcc65c57bb46fc35&chksm=9bd7f8c6aca071d04c4d383f96f2b567ad44dc3e67d1c3926ec92d6a3bcc3273de138b36a0d9&scene=21#wechat_redirect" target="_blank" rel="noopener">链接</a></p>
<h4 id="1-基本框架-1"><a href="#1-基本框架-1" class="headerlink" title="(1) 基本框架"></a>(1) 基本框架</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line"></span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj())</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-leetcode上的相关题目"><a href="#2-leetcode上的相关题目" class="headerlink" title="2. leetcode上的相关题目"></a>2. leetcode上的相关题目</h3><table>
<thead>
<tr>
<th>题号</th>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>101</td>
<td><a href="https://shuoshuo666.github.io/2020/03/10/leetcode101/">对称二叉树</a></td>
<td>简单</td>
</tr>
<tr>
<td>102</td>
<td><a href="https://shuoshuo666.github.io/2020/04/30/leetcode102/">二叉树的层序遍历</a></td>
<td>中等</td>
</tr>
<tr>
<td>103</td>
<td><a href="https://shuoshuo666.github.io/2020/04/30/leetcode103/">二叉树的锯齿形层次遍历</a></td>
<td>中等</td>
</tr>
<tr>
<td>107</td>
<td><a href="https://shuoshuo666.github.io/2020/03/11/leetcode107/">二叉树的层次遍历II</a></td>
<td>简单</td>
</tr>
<tr>
<td>111</td>
<td><a href="https://shuoshuo666.github.io/2020/03/13/leetcode111/">二叉树的最小深度</a></td>
<td>简单</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#105--从前序与中序遍历序列构造二叉树</title>
    <url>/2020/05/08/leetcode105/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#105–从前序与中序遍历序列构造二叉树</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：从前序与中序遍历序列构造二叉树（中等）"><a href="#1-题目：从前序与中序遍历序列构造二叉树（中等）" class="headerlink" title="1.题目：从前序与中序遍历序列构造二叉树（中等）"></a>1.题目：从前序与中序遍历序列构造二叉树（中等）</h3><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder.cbegin(), preorder.cend(), inorder.cbegin(), inorder.cend());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> citer = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator; <span class="comment">// vector&lt;int&gt;::const_iterator的类型别名</span></span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(citer preStart, citer preEnd, citer inStart, citer inEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( preStart == preEnd ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootValue = *preStart; <span class="comment">// 根节点的值</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootValue); <span class="comment">// 建立根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中序遍历中找到根节点的位置</span></span><br><span class="line">        <span class="keyword">auto</span> iter = inStart;</span><br><span class="line">        <span class="keyword">while</span> ( *iter != rootValue ) ++iter;</span><br><span class="line">        <span class="keyword">int</span> leftCount = iter - inStart; <span class="comment">// 左子树节点数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归建立左子树与右子树</span></span><br><span class="line">        root-&gt;left = helper(preStart + <span class="number">1</span>, preStart + <span class="number">1</span> + leftCount, inStart, iter);</span><br><span class="line">        root-&gt;right = helper(preStart + <span class="number">1</span> + leftCount, preEnd, iter + <span class="number">1</span>, inEnd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#99--恢复二叉搜索树</title>
    <url>/2020/05/08/leetcode99/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#99–恢复二叉搜索树</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：恢复二叉搜索树（困难）"><a href="#1-题目：恢复二叉搜索树（困难）" class="headerlink" title="1.题目：恢复二叉搜索树（困难）"></a>1.题目：恢复二叉搜索树（困难）</h3><p>二叉搜索树中的两个节点被错误地交换。</p>
<p>请在不改变其结构的情况下，恢复这棵树。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-中序遍历-递归"><a href="#1-中序遍历-递归" class="headerlink" title="(1) 中序遍历(递归)"></a>(1) 中序遍历(递归)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        TreeNode* temp = <span class="keyword">new</span> TreeNode(firstNode-&gt;val);</span><br><span class="line">        firstNode-&gt;val = secondNode-&gt;val;</span><br><span class="line">        secondNode-&gt;val = temp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* firstNode = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* secondNode = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* preNode = <span class="keyword">new</span> TreeNode(INT32_MIN);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( node == <span class="literal">nullptr</span> ) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(node-&gt;left);</span><br><span class="line">        <span class="comment">// ********操作********</span></span><br><span class="line">        <span class="keyword">if</span> ( firstNode == <span class="literal">nullptr</span> &amp;&amp; preNode-&gt;val &gt; node-&gt;val ) firstNode = preNode;</span><br><span class="line">        <span class="keyword">if</span> ( firstNode != <span class="literal">nullptr</span> &amp;&amp; preNode-&gt;val &gt; node-&gt;val ) secondNode = node;</span><br><span class="line">        preNode = node;</span><br><span class="line">        <span class="comment">// *******************</span></span><br><span class="line">        inOrder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-中序遍历-迭代"><a href="#2-中序遍历-迭代" class="headerlink" title="(2) 中序遍历(迭代)"></a>(2) 中序遍历(迭代)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; auxStack;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        TreeNode* firstNode = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* secondNode = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* preNode = <span class="keyword">new</span> TreeNode(INT32_MIN);</span><br><span class="line">        <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> || !auxStack.empty() ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                auxStack.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = auxStack.top();</span><br><span class="line">            auxStack.pop();</span><br><span class="line">            <span class="comment">// ********操作********</span></span><br><span class="line">            <span class="keyword">if</span> ( firstNode == <span class="literal">nullptr</span> &amp;&amp; preNode-&gt;val &gt; node-&gt;val ) firstNode = preNode;</span><br><span class="line">            <span class="keyword">if</span> ( firstNode != <span class="literal">nullptr</span> &amp;&amp; preNode-&gt;val &gt; node-&gt;val ) secondNode = node;</span><br><span class="line">            preNode = node;</span><br><span class="line">            <span class="comment">// *******************</span></span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换两个节点</span></span><br><span class="line">        TreeNode* temp = <span class="keyword">new</span> TreeNode(firstNode-&gt;val);</span><br><span class="line">        firstNode-&gt;val = secondNode-&gt;val;</span><br><span class="line">        secondNode-&gt;val = temp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#106--从中序与后序遍历序列构造二叉树</title>
    <url>/2020/05/09/leetcode106/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#106–从中序与后序遍历序列构造二叉树</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：从中序与后序遍历序列构造二叉树（中等）"><a href="#1-题目：从中序与后序遍历序列构造二叉树（中等）" class="headerlink" title="1.题目：从中序与后序遍历序列构造二叉树（中等）"></a>1.题目：从中序与后序遍历序列构造二叉树（中等）</h3><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(inorder.cbegin(), inorder.cend(), postorder.cbegin(), postorder.cend());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> citer = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(citer inStart, citer inEnd, citer postStart, citer postEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( inStart == inEnd ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootValue = *(postEnd - <span class="number">1</span>); <span class="comment">// 根节点的值</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootValue); <span class="comment">// 建立根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中序遍历中找到根节点的位置</span></span><br><span class="line">        citer iter = inStart;</span><br><span class="line">        <span class="keyword">while</span> ( *iter != rootValue ) ++iter;</span><br><span class="line">        <span class="keyword">int</span> leftCount = iter - inStart;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归建立左子树与右子树</span></span><br><span class="line">        root-&gt;left = helper(inStart, iter, postStart, postStart + leftCount);</span><br><span class="line">        root-&gt;right = helper(iter + <span class="number">1</span>, inEnd, postStart + leftCount, postEnd - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#113--路径总和II</title>
    <url>/2020/05/09/leetcode113/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#113–路径总和II</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：路径总和II（简单）"><a href="#1-题目：路径总和II（简单）" class="headerlink" title="1.题目：路径总和II（简单）"></a>1.题目：路径总和II（简单）</h3><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        dfs(res, path, root, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; sum == root-&gt;val ) &#123;</span><br><span class="line">            path.push_back(root-&gt;val);</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            path.pop_back();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span> ) dfs(res, path, root-&gt;left, sum - root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span> ) dfs(res, path, root-&gt;right, sum - root-&gt;val);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#114--二叉树展开为链表</title>
    <url>/2020/05/10/leetcode114/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#114–二叉树展开为链表</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树展开为链表（中等）"><a href="#1-题目：二叉树展开为链表（中等）" class="headerlink" title="1.题目：二叉树展开为链表（中等）"></a>1.题目：二叉树展开为链表（中等）</h3><p>给定一个二叉树，原地将它展开为链表。</p>
<h3 id="2-题解-前序遍历"><a href="#2-题解-前序遍历" class="headerlink" title="2.题解(前序遍历)"></a>2.题解(前序遍历)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; auxStack;</span><br><span class="line"></span><br><span class="line">        TreeNode* preBegin = <span class="keyword">new</span> TreeNode(<span class="number">-1</span>);</span><br><span class="line">        preBegin-&gt;right = root;</span><br><span class="line"></span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        TreeNode* ptr = preBegin;</span><br><span class="line">        <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> || !auxStack.empty() ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                auxStack.push(node-&gt;right);</span><br><span class="line">                <span class="comment">// ****操作****</span></span><br><span class="line">                ptr-&gt;right = node;</span><br><span class="line">                ptr = ptr-&gt;right;</span><br><span class="line">                <span class="comment">// ***********</span></span><br><span class="line">                TreeNode* temp = node-&gt;left;</span><br><span class="line">                node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                node = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            node = auxStack.top();</span><br><span class="line">            auxStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#116--填充每个节点的下一个右侧节点指针</title>
    <url>/2020/05/10/leetcode116/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#116–填充每个节点的下一个右侧节点指针</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：填充每个节点的下一个右侧节点指针（中等）"><a href="#1-题目：填充每个节点的下一个右侧节点指针（中等）" class="headerlink" title="1.题目：填充每个节点的下一个右侧节点指针（中等）"></a>1.题目：填充每个节点的下一个右侧节点指针（中等）</h3><p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>初始状态下，所有 next 指针都被设置为 NULL。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> root;</span><br><span class="line">		Node* pre = root; <span class="comment">// 每一层的左边第一个节点</span></span><br><span class="line">		<span class="comment">// 循环条件是当前节点的left不为空，当只有根节点</span></span><br><span class="line">		<span class="comment">// 或所有叶子节点都出串联完后循环就退出了</span></span><br><span class="line">		<span class="keyword">while</span> ( pre-&gt;left != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">			Node* tmp = pre; <span class="comment">// 该层的每一个节点</span></span><br><span class="line">			<span class="keyword">while</span> ( tmp != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">				<span class="comment">// 将tmp的左右节点都串联起来</span></span><br><span class="line">				<span class="comment">// 注:外层循环已经判断了当前节点的left不为空</span></span><br><span class="line">				tmp-&gt;left-&gt;next = tmp-&gt;right;</span><br><span class="line">				<span class="comment">// 下一个不为空说明上一层已经帮我们完成串联了</span></span><br><span class="line">				<span class="keyword">if</span> ( tmp-&gt;next != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">					tmp-&gt;right-&gt;next = tmp-&gt;next-&gt;left;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 继续右边遍历</span></span><br><span class="line">				tmp = tmp-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 从下一层的最左边开始遍历</span></span><br><span class="line">			pre = pre-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#117--填充每个节点的下一个右侧节点指针II</title>
    <url>/2020/05/11/leetcode117/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#117–填充每个节点的下一个右侧节点指针II</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：填充每个节点的下一个右侧节点指针II（中等）"><a href="#1-题目：填充每个节点的下一个右侧节点指针II（中等）" class="headerlink" title="1.题目：填充每个节点的下一个右侧节点指针II（中等）"></a>1.题目：填充每个节点的下一个右侧节点指针II（中等）</h3><p>给定一个二叉树<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>初始状态下，所有 next 指针都被设置为 NULL。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> root;</span><br><span class="line">        Node* curRoot = root;</span><br><span class="line">        Node* dummy = <span class="keyword">new</span> Node(<span class="number">-1</span>); <span class="comment">// 哑节点十分精髓！！！</span></span><br><span class="line">        Node* pre = dummy; <span class="comment">// 每层的第一个节点</span></span><br><span class="line">        <span class="keyword">while</span> ( curRoot != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( curRoot-&gt;left ) &#123;</span><br><span class="line">                pre-&gt;next = curRoot-&gt;left;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( curRoot-&gt;right )&#123;</span><br><span class="line">                pre-&gt;next = curRoot-&gt;right;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( curRoot-&gt;next != <span class="literal">nullptr</span> ) curRoot = curRoot-&gt;next;</span><br><span class="line">            <span class="comment">//遍历到某层的最后一个节点就跳到下一层</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( curRoot-&gt;next == <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                curRoot = dummy-&gt;next;</span><br><span class="line">                dummy-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                pre = dummy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#124--二叉树中的最大路径和</title>
    <url>/2020/05/11/leetcode124/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#124–二叉树中的最大路径和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树中的最大路径和（困难）"><a href="#1-题目：二叉树中的最大路径和（困难）" class="headerlink" title="1.题目：二叉树中的最大路径和（困难）"></a>1.题目：二叉树中的最大路径和（困难）</h3><p>给定一个非空二叉树，返回其最大路径和。</p>
<p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> maxValue = INT32_MIN;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回经过root的单边分支最大和， 即Math.max(root, root+left, root+right)</span></span><br><span class="line"><span class="comment">     * @param root</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//计算左边分支最大值，左边分支如果为负数还不如不选择</span></span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="built_in">max</span>(<span class="number">0</span>, dfs(root-&gt;left));</span><br><span class="line">        <span class="comment">//计算右边分支最大值，右边分支如果为负数还不如不选择</span></span><br><span class="line">        <span class="keyword">int</span> rightMax = <span class="built_in">max</span>(<span class="number">0</span>, dfs(root-&gt;right));</span><br><span class="line">        <span class="comment">//left-&gt;root-&gt;right 作为路径与历史最大值做比较</span></span><br><span class="line">        maxValue = <span class="built_in">max</span>(maxValue, root-&gt;val + leftMax + rightMax);</span><br><span class="line">        <span class="comment">// 返回经过root的单边最大分支给上游</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(leftMax, rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#129--求根到叶子节点数字之和</title>
    <url>/2020/05/12/leetcode129/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#129–求根到叶子节点数字之和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：求根到叶子节点数字之和（中等）"><a href="#1-题目：求根到叶子节点数字之和（中等）" class="headerlink" title="1.题目：求根到叶子节点数字之和（中等）"></a>1.题目：求根到叶子节点数字之和（中等）</h3><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p>
<p>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。</p>
<p>计算从根到叶子节点生成的所有数字之和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        dfs(root, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> accumulate(res.cbegin(), res.cend(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res, <span class="keyword">int</span> pathSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            res.push_back(<span class="number">10</span> * pathSum + node-&gt;val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;left != <span class="literal">nullptr</span> ) dfs(node-&gt;left, res, <span class="number">10</span> * pathSum + node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;right != <span class="literal">nullptr</span> ) dfs(node-&gt;right, res, <span class="number">10</span> * pathSum + node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#144--二叉树的前序遍历</title>
    <url>/2020/05/13/leetcode144/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#144–二叉树的前序遍历</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树的前序遍历（中等）"><a href="#1-题目：二叉树的前序遍历（中等）" class="headerlink" title="1.题目：二叉树的前序遍历（中等）"></a>1.题目：二叉树的前序遍历（中等）</h3><p>给定一个二叉树，返回它的 前序 遍历。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; auxStack;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> || !auxStack.empty() ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                auxStack.push(node-&gt;right);</span><br><span class="line">                res.push_back(node-&gt;val);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = auxStack.top();</span><br><span class="line">            auxStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#145--二叉树的后序遍历</title>
    <url>/2020/05/14/leetcode145/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#145–二叉树的后序遍历</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树的后序遍历（困难）"><a href="#1-题目：二叉树的后序遍历（困难）" class="headerlink" title="1.题目：二叉树的后序遍历（困难）"></a>1.题目：二叉树的后序遍历（困难）</h3><p>给定一个二叉树，返回它的 后序 遍历。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> ( !stk.empty() ) &#123;</span><br><span class="line">            TreeNode* node = stk.top();</span><br><span class="line">            <span class="keyword">if</span> ( node == <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                res.push_back(stk.top()-&gt;val);</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">if</span> ( node-&gt;right ) stk.push(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> ( node-&gt;left ) stk.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#173--二叉搜索树迭代器</title>
    <url>/2020/05/15/leetcode173/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#173–二叉搜索树迭代器</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉搜索树迭代器（中等）"><a href="#1-题目：二叉搜索树迭代器（中等）" class="headerlink" title="1.题目：二叉搜索树迭代器（中等）"></a>1.题目：二叉搜索树迭代器（中等）</h3><p>实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。</p>
<p>调用 next() 将返回二叉搜索树中的下一个最小的数。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-中序遍历"><a href="#1-中序遍历" class="headerlink" title="(1) 中序遍历"></a>(1) 中序遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BSTIterator(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> || !stk.empty() ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                stk.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            midorder.push_back(node-&gt;val);</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        iter = midorder.cbegin();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iter != midorder.cend();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; midorder;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator iter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-受控的中序遍历"><a href="#2-受控的中序遍历" class="headerlink" title="(2) 受控的中序遍历"></a>(2) 受控的中序遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    BSTIterator(TreeNode* root) &#123;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        leftInorder(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode* tmp = stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">        <span class="keyword">if</span> ( tmp-&gt;right != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            leftInorder(tmp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">leftInorder</span><span class="params">( TreeNode* node )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            stk.push(node);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
</search>
