<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Adaboost算法</title>
    <url>/2019/09/19/adaboost/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了集成学习领域中基于boosting思想的Adaboost算法</p>
</blockquote>
<a id="more"></a>

<h3 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="1. 基本思想"></a>1. 基本思想</h3><p>在二分类问题中，通过采用 re-weighting 即更新权重的方式给每个基学习器的训练样本赋予不同的权重，以满足基学习器的多样性</p>
<p>具体来说，将更新后的权重应用于上一个基学习器的训练样本中时，其基学习器误差为0.5，即<br>已知：<br>$$\epsilon_t = \frac {\sum_{n}u_{t}^{n}\delta(f_{t}(x^n) \neq \hat y^n)}{Z_t} \tag{1}$$<br>$$\frac{\sum_{n}u_{t+1}^{n}\delta(f_{t}(x^n) \neq \hat y^n)}{Z_{t+1}} = \frac{1}{2} \tag{2}$$<br>其中：<br>$$Z_t = \sum_{n}u_{t}^{n}$$<br>$$Z_{t+1} = \sum_{n}u_{t+1}^{n}$$</p>
<h3 id="2-表达形式1"><a href="#2-表达形式1" class="headerlink" title="2. 表达形式1"></a>2. 表达形式1</h3><p>已知：</p>
<p>(1) 分类标签：<br>$$Y \in \{1, -1\}$$</p>
<p>(2) 权重更新方法：<br>$$<br>u_{t+1}^n =<br>\begin{cases}<br>u_t^n \cdot d_t,  &amp;\text{if $f_{t}(x^n) \neq \hat y^n$} \\<br>u_t^n / d_t,  &amp;\text{if $f_{t}(x^n) = \hat y^n$}<br>\end{cases}<br>\tag{3}<br>$$</p>
<p>由(1)(2)(3)解得：<br>$$d_t = \sqrt{\frac{1 - \epsilon_t}{\epsilon_t}} \tag{4}$$</p>
<p>引入：<br>$$\alpha_t = lnd_t \tag{5}$$</p>
<p>将(4)(5)代入(3)中，则有：<br>$$u_{t+1}^n = u_t^n \cdot exp(-\hat y^nf_t(x^n)\alpha_t)$$</p>
<p>最终学习器：<br>$$H(x) = sign(\sum_{t=1}^T\alpha_tf_t(x))$$</p>
<h3 id="3-表达形式2"><a href="#3-表达形式2" class="headerlink" title="3. 表达形式2"></a>3. 表达形式2</h3><p>已知：</p>
<p>(1) 分类标签：<br>$$Y \in \{1, 0\}$$</p>
<p>(2) 权重更新方法：<br>$$<br>u_{t+1}^n =<br>\begin{cases}<br>u_t^n / \beta_t,  &amp; \text{if $f_{t}(x^n) \neq \hat y^n$} \\<br>u_t^n, &amp; \text{if $f_{t}(x^n) = \hat y^n$}<br>\end{cases}<br>\tag{6}<br>$$</p>
<p>由(1)(2)(6)解得：<br>$$\beta_t = \frac{\epsilon_t}{1 - \epsilon_t} \tag{7}$$</p>
<p>将(7)代入(6)中，则有：<br>$$u_{t+1}^n = u_t^n \cdot \beta_t^{-|f_t(x^n) - \hat y^n|}$$</p>
<p>最终学习器：<br>$$<br>H(x) =<br>\begin{cases}<br>1,  &amp;\text{if $\sum_{t=1}^Tf_t(x)ln(1/\beta_t) \ge \frac12\cdot\sum_{t=1}^Tln(1/\beta_t)$} \\[2ex]<br>0,  &amp;\text{otherwise}<br>\end{cases}<br>$$</p>
<h3 id="4-基学习器生成过程"><a href="#4-基学习器生成过程" class="headerlink" title="4. 基学习器生成过程"></a>4. 基学习器生成过程</h3><p>$u_1 \to f_1 \to \epsilon_1 \to d_1 \to u_2 \to f_2 \to \epsilon_2 \to \cdots$</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>集成学习</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找法总结</title>
    <url>/2020/05/01/binarySearch/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了二分查找法的基本框架以及leetcode上的有关习题</p>
<a id="more"></a>
</blockquote>
<h3 id="1-基本框架"><a href="#1-基本框架" class="headerlink" title="1. 基本框架"></a>1. 基本框架</h3><h4 id="0-内容来源"><a href="#0-内容来源" class="headerlink" title="(0) 内容来源:"></a>(0) 内容来源:</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485044&idx=1&sn=e6b95782141c17abe206bfe2323a4226&chksm=9bd7f87caca0716aa5add0ddddce0bfe06f1f878aafb35113644ebf0cf0bfe51659da1c1b733&scene=21#wechat_redirect" target="_blank" rel="noopener">链接</a></p>
<h4 id="1-寻找一个数"><a href="#1-寻找一个数" class="headerlink" title="(1) 寻找一个数"></a>(1) 寻找一个数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 这里为闭区间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( left &lt;= right ) &#123; <span class="comment">// 这里为小于等于号；等于时，区间不为空(闭区间)，所以也要检查</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( nums[mid] == target ) <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( nums[mid] &lt; target ) left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( target &lt; nums[mid] ) right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-寻找左边界"><a href="#2-寻找左边界" class="headerlink" title="(2) 寻找左边界"></a>(2) 寻找左边界</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>(); <span class="comment">// 这里为左闭右开区间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( left &lt; right ) &#123; <span class="comment">// 这里为小于号；等于时，区间为空(左闭右开)，所以不用检查</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( nums[mid] == target ) right = mid; <span class="comment">// 关键</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( nums[mid] &lt; target ) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( target &lt; nums[mid]) right = mid; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查越界</span></span><br><span class="line">    <span class="comment">// left 的取值范围为[0, nums.size()]</span></span><br><span class="line">    <span class="comment">// 当left == nums.size()时，返回值 left 越界</span></span><br><span class="line">    <span class="keyword">if</span> ( left == nums.<span class="built_in">size</span>() ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums[left] == target ? left : <span class="number">-1</span>; <span class="comment">// 注意！返回 left</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-寻找右边界"><a href="#3-寻找右边界" class="headerlink" title="(3) 寻找右边界"></a>(3) 寻找右边界</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>(); <span class="comment">// 这里为左闭右开区间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( left &lt; right ) &#123; <span class="comment">// 这里为小于号；等于时，区间为空(左闭右开)，所以不用检查</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) left = mid + <span class="number">1</span>; <span class="comment">// 关键</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) right = mid; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查越界</span></span><br><span class="line">    <span class="comment">// left 的取值范围为[0, nums.size()]</span></span><br><span class="line">    <span class="comment">// 当left == 0时，返回值 left - 1 越界</span></span><br><span class="line">    <span class="keyword">if</span> ( left == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nums[left<span class="number">-1</span>] == target ? (left - <span class="number">1</span>) : <span class="number">-1</span>; <span class="comment">// 注意！返回 left - 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-leetcode上的相关题目"><a href="#2-leetcode上的相关题目" class="headerlink" title="2. leetcode上的相关题目"></a>2. leetcode上的相关题目</h3><h4 id="1-寻找一个数-1"><a href="#1-寻找一个数-1" class="headerlink" title="(1) 寻找一个数"></a>(1) 寻找一个数</h4><table>
<thead>
<tr>
<th>题号</th>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>33</td>
<td><a href="https://shuoshuo666.github.io/2020/03/31/leetcode33/">搜索旋转排序数组</a></td>
<td>中等</td>
</tr>
<tr>
<td>35</td>
<td><a href="https://shuoshuo666.github.io/2020/02/28/leetcode35/">搜索插入位置</a></td>
<td>简单</td>
</tr>
<tr>
<td>69</td>
<td><a href="https://shuoshuo666.github.io/2020/03/02/leetcode69/">x的平方根</a></td>
<td>简单</td>
</tr>
<tr>
<td>74</td>
<td><a href="https://shuoshuo666.github.io/2020/04/19/leetcode74/">搜索二维矩阵</a></td>
<td>中等</td>
</tr>
<tr>
<td>81</td>
<td><a href="https://shuoshuo666.github.io/2020/04/22/leetcode81/">搜索旋转排序数组II</a></td>
<td>中等</td>
</tr>
</tbody></table>
<h4 id="2-寻找左右边界"><a href="#2-寻找左右边界" class="headerlink" title="(2) 寻找左右边界"></a>(2) 寻找左右边界</h4><table>
<thead>
<tr>
<th>题号</th>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>34</td>
<td><a href="https://shuoshuo666.github.io/2020/03/31/leetcode34/">在排序数组中查找元素的第一个和最后一个位置</a></td>
<td>中等</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的拷贝构造函数</title>
    <url>/2019/11/25/copy-constructor/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了C++中的拷贝构造函数</p>
</blockquote>
<a id="more"></a>

<h3 id="1-什么时候调用拷贝构造函数"><a href="#1-什么时候调用拷贝构造函数" class="headerlink" title="1. 什么时候调用拷贝构造函数"></a>1. 什么时候调用拷贝构造函数</h3><p>(1) 复制对象，通过使用另一个同类型的对象来初始化新创建的对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassExample</span>&#123;</span>&#125;;  <span class="comment">//定义类ClassExample</span></span><br><span class="line">ClassExample B = A;  <span class="comment">//ClassExample B(A); 是一样的</span></span><br></pre></td></tr></table></figure>

<p>(2) 复制对象，把它作为参数传递给函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ClassExample C;  <span class="comment">//类ClassExample实例化对象C</span></span><br><span class="line">Fun(C);  <span class="comment">//将对象C通过值传递，作为参数传递给函数Fun</span></span><br></pre></td></tr></table></figure>

<p>(3) 复制对象，并从函数返回这个对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ClassExample <span class="title">Fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">ClassExample D;</span><br><span class="line"><span class="keyword">return</span> D;  <span class="comment">//函数Fun将对象D返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-什么时候必须自定义拷贝构造函数"><a href="#2-什么时候必须自定义拷贝构造函数" class="headerlink" title="2. 什么时候必须自定义拷贝构造函数"></a>2. 什么时候必须自定义拷贝构造函数</h3><p>(1) 类中带有指针变量<br>(2) 并且，类中有动态内存分配</p>
<blockquote>
<p>此时，自定义拷贝构造函数应使用深拷贝，而默认拷贝构造函数使用的浅拷贝</p>
</blockquote>
<h3 id="3-拷贝构造函数的常见定义形式"><a href="#3-拷贝构造函数的常见定义形式" class="headerlink" title="3. 拷贝构造函数的常见定义形式"></a>3. 拷贝构造函数的常见定义形式</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">classname (<span class="keyword">const</span> classname &amp;obj)&#123;</span><br><span class="line">    <span class="comment">//拷贝构造函数主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>gcc的简单命令</title>
    <url>/2019/08/21/gcc/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍了gcc的简单命令</p>
</blockquote>
<a id="more"></a>

<p>命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc main.c                <span class="comment"># 一步到位编译，生成a.exe文件</span></span><br><span class="line">$ gcc main.c --save-temps   <span class="comment"># 一步到位编译，保留中间文件</span></span><br><span class="line">$ gcc -E main.c -o main.i   <span class="comment"># 预编译，生成main.i文件</span></span><br><span class="line">$ gcc -S main.i -o main.s   <span class="comment"># 编译为汇编代码，生成main.s文件</span></span><br><span class="line">$ gcc -c main.s -o main.o   <span class="comment"># 汇编，生成main.o文件</span></span><br><span class="line">$ gcc main.o                <span class="comment"># 连接，生成a.exe文件</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>git的常用命令</title>
    <url>/2020/02/28/git/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍了git的常用命令</p>
</blockquote>
<a id="more"></a>

<p>命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init  <span class="comment"># 初始化一个git仓库</span></span><br><span class="line"></span><br><span class="line">git add &lt;filename&gt;  <span class="comment"># 将文件添加到暂存区</span></span><br><span class="line"></span><br><span class="line">git commit -m &lt;message&gt;  <span class="comment"># 将暂存区中的文件提交到当前分支</span></span><br><span class="line"></span><br><span class="line">git status  <span class="comment"># 掌握工作区状态</span></span><br><span class="line"></span><br><span class="line">git diff &lt;filename&gt;  <span class="comment"># 查看修改文件的改动</span></span><br><span class="line"></span><br><span class="line">git reset --hard commit_id  <span class="comment"># 版本回退</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span>  <span class="comment"># 查看提交历史</span></span><br><span class="line"></span><br><span class="line">git reflog  <span class="comment"># 查看命令历史</span></span><br><span class="line"></span><br><span class="line">git restore &lt;filename&gt;  <span class="comment"># 丢弃工作区的改动</span></span><br><span class="line"></span><br><span class="line">git restore --staged &lt;filename&gt;  <span class="comment"># 丢弃暂存区的改动</span></span><br><span class="line"></span><br><span class="line">git rm &lt;filename&gt;  <span class="comment"># 删除文件</span></span><br><span class="line"></span><br><span class="line">git remote add origin git@server-name:path/repo-name.git  <span class="comment"># 关联一个远程库</span></span><br><span class="line"></span><br><span class="line">git push -u origin master  <span class="comment"># 第一次推送master分支的所有内容</span></span><br><span class="line"></span><br><span class="line">git push origin master  <span class="comment"># 推送master分支中的所有内容</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> &lt;address&gt;  <span class="comment"># 把远程库克隆到本地</span></span><br><span class="line"></span><br><span class="line">git branch  <span class="comment"># 查看分支</span></span><br><span class="line"></span><br><span class="line">git branch &lt;name&gt;  <span class="comment"># 创建分支</span></span><br><span class="line"></span><br><span class="line">git branch -d &lt;name&gt;  <span class="comment"># 删除分支</span></span><br><span class="line"></span><br><span class="line">git switch &lt;name&gt;  <span class="comment"># 切换分支</span></span><br><span class="line"></span><br><span class="line">git switch -c &lt;name&gt;  <span class="comment"># 创建+切换分支</span></span><br><span class="line"></span><br><span class="line">git merge &lt;name&gt;  <span class="comment"># 合并分支到当前分支</span></span><br><span class="line"></span><br><span class="line">git merge --no-ff -m &lt;message&gt; &lt;name&gt;  <span class="comment"># 禁用Fast-Forward合并分支，并提交</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中变量的默认初始化</title>
    <url>/2020/02/13/init-var/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了C++中内置类型、数组类型、标准库类型等类型变量的默认初始化</p>
<a id="more"></a>
</blockquote>
<h3 id="1-内置类型"><a href="#1-内置类型" class="headerlink" title="1.内置类型"></a>1.内置类型</h3><p>(1)函数体外定义的变量初始成0；<br>(2)函数体内定义的变量不进行自动初始化；<br>(3)局部静态变量若没有显式初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。</p>
<h3 id="2-数组类型"><a href="#2-数组类型" class="headerlink" title="2.数组类型"></a>2.数组类型</h3><p>(1)若没有提供初始化列表，其自动初始化规则与内置类型一样：函数体外初始化为0；函数体内不进行自动初始化；<br>(2)若提供了部分初始化列表，剩下的数组元素，若为内置类型不论在哪定义，均初始化为0；若为类类型，则调用默认构造函数进行初始化</p>
<h3 id="3-vector类型"><a href="#3-vector类型" class="headerlink" title="3.vector类型"></a>3.vector类型</h3><p>若仅提供元素数量而没有提供初始值，若为内置类型则值初始化为0；若为类类型，调用默认构造函数进行初始化。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的初始化列表</title>
    <url>/2019/11/27/initialization-list/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了C++中的初始化列表</p>
<a id="more"></a>
</blockquote>
<h3 id="1-什么是初始化列表"><a href="#1-什么是初始化列表" class="headerlink" title="1.什么是初始化列表"></a>1.什么是初始化列表</h3><p>(1) 构造函数除了有名字，参数列表外，还可以有初始化列表；</p>
<p>(2) 初始化列表在构造函数头之后、大括号之前，以冒号开头，后面跟一系列以逗号分隔的初始化字段。</p>
<p>看一个例子，下面的代码定义了CExample类，使用了初始化列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    CExample() : a(<span class="number">6</span>), b(<span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//a = 6;</span></span><br><span class="line">        <span class="comment">//b = 6;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-构造函数的两个执行阶段"><a href="#2-构造函数的两个执行阶段" class="headerlink" title="2.构造函数的两个执行阶段"></a>2.构造函数的两个执行阶段</h3><blockquote>
<p>构造函数的执行可以分成两个阶段，初始化阶段和计算阶段，初始化阶段先于计算阶段 </p>
</blockquote>
<h4 id="1-初始化阶段"><a href="#1-初始化阶段" class="headerlink" title="(1) 初始化阶段"></a>(1) 初始化阶段</h4><p> 所有数据成员（包括类类型的成员）都会在初始化阶段初始化，即使该成员没有出现在构造函数的初始化列表中 </p>
<h4 id="2-计算阶段"><a href="#2-计算阶段" class="headerlink" title="(2) 计算阶段"></a>(2) 计算阶段</h4><p>一般用于执行构造函数体内的赋值操作 </p>
<p>看一个例子，下面的代码定义了Test类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    CExample e;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    Test(<span class="keyword">int</span> M, <span class="keyword">int</span> N, CExample&amp; K) : c(M), d(N), e(K)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//c = M;</span></span><br><span class="line">        <span class="comment">//d = N;</span></span><br><span class="line">        <span class="comment">//e = K;  将调用赋值运算符重载函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行如下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    CExample aaa;</span><br><span class="line">    <span class="function">Test <span class="title">bbb</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, aaa)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行至<code>Test bbb(1, 2, aaa)</code>时，将调用Test类的构造函数。</p>
<p>第一个阶段（即初始化阶段），不使用初始化列表（即代码中注释的部分）与使用初始化列表，将发生：</p>
<style>
table th:first-of-type {
    width: 100px;
}
table th:nth-of-type(2) {
    width: 225px;
}
</style>
<table>
<thead>
<tr>
<th align="center">数据成员</th>
<th align="center">不使用初始化列表</th>
<th align="center">使用初始化列表</th>
</tr>
</thead>
<tbody><tr>
<td align="center">内置类型</td>
<td align="center">int c, d;//变量的定义</td>
<td align="center">int c = 1;int d = 2;//变量的初始化</td>
</tr>
<tr>
<td align="center">类类型</td>
<td align="center">CExample e;//调用构造函数</td>
<td align="center">CExample bbb = aaa;//调用拷贝构造函数</td>
</tr>
</tbody></table>
<p>第二个阶段（即计算阶段），不使用初始化列表（即代码中注释的部分）与使用初始化列表，将发生：</p>
<table>
<thead>
<tr>
<th align="center">数据成员</th>
<th align="center">不使用初始化列表</th>
<th align="center">使用初始化列表</th>
</tr>
</thead>
<tbody><tr>
<td align="center">内置类型</td>
<td align="center">c = 1;d = 2;//变量的赋值</td>
<td align="center">–</td>
</tr>
<tr>
<td align="center">类类型</td>
<td align="center">e = k;//调用赋值运算符重载函数</td>
<td align="center">–</td>
</tr>
</tbody></table>
<p>综合两张表可以看出：</p>
<p>(1) 对内置类型的数据成员，不使用初始化列表是先定义、再赋值；而使用初始化列表则是直接初始化。这二者在结果和性能上并无太大区别</p>
<p>(2) 对于类类型的数据成员，不使用初始化列表是先调用构造函数创建对象、再调用赋值运算符重载函数进行对其进行赋值；而使用初始化列表则是直接调用拷贝构造函数进行初始化。显然，二者结果上没有区别，但是后者的性能要好于前者，因为后者少了一次调用构造函数的过程</p>
<p>所以一个好的原则是，能使用初始化列表的时候尽量使用初始化列表 </p>
<h3 id="3-什么时候必须使用初始化列表"><a href="#3-什么时候必须使用初始化列表" class="headerlink" title="3.什么时候必须使用初始化列表"></a>3.什么时候必须使用初始化列表</h3><p>(1)  数据成员常量成员(const)，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 </p>
<p>(2)  数据成员是引用类型(&amp;)，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 </p>
<p>(3)  数据成员是没有默认构造函数（即无参构造函数）的类类型，看一个例子</p>
<p>若将类CExample的定义改为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    CExample(<span class="keyword">int</span> M, <span class="keyword">int</span> N) : a(M), b(N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//a = M;</span></span><br><span class="line">        <span class="comment">//b = N;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码重载了构造函数，重载后的构造函数需要两个参数，而系统将不再自动生成无参的默认构造函数</p>
<p>若不使用初始化列表，当执行至<code>Test bbb(1, 2, aaa)</code>时，将调用Test类的构造函数</p>
<p>在第一阶段（即初始化阶段）时，将调用CExample类的构造函数（<code>CExample e;</code>），而类CExample的构造函数需要两个参数M和N，而代码<code>CExample e;</code>却没未提供，因此调用CExample类的构造函数将出现编译错误</p>
<p>因此当数据成员是没有默认构造函数的类类型时，必须使用初始化列表</p>
<h3 id="4-成员变量的初始化顺序"><a href="#4-成员变量的初始化顺序" class="headerlink" title="4.成员变量的初始化顺序"></a>4.成员变量的初始化顺序</h3><p>成员是按照他们在<code>类中出现的顺序</code>进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的 </p>
<p>看一个例子，若类CExample的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    CExample(<span class="keyword">int</span> M) : a(M), b(a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//a = M;</span></span><br><span class="line">        <span class="comment">//b = N;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok，先初始化a，后初始化b</p>
<p>若类CExample的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    CExample(<span class="keyword">int</span> M) : b(M), a(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//a = M;</span></span><br><span class="line">        <span class="comment">//b = N;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误！由于类定义中，a出现在b前面，所以无论初始化列表的顺序怎样，都是先初始化a，再初始化b</p>
<p>然而用<code>a(b)</code>初始化a时，b还没有定义，所以编译错误</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#1--两数之和</title>
    <url>/2020/02/21/leetcode1/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#1–两数之和题解</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：两数之和（简单）"><a href="#1-题目：两数之和（简单）" class="headerlink" title="1.题目：两数之和（简单）"></a>1.题目：两数之和（简单）</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-暴力解法"><a href="#1-暴力解法" class="headerlink" title="(1)暴力解法"></a>(1)暴力解法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; ++i ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( nums[i] + nums[j] == target ) &#123;</span><br><span class="line">                    res.push_back(i);</span><br><span class="line">                    res.push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行用时：452ms<br>消耗内存：9.4M</p>
<h4 id="2-使用哈希表"><a href="#2-使用哈希表" class="headerlink" title="(2)使用哈希表"></a>(2)使用哈希表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> ( hash.<span class="built_in">find</span>(temp) != hash.<span class="built_in">end</span>() ) &#123;</span><br><span class="line">                res.push_back(hash[temp]);</span><br><span class="line">                res.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> hash[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行用时：8ms<br>消耗内存：12.5M</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#100--相同的树</title>
    <url>/2020/03/10/leetcode100/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#100–相同的树</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：相同的树（简单）"><a href="#1-题目：相同的树（简单）" class="headerlink" title="1.题目：相同的树（简单）"></a>1.题目：相同的树（简单）</h3><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ( p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;val !=  q-&gt;val ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ( isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#101--对称二叉树</title>
    <url>/2020/03/10/leetcode101/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#101–对称二叉树</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：对称二叉树（简单）"><a href="#1-题目：对称二叉树（简单）" class="headerlink" title="1.题目：对称二叉树（简单）"></a>1.题目：对称二叉树（简单）</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p><strong>示例:</strong></p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="(1) 递归"></a>(1) 递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ( p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;val != q-&gt;val ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isMirror(p-&gt;left, q-&gt;right) &amp;&amp; isMirror(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-BFS"><a href="#2-BFS" class="headerlink" title="(2) BFS"></a>(2) BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(<span class="built_in">size</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i ) &#123;</span><br><span class="line">                root = q.front(); q.pop();</span><br><span class="line">                v[i] = root ? root-&gt;val : INT32_MIN;</span><br><span class="line">                <span class="keyword">if</span> ( root != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                    q.push(root-&gt;left);</span><br><span class="line">                    q.push(root-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否回文</span></span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span> / <span class="number">2</span>; ++i ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( v[i] != v[<span class="built_in">size</span> - <span class="number">1</span> - i] ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>BFS</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#102--二叉树的层序遍历</title>
    <url>/2020/04/30/leetcode102/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#102–二叉树的层序遍历</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：二叉树的层序遍历（中等）"><a href="#1-题目：二叉树的层序遍历（中等）" class="headerlink" title="1.题目：二叉树的层序遍历（中等）"></a>1.题目：二叉树的层序遍历（中等）</h3><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="(1) 递归"></a>(1) 递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        helper(root, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* node, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( res.<span class="built_in">size</span>() == level ) res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        res[level].push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;left != <span class="literal">nullptr</span> ) helper(node-&gt;left, res, level + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;right != <span class="literal">nullptr</span> ) helper(node-&gt;right, res, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-BFS"><a href="#2-BFS" class="headerlink" title="(2) BFS"></a>(2) BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; order;</span><br><span class="line">        order.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( !order.empty() ) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; save;</span><br><span class="line">            <span class="keyword">size_t</span> count = order.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i ) &#123;</span><br><span class="line">                TreeNode* node = order.front();</span><br><span class="line">                order.pop();</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;left != <span class="literal">nullptr</span> ) order.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;right != <span class="literal">nullptr</span> ) order.push(node-&gt;right);</span><br><span class="line">                save.push_back(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(save);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>BFS</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#103--二叉树的锯齿形层次遍历</title>
    <url>/2020/04/30/leetcode103/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#103–二叉树的锯齿形层次遍历</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：二叉树的锯齿形层次遍历（中等）"><a href="#1-题目：二叉树的锯齿形层次遍历（中等）" class="headerlink" title="1.题目：二叉树的锯齿形层次遍历（中等）"></a>1.题目：二叉树的锯齿形层次遍历（中等）</h3><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<h3 id="2-题解-BFS"><a href="#2-题解-BFS" class="headerlink" title="2.题解(BFS)"></a>2.题解(BFS)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">zigzagLevelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; order;</span><br><span class="line">        order.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( !order.empty() ) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; save;</span><br><span class="line">            <span class="keyword">size_t</span> count = order.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i ) &#123;</span><br><span class="line">                TreeNode* node = order.front();</span><br><span class="line">                order.pop();</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;left != <span class="literal">nullptr</span> ) order.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;right != <span class="literal">nullptr</span> ) order.push(node-&gt;right);</span><br><span class="line">                save.push_back(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( res.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span> ) reverse(save.<span class="built_in">begin</span>(), save.<span class="built_in">end</span>());</span><br><span class="line">            res.push_back(save);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>BFS</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#104--二叉树的最大深度</title>
    <url>/2020/03/11/leetcode104/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#104–二叉树的最大深度</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树的最大深度（简单）"><a href="#1-题目：二叉树的最大深度（简单）" class="headerlink" title="1.题目：二叉树的最大深度（简单）"></a>1.题目：二叉树的最大深度（简单）</h3><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#107--二叉树的层次遍历2</title>
    <url>/2020/03/11/leetcode107/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#107–二叉树的层次遍历2</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树的层次遍历2（简单）"><a href="#1-题目：二叉树的层次遍历2（简单）" class="headerlink" title="1.题目：二叉树的层次遍历2（简单）"></a>1.题目：二叉树的层次遍历2（简单）</h3><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<h3 id="2-题解-队列"><a href="#2-题解-队列" class="headerlink" title="2.题解(队列)"></a>2.题解(队列)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrderBottom</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; order;</span><br><span class="line">        order.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( !order.empty() ) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; save;</span><br><span class="line">            <span class="keyword">size_t</span> count = order.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i ) &#123;</span><br><span class="line">                TreeNode* node = order.front();</span><br><span class="line">                order.pop();</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;left != <span class="literal">nullptr</span> ) order.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;right != <span class="literal">nullptr</span> ) order.push(node-&gt;right);</span><br><span class="line">                save.push_back(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(save);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>()); <span class="comment">// 逆序</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#108--将有序数组转化为二叉搜索树</title>
    <url>/2020/03/12/leetcode108/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#108–将有序数组转化为二叉搜索树</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：将有序数组转化为二叉搜索树（简单）"><a href="#1-题目：将有序数组转化为二叉搜索树（简单）" class="headerlink" title="1.题目：将有序数组转化为二叉搜索树（简单）"></a>1.题目：将有序数组转化为二叉搜索树（简单）</h3><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">begin</span> == <span class="built_in">end</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="built_in">begin</span> + (<span class="built_in">end</span> - <span class="built_in">begin</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root-&gt;left = sortedArrayToBST(nums, <span class="built_in">begin</span>, mid);</span><br><span class="line">        root-&gt;right = sortedArrayToBST(nums, mid + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#11--盛水最多的容器</title>
    <url>/2020/03/23/leetcode11/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#11–盛水最多的容器</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：盛水最多的容器（中等）"><a href="#1-题目：盛水最多的容器（中等）" class="headerlink" title="1.题目：盛水最多的容器（中等）"></a>1.题目：盛水最多的容器（中等）</h3><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入：[1,8,6,2,5,4,8,3,7]<br>输出：49</p>
</blockquote>
<h3 id="2-题解-双指针法"><a href="#2-题解-双指针法" class="headerlink" title="2.题解(双指针法)"></a>2.题解(双指针法)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="built_in">height</span>.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( i &lt; j ) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, (j - i) * <span class="built_in">min</span>(<span class="built_in">height</span>[i], <span class="built_in">height</span>[j]));</span><br><span class="line">            <span class="comment">//移动短板</span></span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">height</span>[i] &lt; <span class="built_in">height</span>[j] ) ++i;</span><br><span class="line">            <span class="keyword">else</span> --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#110--平衡二叉树</title>
    <url>/2020/03/12/leetcode110/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#110–平衡二叉树</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：平衡二叉树（简单）"><a href="#1-题目：平衡二叉树（简单）" class="headerlink" title="1.题目：平衡二叉树（简单）"></a>1.题目：平衡二叉树（简单）</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><h4 id="1-自顶向下"><a href="#1-自顶向下" class="headerlink" title="(1)自顶向下"></a>(1)自顶向下</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">abs</span>(depth(root-&gt;left) - depth(root-&gt;right)) &gt; <span class="number">1</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span> </span>&#123;  <span class="comment">//返回子树高度</span></span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(depth(root-&gt;left), depth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-自底向上"><a href="#2-自底向上" class="headerlink" title="(2)自底向上"></a>(2)自底向上</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> depth(root) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span> </span>&#123;  <span class="comment">//返回子树高度，若不平衡，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = depth(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> ( left == <span class="number">-1</span> ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = depth(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> ( right == <span class="number">-1</span> ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(left - right) &lt; <span class="number">2</span> ? <span class="built_in">max</span>(left, right) + <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#111--二叉树的最小深度</title>
    <url>/2020/03/13/leetcode111/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#111–二叉树的最小深度</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树的最小深度（简单）"><a href="#1-题目：二叉树的最小深度（简单）" class="headerlink" title="1.题目：二叉树的最小深度（简单）"></a>1.题目：二叉树的最小深度（简单）</h3><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="(1) 递归"></a>(1) 递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;left == <span class="literal">nullptr</span> ) <span class="keyword">return</span> minDepth(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;right == <span class="literal">nullptr</span> ) <span class="keyword">return</span> minDepth(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(minDepth(root-&gt;left), minDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-BFS"><a href="#2-BFS" class="headerlink" title="(2) BFS"></a>(2) BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i ) &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right ==<span class="literal">nullptr</span> ) <span class="keyword">return</span> depth;</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;left != <span class="literal">nullptr</span> ) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;right != <span class="literal">nullptr</span> ) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ++depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>BFS</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#112--路径总和</title>
    <url>/2020/03/13/leetcode112/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#112–路径总和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：路径总和（简单）"><a href="#1-题目：路径总和（简单）" class="headerlink" title="1.题目：路径总和（简单）"></a>1.题目：路径总和（简单）</h3><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="(1) 递归"></a>(1) 递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> )</span><br><span class="line">            <span class="keyword">return</span> sum == root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-BFS"><a href="#2-BFS" class="headerlink" title="(2) BFS"></a>(2) BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;TreeNode*, <span class="keyword">int</span>&gt;&gt; q;  <span class="comment">//保存节点及从根节点到此节点的路径和</span></span><br><span class="line">        q.push(make_pair(root, root-&gt;val));</span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i ) &#123;</span><br><span class="line">                pair&lt;TreeNode*, <span class="keyword">int</span>&gt; node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> ( node.first-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node.first-&gt;right == <span class="literal">nullptr</span> &amp;&amp; node.second == sum )</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> ( node.first-&gt;left ) q.push(make_pair(node.first-&gt;left, node.second + node.first-&gt;left-&gt;val));</span><br><span class="line">                <span class="keyword">if</span> ( node.first-&gt;right ) q.push(make_pair(node.first-&gt;right, node.second + node.first-&gt;right-&gt;val));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#118--杨辉三角</title>
    <url>/2020/03/14/leetcode118/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#118–杨辉三角</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：杨辉三角（简单）"><a href="#1-题目：杨辉三角（简单）" class="headerlink" title="1.题目：杨辉三角（简单）"></a>1.题目：杨辉三角（简单）</h3><p>给定一个非负整数 <em>numRows*，生成杨辉三角的前 *numRows</em> 行。</p>
<h3 id="2-题解-动态规划"><a href="#2-题解-动态规划" class="headerlink" title="2.题解(动态规划)"></a>2.题解(动态规划)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( numRows == <span class="number">0</span> ) <span class="keyword">return</span> &#123;&#125;;  <span class="comment">//输入为0的情况</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res = &#123;&#123;<span class="number">1</span>&#125;&#125;;  <span class="comment">//第一行</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numRows; ++i ) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">            temp.push_back(<span class="number">1</span>);  <span class="comment">//行首的1</span></span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j ) &#123;</span><br><span class="line">                temp.push_back(res[i - <span class="number">1</span>][j - <span class="number">1</span>] + res[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            temp.push_back(<span class="number">1</span>);  <span class="comment">//行尾的1</span></span><br><span class="line">            res.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#119--杨辉三角2</title>
    <url>/2020/03/14/leetcode119/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#119–杨辉三角2</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：杨辉三角2（简单）"><a href="#1-题目：杨辉三角2（简单）" class="headerlink" title="1.题目：杨辉三角2（简单）"></a>1.题目：杨辉三角2（简单）</h3><p>给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="(1)递归"></a>(1)递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( rowIndex == <span class="number">0</span> ) <span class="keyword">return</span> &#123;<span class="number">1</span>&#125;;  <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">auto</span> last = getRow(rowIndex - <span class="number">1</span>);  <span class="comment">//上一行的结果</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.push_back(<span class="number">1</span>);  <span class="comment">//行首的1</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rowIndex; ++i ) &#123;</span><br><span class="line">            res.push_back(last[i - <span class="number">1</span>] + last[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(<span class="number">1</span>);  <span class="comment">//行尾的1</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-秀"><a href="#2-秀" class="headerlink" title="(2)秀"></a>(2)秀</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; ++i ) &#123;  <span class="comment">//第i行的结果</span></span><br><span class="line">            result.push_back(<span class="number">1</span>);  <span class="comment">//行尾的1</span></span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; <span class="number">0</span>; --j ) &#123;  <span class="comment">//在同一个数组中产生下一行的结果</span></span><br><span class="line">                result[j] += result[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#12--整数转罗马数字</title>
    <url>/2020/03/24/leetcode12/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#12–整数转罗马数字</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：整数转罗马数字（中等）"><a href="#1-题目：整数转罗马数字（中等）" class="headerlink" title="1.题目：整数转罗马数字（中等）"></a>1.题目：整数转罗马数字（中等）</h3><p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</p>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 1994<br>输出: “MCMXCIV”<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; sys&#123;<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( index &lt; <span class="number">13</span> ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( num &gt;= nums[index] ) &#123;</span><br><span class="line">                res.append(sys[index]);</span><br><span class="line">                num -= nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#121--买卖股票的最佳时机</title>
    <url>/2020/03/14/leetcode121/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#121–买卖股票的最佳时机</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：买卖股票的最佳时机（简单）"><a href="#1-题目：买卖股票的最佳时机（简单）" class="headerlink" title="1.题目：买卖股票的最佳时机（简单）"></a>1.题目：买卖股票的最佳时机（简单）</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-暴力双循环"><a href="#1-暴力双循环" class="headerlink" title="(1)暴力双循环"></a>(1)暴力双循环</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); ++i )&#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; prices.<span class="built_in">size</span>(); ++j ) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, prices[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="(2)动态规划"></a>(2)动态规划</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( prices.empty() ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(prices.<span class="built_in">size</span>())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i )&#123;</span><br><span class="line">            minPrice = <span class="built_in">min</span>(minPrice, prices[i]);</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], prices[i] - minPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-动态规划-转化为最大子列和"><a href="#3-动态规划-转化为最大子列和" class="headerlink" title="(3)动态规划(转化为最大子列和)"></a>(3)动态规划(转化为最大子列和)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//转化为最大子列和问题</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( prices.<span class="built_in">size</span>() &lt;= <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//构造相邻元素求差数组</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diff</span><span class="params">(prices.<span class="built_in">size</span>() - <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>() - <span class="number">1</span>; ++i ) &#123;</span><br><span class="line">            diff[i] = prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构造DP数组</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(diff.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="built_in">max</span>(<span class="number">0</span>, diff[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> profit = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; diff.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(<span class="number">0</span>, dp[i<span class="number">-1</span>] + diff[i]);</span><br><span class="line">            profit = <span class="built_in">max</span>(profit, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#122--买卖股票的最佳时机2</title>
    <url>/2020/03/15/leetcode122/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#122–买卖股票的最佳时机2</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：买卖股票的最佳时机2（简单）"><a href="#1-题目：买卖股票的最佳时机2（简单）" class="headerlink" title="1.题目：买卖股票的最佳时机2（简单）"></a>1.题目：买卖股票的最佳时机2（简单）</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h3 id="2-题解-贪心算法"><a href="#2-题解-贪心算法" class="headerlink" title="2.题解(贪心算法)"></a>2.题解(贪心算法)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( prices.<span class="built_in">size</span>() &lt; <span class="number">2</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//建立求差数组</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; diff;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            diff.push_back(prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//累加求差数组中的正数</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j : diff ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( j &gt; <span class="number">0</span> ) res += j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>改进：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> ( diff &gt; <span class="number">0</span> ) res += diff;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#125--验证回文串</title>
    <url>/2020/03/15/leetcode125/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#125–验证回文串</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：验证回文串（简单）"><a href="#1-题目：验证回文串（简单）" class="headerlink" title="1.题目：验证回文串（简单）"></a>1.题目：验证回文串（简单）</h3><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p>说明：本题中，我们将空字符串定义为有效的回文串。</p>
<h3 id="2-题解-双指针"><a href="#2-题解-双指针" class="headerlink" title="2.题解(双指针)"></a>2.题解(双指针)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> left = <span class="number">0</span>, right = s.<span class="built_in">size</span>() - <span class="number">1</span>; left &lt; right; ++left, --right ) &#123;</span><br><span class="line">            <span class="keyword">while</span>( !<span class="built_in">isalnum</span>(s[left]) &amp;&amp; left &lt; right ) ++left;</span><br><span class="line">            <span class="keyword">while</span>( !<span class="built_in">isalnum</span>(s[right]) &amp;&amp; left &lt; right ) --right;</span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">toupper</span>(s[left]) != <span class="built_in">toupper</span>(s[right]) ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#13--罗马数字转整数</title>
    <url>/2020/02/22/leetcode13/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#13–罗马数字转整数</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：罗马数字转整数（简单）"><a href="#1-题目：罗马数字转整数（简单）" class="headerlink" title="1.题目：罗马数字转整数（简单）"></a>1.题目：罗马数字转整数（简单）</h3><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>I</td>
<td>1</td>
</tr>
<tr>
<td>V</td>
<td>5</td>
</tr>
<tr>
<td>X</td>
<td>10</td>
</tr>
<tr>
<td>L</td>
<td>50</td>
</tr>
<tr>
<td>C</td>
<td>100</td>
</tr>
<tr>
<td>D</td>
<td>500</td>
</tr>
<tr>
<td>M</td>
<td>1000</td>
</tr>
</tbody></table>
<p>例如，罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。27 写做 XXVII ,即为 XX + V + II。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。</li>
<li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。</li>
<li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: “III”<br>输出: 3</p>
<p>输入: “IV”<br>输出: 4</p>
<p>输入: “IX”<br>输出: 9</p>
<p>输入: “LVIII”<br>输出: 58<br>解释: L = 50, V= 5, III = 3</p>
<p>输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; tras = &#123;&#123;<span class="string">'I'</span>, <span class="number">1</span>&#125;, &#123;<span class="string">'V'</span>, <span class="number">5</span>&#125;, &#123;<span class="string">'X'</span>, <span class="number">10</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'L'</span>, <span class="number">50</span>&#125;, &#123;<span class="string">'C'</span>, <span class="number">100</span>&#125;, &#123;<span class="string">'D'</span>, <span class="number">500</span>&#125;, &#123;<span class="string">'M'</span>, <span class="number">1000</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( i &lt; s.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; tras[s[i]] &lt; tras[s[i + <span class="number">1</span>]] ) &#123;</span><br><span class="line">                res -= tras[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res += tras[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#136--只出现一次的数字</title>
    <url>/2020/03/16/leetcode136/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#136–只出现一次的数字</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：只出现一次的数字（简单）"><a href="#1-题目：只出现一次的数字（简单）" class="headerlink" title="1.题目：只出现一次的数字（简单）"></a>1.题目：只出现一次的数字（简单）</h3><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>输入: [2,2,1]<br>输出: 1</p>
<p>输入: [4,1,2,1,2]<br>输出: 4</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-使用集合"><a href="#1-使用集合" class="headerlink" title="(1)使用集合"></a>(1)使用集合</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; save;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> num : nums ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( save.<span class="built_in">find</span>(num) == save.<span class="built_in">end</span>() ) save.insert(num);</span><br><span class="line">            <span class="keyword">else</span> save.erase(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = *save.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-使用哈希表"><a href="#2-使用哈希表" class="headerlink" title="(2)使用哈希表"></a>(2)使用哈希表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; save;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> num : nums ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( save.<span class="built_in">find</span>(num) == save.<span class="built_in">end</span>() ) save.insert(&#123;num, <span class="literal">true</span>&#125;);</span><br><span class="line">            <span class="keyword">else</span> save[num] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> iter = save.<span class="built_in">begin</span>(); iter != save.<span class="built_in">end</span>(); ++iter ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( iter-&gt;second == <span class="literal">true</span> ) <span class="keyword">return</span> iter-&gt;first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-排序后双指针"><a href="#3-排序后双指针" class="headerlink" title="(3)排序后双指针"></a>(3)排序后双指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort( nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>() );</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); i += <span class="number">2</span>, j += <span class="number">2</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( nums[i] != nums[j] ) <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-异或"><a href="#4-异或" class="headerlink" title="(4)异或"></a>(4)异或</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> num : nums ) &#123;</span><br><span class="line">            res = res ^ num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#14--最长公共前缀</title>
    <url>/2020/02/23/leetcode14/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#14–最长公共前缀题解</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：最长公共前缀（简单）"><a href="#1-题目：最长公共前缀（简单）" class="headerlink" title="1.题目：最长公共前缀（简单）"></a>1.题目：最长公共前缀（简单）</h3><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”</p>
<p>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><p><strong>方法:</strong></p>
<p>首先，我们将描述一种查找一组字符串的最长公共前缀LCP(S1…Sn)的简单方法。<br>我们将会用到这样的结论：<br>LCP(S1…Sn) = LCP(LCP(LCP(S1, S2), S3),…Sn)</p>
<p>为了运用这种思想，算法要依次遍历字符串{S1…Sn}，当遍历到第i个字符串的时候找到最长公共前缀LCP(S1…Si)。当LCP(S1…Si)是一个空串的时候，算法就结束了。否则，在执行了n次遍历之后，算法就会返回最终答案LCP(S1…Sn)。</p>
<img src="/2020/02/23/leetcode14/leetcode14.png" class>

<p><strong>实现:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> r = strs.<span class="built_in">size</span>() ? strs[<span class="number">0</span>] : <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">string</span> s: strs ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( s.substr(<span class="number">0</span>, r.<span class="built_in">size</span>() ) != r ) &#123;</span><br><span class="line">                r = r.substr(<span class="number">0</span>, r.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> ( r == <span class="string">""</span> ) <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#141--环形链表</title>
    <url>/2020/03/16/leetcode141/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#141–环形链表</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：环形链表（简单）"><a href="#1-题目：环形链表（简单）" class="headerlink" title="1.题目：环形链表（简单）"></a>1.题目：环形链表（简单）</h3><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-使用集合"><a href="#1-使用集合" class="headerlink" title="(1)使用集合"></a>(1)使用集合</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;ListNode*&gt; save;</span><br><span class="line">        <span class="keyword">auto</span> ptr = head;</span><br><span class="line">        <span class="keyword">while</span> ( ptr != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( save.<span class="built_in">find</span>(ptr) != save.<span class="built_in">end</span>() ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            save.insert(ptr);</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-快慢指针"><a href="#2-快慢指针" class="headerlink" title="(2)快慢指针"></a>(2)快慢指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> fast = head;</span><br><span class="line">        <span class="keyword">auto</span> slow = head;</span><br><span class="line">        <span class="keyword">while</span> ( fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> ( fast == slow ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#155--最小栈</title>
    <url>/2020/03/17/leetcode155/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#155–最小栈</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：最小栈（简单）"><a href="#1-题目：最小栈（简单）" class="headerlink" title="1.题目：最小栈（简单）"></a>1.题目：最小栈（简单）</h3><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) – 将元素 x 推入栈中。<br>pop() – 删除栈顶的元素。<br>top() – 获取栈顶元素。<br>getMin() – 检索栈中的最小元素。</p>
<h3 id="2-题解-辅助栈"><a href="#2-题解-辅助栈" class="headerlink" title="2.题解(辅助栈)"></a>2.题解(辅助栈)</h3><h4 id="1-两栈同步"><a href="#1-两栈同步" class="headerlink" title="(1)两栈同步"></a>(1)两栈同步</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MinStack() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>.push_back(x);</span><br><span class="line">        <span class="keyword">if</span> ( minNums.empty() ) minNums.push_back(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( x &lt; minNums.back() ) minNums.push_back(x);</span><br><span class="line">        <span class="keyword">else</span> minNums.push_back(minNums.back());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">stack</span>.empty() ) &#123;</span><br><span class="line">            <span class="built_in">stack</span>.pop_back();</span><br><span class="line">            minNums.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minNums.back();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minNums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-两栈不同步"><a href="#2-两栈不同步" class="headerlink" title="(2)两栈不同步"></a>(2)两栈不同步</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MinStack() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>.push_back(x);</span><br><span class="line">        <span class="keyword">if</span> ( minNums.empty() ) minNums.push_back(x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( x &lt;= minNums.back() ) minNums.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">stack</span>.empty() ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">stack</span>.back() == minNums.back() ) minNums.pop_back();</span><br><span class="line">            <span class="built_in">stack</span>.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minNums.back();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minNums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#16--最接近的三数之和</title>
    <url>/2020/03/26/leetcode16/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#16–最接近的三数之和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：最接近的三数之和（中等）"><a href="#1-题目：最接近的三数之和（中等）" class="headerlink" title="1.题目：最接近的三数之和（中等）"></a>1.题目：最接近的三数之和（中等）</h3><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</p>
<p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p>
</blockquote>
<h3 id="2-题解-双指针"><a href="#2-题解-双指针" class="headerlink" title="2.题解(双指针)"></a>2.题解(双指针)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.<span class="built_in">size</span>() &lt; <span class="number">3</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, minDiff = INT32_MAX;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; ++i ) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">size_t</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ( left &lt; right ) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> ( sum == target ) <span class="keyword">return</span> sum;</span><br><span class="line">                <span class="keyword">if</span> ( sum &gt; target ) &#123;</span><br><span class="line">                    diff = sum - target;</span><br><span class="line">                    --right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( sum &lt; target ) &#123;</span><br><span class="line">                    diff = target - sum;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( diff &lt; minDiff ) &#123;</span><br><span class="line">                    minDiff = diff;</span><br><span class="line">                    res = sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#15--三数之和</title>
    <url>/2020/03/24/leetcode15/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#15–三数之和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：三数之和（中等）"><a href="#1-题目：三数之和（中等）" class="headerlink" title="1.题目：三数之和（中等）"></a>1.题目：三数之和（中等）</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：<br>[ [-1, 0, 1],<br>[-1, -1, 2] ]</p>
</blockquote>
<h3 id="2-题解-双指针"><a href="#2-题解-双指针" class="headerlink" title="2.题解(双指针)"></a>2.题解(双指针)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> ( nums.<span class="built_in">size</span>() &lt; <span class="number">3</span> ) <span class="keyword">return</span> ans;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>( nums[<span class="number">0</span>] &gt; <span class="number">0</span> ) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( i &lt; nums.<span class="built_in">size</span>() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ( left &lt; right ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( nums[i] &gt; <span class="number">0</span> ) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 转换为long long避免加法过程中溢出</span></span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> y = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(nums[i]);</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(nums[left]);</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> z = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(nums[right]);</span><br><span class="line">                <span class="keyword">if</span> ( x + y &gt; <span class="number">0</span> - z )</span><br><span class="line">                    right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( x + y &lt; <span class="number">0</span> - z )</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.push_back(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 相同的left和right不应该再次出现，因此跳过</span></span><br><span class="line">                    <span class="keyword">while</span> ( left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>] ) left++;</span><br><span class="line">                    <span class="keyword">while</span> ( left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>] ) right--;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 避免nums[i]作为第一个数重复出现</span></span><br><span class="line">            <span class="keyword">while</span> ( i + <span class="number">1</span> &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[i] == nums[i + <span class="number">1</span>] ) i++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#167--两数之和 II - 输入有序数组</title>
    <url>/2020/03/17/leetcode167/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#167–两数之和 II - 输入有序数组</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：两数之和-II-输入有序数组（简单）"><a href="#1-题目：两数之和-II-输入有序数组（简单）" class="headerlink" title="1.题目：两数之和 II - 输入有序数组（简单）"></a>1.题目：两数之和 II - 输入有序数组（简单）</h3><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<p>说明:</p>
<p>返回的下标值（index1 和 index2）不是从零开始的。<br>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p>
<h3 id="2-题解-双指针法"><a href="#2-题解-双指针法" class="headerlink" title="2.题解(双指针法)"></a>2.题解(双指针法)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( i &lt; j ) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[i] + numbers[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; target) ++i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) --j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> &#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#168--excel表列名称</title>
    <url>/2020/03/18/leetcode168/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#168–excel表列名称</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：excel表列名称"><a href="#1-题目：excel表列名称" class="headerlink" title="1.题目：excel表列名称"></a>1.题目：excel表列名称</h3><p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>1 -&gt; A<br>2 -&gt; B<br>3 -&gt; C<br>…<br>26 -&gt; Z<br>27 -&gt; AA<br>28 -&gt; AB<br>…</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span> ( n &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            res.push_back(<span class="string">'A'</span> + (n - <span class="number">1</span>) % <span class="number">26</span>);</span><br><span class="line">            n = (n - <span class="number">1</span>) / <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#160--相交链表</title>
    <url>/2020/03/17/leetcode160/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#160–相交链表</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：相交链表（简单）"><a href="#1-题目：相交链表（简单）" class="headerlink" title="1.题目：相交链表（简单）"></a>1.题目：相交链表（简单）</h3><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> ptrA = headA, ptrB = headB;</span><br><span class="line">        <span class="keyword">while</span> ( ptrA != ptrB ) &#123;</span><br><span class="line">            ptrA = ( ptrA == <span class="literal">nullptr</span> ) ? headB : ptrA-&gt;next;</span><br><span class="line">            ptrB = ( ptrB == <span class="literal">nullptr</span> ) ? headA : ptrB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptrA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#169--多数元素</title>
    <url>/2020/03/18/leetcode169/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#169–多数元素</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：多数元素"><a href="#1-题目：多数元素" class="headerlink" title="1.题目：多数元素"></a>1.题目：多数元素</h3><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="(1)哈希表"></a>(1)哈希表</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; helper;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> num : nums ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( helper.<span class="built_in">find</span>(num) == helper.<span class="built_in">end</span>() ) helper.insert(&#123;num, <span class="number">1</span>&#125;);</span><br><span class="line">            <span class="keyword">else</span> ++helper[num];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> iter = helper.<span class="built_in">begin</span>(); iter != helper.<span class="built_in">end</span>(); ++iter ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( iter-&gt;second &gt; nums.<span class="built_in">size</span>() / <span class="number">2</span> ) <span class="keyword">return</span> iter-&gt;first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-投票法"><a href="#2-投票法" class="headerlink" title="(2)投票法"></a>(2)投票法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> candidate = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> num : nums ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( num == candidate )</span><br><span class="line">                ++count;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( --count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#17--电话号码的字母组合</title>
    <url>/2020/03/26/leetcode17/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#17–电话号码的字母组合</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：电话号码的字母组合（中等）"><a href="#1-题目：电话号码的字母组合（中等）" class="headerlink" title="1.题目：电话号码的字母组合（中等）"></a>1.题目：电话号码的字母组合（中等）</h3><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
</blockquote>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( digits.empty() ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">string</span> path; <span class="comment">//路径</span></span><br><span class="line">        backtrack(digits, res, path, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; key&#123;&#123;<span class="string">'2'</span>, <span class="string">"abc"</span>&#125;, &#123;<span class="string">'3'</span>, <span class="string">"def"</span>&#125;, &#123;<span class="string">'4'</span>, <span class="string">"ghi"</span>&#125;, &#123;<span class="string">'5'</span>, <span class="string">"jkl"</span>&#125;,</span><br><span class="line">                          &#123;<span class="string">'6'</span>, <span class="string">"mno"</span>&#125;, &#123;<span class="string">'7'</span>, <span class="string">"pqrs"</span>&#125;, &#123;<span class="string">'8'</span>, <span class="string">"tuv"</span>&#125;, &#123;<span class="string">'9'</span>, <span class="string">"wxyz"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; digits, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">string</span>&amp; path, <span class="keyword">size_t</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        <span class="keyword">if</span> ( index == digits.<span class="built_in">size</span>() ) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选择列表</span></span><br><span class="line">        <span class="built_in">string</span> alpha = key[digits[index]];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; alpha.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            path.push_back(alpha[i]); <span class="comment">// 做选择</span></span><br><span class="line">            backtrack(digits, res, path, index + <span class="number">1</span>);</span><br><span class="line">            path.pop_back(); <span class="comment">// 撤销选择</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#171--excel表列序号</title>
    <url>/2020/03/19/leetcode171/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#171–excel表列序号</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：excel表列序号（简单）"><a href="#1-题目：excel表列序号（简单）" class="headerlink" title="1.题目：excel表列序号（简单）"></a>1.题目：excel表列序号（简单）</h3><p>给定一个Excel表格中的列名称，返回其相应的列序号。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>A -&gt; 1<br>B -&gt; 2<br>C -&gt; 3<br>…<br>Z -&gt; 26<br>AA -&gt; 27<br>AB -&gt; 28<br>…</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">char</span> c : s ) &#123;</span><br><span class="line">            res = res * <span class="number">26</span> + (c - <span class="string">'A'</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#172--阶乘后的0</title>
    <url>/2020/03/19/leetcode172/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#172–阶乘后的0</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：阶乘后的0（简单）"><a href="#1-题目：阶乘后的0（简单）" class="headerlink" title="1.题目：阶乘后的0（简单）"></a>1.题目：阶乘后的0（简单）</h3><p>给定一个整数 n，返回 n! 结果尾数中零的数量。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count += n / <span class="number">5</span>;</span><br><span class="line">            n = n / <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#18--四数之和</title>
    <url>/2020/03/27/leetcode18/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#18–四数之和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：四数之和（中等）"><a href="#1-题目：四数之和（中等）" class="headerlink" title="1.题目：四数之和（中等）"></a>1.题目：四数之和（中等）</h3><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p>注意：</p>
<p>答案中不可以包含重复的四元组。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</p>
<p>满足要求的四元组集合为：<br>[<br>[-1,  0, 0, 1],<br>[-2, -1, 1, 2],<br>[-2,  0, 0, 2]<br>]</p>
</blockquote>
<h3 id="2-题解-双指针"><a href="#2-题解-双指针" class="headerlink" title="2.题解(双指针)"></a>2.题解(双指针)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> ( nums.<span class="built_in">size</span>() &lt; <span class="number">4</span> ) <span class="keyword">return</span> res;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> first = <span class="number">0</span>; first &lt; nums.<span class="built_in">size</span>() - <span class="number">3</span>; ++first ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> second = first + <span class="number">1</span>; second &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; ++second ) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = second + <span class="number">1</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> ( i &lt; j ) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[first] + nums[second] + nums[i] + nums[j];</span><br><span class="line">                    <span class="keyword">if</span> ( sum &gt; target ) --j;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ( sum &lt; target ) ++i;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.push_back(&#123;nums[first], nums[second], nums[i], nums[j]&#125;);</span><br><span class="line">                        <span class="keyword">while</span> ( i &lt; j &amp;&amp; nums[i] == nums[i + <span class="number">1</span>] ) ++i;</span><br><span class="line">                        <span class="keyword">while</span> ( i &lt; j &amp;&amp; nums[j] == nums[j - <span class="number">1</span>] ) --j;</span><br><span class="line">                        ++i, --j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> ( second &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span> &amp;&amp; nums[second] == nums[second + <span class="number">1</span>] ) ++second;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ( first &lt; nums.<span class="built_in">size</span>() - <span class="number">3</span> &amp;&amp; nums[first] == nums[first + <span class="number">1</span>] ) ++first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#19--删除链表的倒数第N个节点</title>
    <url>/2020/03/27/leetcode19/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#19–删除链表的倒数第N个节点</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：删除链表的倒数第N个节点（中等）"><a href="#1-题目：删除链表的倒数第N个节点（中等）" class="headerlink" title="1.题目：删除链表的倒数第N个节点（中等）"></a>1.题目：删除链表的倒数第N个节点（中等）</h3><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p>
<p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p>
</blockquote>
<h3 id="2-题解-双指针"><a href="#2-题解-双指针" class="headerlink" title="2.题解(双指针)"></a>2.题解(双指针)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* look = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        look-&gt;next = head;</span><br><span class="line">        ListNode* left = look;</span><br><span class="line">        ListNode* right = look;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; ++i ) &#123;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( right != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            left = left-&gt;next;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        left-&gt;next = left-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> look-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#2--两数相加</title>
    <url>/2020/03/20/leetcode2/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#2–两数相加</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：两数相加（中等）"><a href="#1-题目：两数相加（中等）" class="headerlink" title="1.题目：两数相加（中等）"></a>1.题目：两数相加（中等）</h3><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
</blockquote>
<h3 id="2-题解-链表"><a href="#2-题解-链表" class="headerlink" title="2.题解(链表)"></a>2.题解(链表)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* ptr = head;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( l1 != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                temp += l1-&gt;val;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( l2 != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                temp += l2-&gt;val;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr-&gt;next = <span class="keyword">new</span> ListNode(temp % <span class="number">10</span>);</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">            temp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( temp == <span class="number">1</span> ) &#123;</span><br><span class="line">            ptr-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#20--有效的括号</title>
    <url>/2020/02/23/leetcode20/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#20–有效的括号题解</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：有效的括号（简单）"><a href="#1-题目：有效的括号（简单）" class="headerlink" title="1.题目：有效的括号（简单）"></a>1.题目：有效的括号（简单）</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: “()”<br>输出: true</p>
<p>输入: “()[]{}”<br>输出: true</p>
<p>输入: “(]”<br>输出: false</p>
<p>输入: “([)]”<br>输出: false</p>
<p>输入: “{[]}”<br>输出: true</p>
</blockquote>
<h3 id="2-题解-栈"><a href="#2-题解-栈" class="headerlink" title="2.题解(栈)"></a>2.题解(栈)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( s == <span class="string">""</span> ) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//s为空串</span></span><br><span class="line">        <span class="keyword">if</span> ( s.length() % <span class="number">2</span> != <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//s长度为奇数</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; ss;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> i : s ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( i == <span class="string">'&#123;'</span> || i == <span class="string">'('</span> || i == <span class="string">'['</span> ) ss.push(i);  <span class="comment">//左括号则压栈</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( ss.<span class="built_in">size</span>() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//无匹配的括号</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( (i == <span class="string">'&#125;'</span> &amp;&amp; ss.top() != <span class="string">'&#123;'</span>) ||</span><br><span class="line">                          (i == <span class="string">']'</span> &amp;&amp; ss.top() != <span class="string">'['</span>) ||</span><br><span class="line">                          (i == <span class="string">')'</span> &amp;&amp; ss.top() != <span class="string">'('</span>) ) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//匹配错误</span></span><br><span class="line">                <span class="keyword">else</span> ss.pop();  <span class="comment">//匹配成功，出栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( ss.<span class="built_in">size</span>() != <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//最后栈非空则错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>重点:</strong></p>
<p>栈的使用</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#21--合并两个有序链表</title>
    <url>/2020/02/23/leetcode21/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#21–合并两个有序链表题解</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：合并两个有序链表（简单）"><a href="#1-题目：合并两个有序链表（简单）" class="headerlink" title="1.题目：合并两个有序链表（简单）"></a>1.题目：合并两个有序链表（简单）</h3><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* first = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* ptr = first;</span><br><span class="line">        <span class="keyword">while</span> ( l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( l1-&gt;val &lt; l2-&gt;val ) &#123;</span><br><span class="line">                ptr-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ptr-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr-&gt;next = l1 == <span class="literal">nullptr</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#22--括号生成</title>
    <url>/2020/03/28/leetcode22/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#22–括号生成</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：括号生成（中等）"><a href="#1-题目：括号生成（中等）" class="headerlink" title="1.题目：括号生成（中等）"></a>1.题目：括号生成（中等）</h3><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p><strong>示例:</strong></p>
<p>例如，给出 n = 3，生成结果为：</p>
<p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( n == <span class="number">0</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">string</span> path; <span class="comment">// 路径</span></span><br><span class="line">        backtrack(n, n, res, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res, <span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        <span class="keyword">if</span> ( left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span> ) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选择列表：'(' and ')'</span></span><br><span class="line">        <span class="keyword">if</span> ( left &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            path.push_back(<span class="string">'('</span>);</span><br><span class="line">            backtrack(left - <span class="number">1</span>, right, res, path);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( right &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( left == right ) <span class="keyword">return</span>; <span class="comment">// 剪枝</span></span><br><span class="line">            path.push_back(<span class="string">')'</span>);</span><br><span class="line">            backtrack(left, right - <span class="number">1</span>, res, path);</span><br><span class="line">            path.pop_back(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#24--两两交换链表中的节点</title>
    <url>/2020/03/28/leetcode24/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#24–两两交换链表中的节点</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：两两交换链表中的节点（中等）"><a href="#1-题目：两两交换链表中的节点（中等）" class="headerlink" title="1.题目：两两交换链表中的节点（中等）"></a>1.题目：两两交换链表中的节点（中等）</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><strong>示例:</strong></p>
<p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( head == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* sentry = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        sentry-&gt;next = head;</span><br><span class="line">        ListNode* ptr = sentry;</span><br><span class="line">        <span class="keyword">while</span> ( ptr-&gt;next != <span class="literal">nullptr</span> &amp;&amp; ptr-&gt;next-&gt;next != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            ListNode* temp = ptr-&gt;next;</span><br><span class="line">            ptr-&gt;next = ptr-&gt;next-&gt;next;</span><br><span class="line">            temp-&gt;next = ptr-&gt;next-&gt;next;</span><br><span class="line">            ptr-&gt;next-&gt;next = temp;</span><br><span class="line">            ptr = ptr-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sentry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#29--两数相除</title>
    <url>/2020/03/29/leetcode29/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#29–两数相除</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：两数相除（中等）"><a href="#1-题目：两数相除（中等）" class="headerlink" title="1.题目：两数相除（中等）"></a>1.题目：两数相除（中等）</h3><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数 dividend 除以除数 divisor 得到的商。</p>
<p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: dividend = 10, divisor = 3<br>输出: 3<br>解释: 10/3 = truncate(3.33333..) = truncate(3) = 3</p>
</blockquote>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( dividend == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( divisor == <span class="number">1</span> ) <span class="keyword">return</span> dividend;</span><br><span class="line">        <span class="keyword">if</span> ( divisor == <span class="number">-1</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( dividend &gt; INT_MIN ) <span class="keyword">return</span> -dividend;  <span class="comment">// 只要不是最小的那个整数，都是直接返回相反数就好啦</span></span><br><span class="line">            <span class="keyword">return</span> INT_MAX;  <span class="comment">// 是最小的那个，那就返回最大的整数啦</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> a = dividend;</span><br><span class="line">        <span class="keyword">long</span> b = divisor;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> ( (a&gt;<span class="number">0</span> &amp;&amp; b&lt;<span class="number">0</span>) || (a&lt;<span class="number">0</span> &amp;&amp; b&gt;<span class="number">0</span>) ) sign = <span class="number">-1</span>;</span><br><span class="line">        a = a &gt; <span class="number">0</span> ? a : -a;</span><br><span class="line">        b = b &gt; <span class="number">0</span> ? b : -b;</span><br><span class="line">        <span class="keyword">long</span> res = div(a, b);</span><br><span class="line">        <span class="keyword">if</span> ( sign &gt; <span class="number">0</span> ) <span class="keyword">return</span> res &gt; INT_MAX ? INT_MAX : res;</span><br><span class="line">        <span class="keyword">return</span> -res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span> </span>&#123;  <span class="comment">// 似乎精髓和难点就在于下面这几句</span></span><br><span class="line">        <span class="keyword">if</span> ( a &lt; b ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> tb = b; <span class="comment">// 在后面的代码中不更新b</span></span><br><span class="line">        <span class="keyword">while</span> ( tb + tb &lt;= a ) &#123;</span><br><span class="line">            count = count + count; <span class="comment">// 最小解翻倍</span></span><br><span class="line">            tb = tb + tb; <span class="comment">// 当前测试的值也翻倍</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count + div(a - tb, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#26--删除排序数组中的重复项</title>
    <url>/2020/02/27/leetcode26/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#26–删除排序数组中的重复项</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：删除排序数组中的重复项（简单）"><a href="#1-题目：删除排序数组中的重复项（简单）" class="headerlink" title="1.题目：删除排序数组中的重复项（简单）"></a>1.题目：删除排序数组中的重复项（简单）</h3><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定数组 nums = [1,1,2],<br>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>
<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-删除元素法-不好"><a href="#1-删除元素法-不好" class="headerlink" title="(1)删除元素法(不好)"></a>(1)删除元素法(不好)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.<span class="built_in">size</span>() == <span class="number">0</span> )  <span class="comment">//处理边界情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> iter = nums.<span class="built_in">begin</span>() + <span class="number">1</span>; iter != nums.<span class="built_in">end</span>(); ++iter )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( *iter == *(iter - <span class="number">1</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                nums.erase(iter);  <span class="comment">//将该元素删除</span></span><br><span class="line">                --iter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行用时：352ms</p>
<p>vector将元素保存在<strong>连续</strong>的内存空间中，所以在vector的中间位置进行插入和删除元素将非常耗时：<br>在一次插入或删除操作后，需要移动插入/删除位置之后的所有元素，来保持连续存储。<br>因此双指针法是更好的选择。由于C++不推荐使用指针，所以用迭代器来代替指针。</p>
<h4 id="2-双指针法"><a href="#2-双指针法" class="headerlink" title="(2)双指针法"></a>(2)双指针法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先处理特殊情况，否则会产生执行错误</span></span><br><span class="line">        <span class="keyword">if</span> ( nums.<span class="built_in">size</span>() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//所给数组为空</span></span><br><span class="line">        <span class="keyword">auto</span> itr1 = nums.<span class="built_in">begin</span>() ;  <span class="comment">//指针1指向第一个元素</span></span><br><span class="line">        <span class="keyword">auto</span> itr2 = nums.<span class="built_in">begin</span>() + <span class="number">1</span>;  <span class="comment">//指针2指向第二个元素</span></span><br><span class="line">        <span class="keyword">for</span> ( ; itr2 != nums.<span class="built_in">end</span>(); ++itr2 ) &#123;  <span class="comment">//遍历数组</span></span><br><span class="line">            <span class="keyword">if</span> ( *itr2 != * itr1 ) &#123;  <span class="comment">//发现和指针1不相同的数</span></span><br><span class="line">                itr1 += <span class="number">1</span>;  <span class="comment">//指针1向后移动一个元素</span></span><br><span class="line">                *itr1 = *itr2;  <span class="comment">//修改指针1的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> itr1 - nums.<span class="built_in">begin</span>() + <span class="number">1</span>;  <span class="comment">//返回数组长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行用时：28ms</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#27--移除元素</title>
    <url>/2020/02/27/leetcode27/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#27–移除元素</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：移除元素（简单）"><a href="#1-题目：移除元素（简单）" class="headerlink" title="1.题目：移除元素（简单）"></a>1.题目：移除元素（简单）</h3><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定 nums = [3,2,2,3], val = 3,<br>函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。<br>你不需要考虑数组中超出新长度后面的元素。</p>
<p>给定 nums = [0,1,2,2,3,0,4,2], val = 2,<br>函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。<br>注意这五个元素可为任意顺序。<br>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.<span class="built_in">size</span>() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> beg = nums.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">auto</span> bac = nums.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( beg != bac ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( *beg == val ) &#123;</span><br><span class="line">                swap(*beg, *bac);</span><br><span class="line">                --bac;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ++beg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( *beg == val ) --beg;</span><br><span class="line">        <span class="keyword">return</span> beg - nums.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>改进：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.<span class="built_in">size</span>() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> beg = nums.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">auto</span> bac = nums.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( beg &lt;= bac ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( *beg == val ) &#123;</span><br><span class="line">                swap(*beg, *bac);</span><br><span class="line">                --bac;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ++beg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bac - nums.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#3--无重复字符的最长子串</title>
    <url>/2020/03/20/leetcode3/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#3–无重复字符的最长子串</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：无重复字符的最长子串（中等）"><a href="#1-题目：无重复字符的最长子串（中等）" class="headerlink" title="1.题目：无重复字符的最长子串（中等）"></a>1.题目：无重复字符的最长子串（中等）</h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串的长度</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
</blockquote>
<h3 id="2-题解-滑动窗口"><a href="#2-题解-滑动窗口" class="headerlink" title="2.题解(滑动窗口)"></a>2.题解(滑动窗口)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( s.<span class="built_in">size</span>() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; lookup;</span><br><span class="line">        <span class="keyword">int</span> maxStr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i )&#123;</span><br><span class="line">            <span class="keyword">while</span> ( lookup.<span class="built_in">find</span>(s[i]) != lookup.<span class="built_in">end</span>() )&#123;</span><br><span class="line">                lookup.erase(s[left]);</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            maxStr = <span class="built_in">max</span>(maxStr, i - left + <span class="number">1</span>);</span><br><span class="line">            lookup.insert(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#31--下一个排列</title>
    <url>/2020/03/29/leetcode31/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#31–下一个排列</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：下一个排列（中等）"><a href="#1-题目：下一个排列（中等）" class="headerlink" title="1.题目：下一个排列（中等）"></a>1.题目：下一个排列（中等）</h3><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须原地修改，只允许使用额外常数空间。</p>
<p><strong>示例:</strong></p>
<p>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> left = nums.<span class="built_in">end</span>();</span><br><span class="line">        --left;</span><br><span class="line">        <span class="keyword">while</span> ( left != nums.<span class="built_in">begin</span>() &amp;&amp; *left &lt;= *(left - <span class="number">1</span>) ) --left;</span><br><span class="line">        <span class="keyword">if</span> ( left == nums.<span class="built_in">begin</span>() ) sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> right = left + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ( right != nums.<span class="built_in">end</span>() &amp;&amp; *right &gt; *(left - <span class="number">1</span>) ) ++right;</span><br><span class="line">            swap(*(left - <span class="number">1</span>), *(right - <span class="number">1</span>));</span><br><span class="line">            sort(left, nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#33--搜索旋转排序数组</title>
    <url>/2020/03/31/leetcode33/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#33–搜索旋转排序数组</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：搜索旋转排序数组（中等）"><a href="#1-题目：搜索旋转排序数组（中等）" class="headerlink" title="1.题目：搜索旋转排序数组（中等）"></a>1.题目：搜索旋转排序数组（中等）</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p><strong>示例:</strong></p>
<p>输入: nums = [4,5,6,7,0,1,2], target = 0<br>输出: 4</p>
<h3 id="2-题解-二分法"><a href="#2-题解-二分法" class="headerlink" title="2.题解(二分法)"></a>2.题解(二分法)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.empty() ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//闭区间</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( left &lt;= right ) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//若找到了</span></span><br><span class="line">            <span class="keyword">if</span> ( nums[mid] == target ) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">//若左面有序</span></span><br><span class="line">            <span class="keyword">if</span> ( nums[left] &lt;= nums[mid] ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( nums[left] &lt;= target &amp;&amp; target &lt; nums[mid] ) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若右面有序</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( nums[mid] &lt; target &amp;&amp; target &lt;= nums[right] ) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#34--在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2020/03/31/leetcode34/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#34–在排序数组中查找元素的第一个和最后一个位置</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：在排序数组中查找元素的第一个和最后一个位置（中等）"><a href="#1-题目：在排序数组中查找元素的第一个和最后一个位置（中等）" class="headerlink" title="1.题目：在排序数组中查找元素的第一个和最后一个位置（中等）"></a>1.题目：在排序数组中查找元素的第一个和最后一个位置（中等）</h3><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<p><strong>示例:</strong></p>
<p>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: [3,4]</p>
<h3 id="2-题解-二分法"><a href="#2-题解-二分法" class="headerlink" title="2.题解(二分法)"></a>2.题解(二分法)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty() ) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;searchLeftBound(nums, target), searchRightBound(nums, target)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchLeftBound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> ( left &lt; right ) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ( nums[mid] == target ) right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( nums[mid] &gt; target ) right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( nums[mid] &lt; target ) left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( left &gt; nums.<span class="built_in">size</span>() - <span class="number">1</span> || nums[left] != target ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchRightBound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> ( left &lt; right ) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ( nums[mid] == target ) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( nums[mid] &gt; target ) right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( nums[mid] &lt; target ) left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( left == <span class="number">0</span> || nums[left - <span class="number">1</span>] != target ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#28--实现strStr()</title>
    <url>/2020/02/27/leetcode28/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#28–实现strStr()</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：实现strStr-（简单）"><a href="#1-题目：实现strStr-（简单）" class="headerlink" title="1.题目：实现strStr()（简单）"></a>1.题目：实现strStr()（简单）</h3><p>实现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: haystack = “hello”, needle = “ll”<br>输出: 2</p>
<p>输入: haystack = “aaaaa”, needle = “bba”<br>输出: -1</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-标准库法"><a href="#1-标准库法" class="headerlink" title="(1)标准库法"></a>(1)标准库法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( needle.empty() ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = haystack.<span class="built_in">find</span>(needle);</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用string的成员函数find()</p>
<h4 id="2-双指针法"><a href="#2-双指针法" class="headerlink" title="(2)双指针法"></a>(2)双指针法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( needle.empty() ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( haystack[i] != <span class="string">'\0'</span> &amp;&amp; needle[j] != <span class="string">'\0'</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( haystack[i] == needle[j] ) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                i = i - j + <span class="number">1</span>;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( needle[j] == <span class="string">'\0'</span> ) <span class="keyword">return</span> i - j;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#35--搜索插入位置</title>
    <url>/2020/02/28/leetcode35/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#35–搜索插入位置</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：搜索插入位置（简单）"><a href="#1-题目：搜索插入位置（简单）" class="headerlink" title="1.题目：搜索插入位置（简单）"></a>1.题目：搜索插入位置（简单）</h3><p>实现 strStr() 函数。<br>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: [1,3,5,6], 5<br>输出: 2</p>
<p>输入: [1,3,5,6], 2<br>输出: 1</p>
<p>输入: [1,3,5,6], 7<br>输出: 4</p>
<p>输入: [1,3,5,6], 0<br>输出: 0</p>
</blockquote>
<h3 id="2-题解-二分法"><a href="#2-题解-二分法" class="headerlink" title="2.题解(二分法)"></a>2.题解(二分法)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( left &lt;= right ) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ( target == nums[mid] ) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( target &lt; nums[mid] ) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( nums[mid] &lt; target ) left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#36--有效的数独</title>
    <url>/2020/04/08/leetcode36/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#36–有效的数独</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：有效的数独（中等）"><a href="#1-题目：有效的数独（中等）" class="headerlink" title="1.题目：有效的数独（中等）"></a>1.题目：有效的数独（中等）</h3><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>
<p><strong>示例:</strong></p>
<p>输入:<br>[<br>  [“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],<br>  [“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],<br>  [“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],<br>  [“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],<br>  [“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],<br>  [“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],<br>  [“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],<br>  [“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],<br>  [“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]<br>]<br>输出: true</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 整个board有9行，第二维的维数10是为了让下标有9，和数独中的数字9对应。</span></span><br><span class="line">        <span class="keyword">int</span> row[<span class="number">9</span>][<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 哈希表存储每一行的每个数是否出现过，默认初始情况下，每一行每一个数都没有出现过</span></span><br><span class="line">        <span class="keyword">int</span> col[<span class="number">9</span>][<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 存储每一列的每个数是否出现过，默认初始情况下，每一列的每一个数都没有出现过</span></span><br><span class="line">        <span class="keyword">int</span> box[<span class="number">9</span>][<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 存储每一个box的每个数是否出现过，默认初始情况下，在每个box中，每个数都没有出现过。整个board有9个box。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 遍历到第i行第j列的那个数,我们要判断这个数在其所在的行有没有出现过，</span></span><br><span class="line">                <span class="comment">// 同时判断这个数在其所在的列有没有出现过</span></span><br><span class="line">                <span class="comment">// 同时判断这个数在其所在的box中有没有出现过</span></span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> curNumber = board[i][j] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span> (row[i][curNumber]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (col[j][curNumber]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (box[j / <span class="number">3</span> + (i / <span class="number">3</span>) * <span class="number">3</span>][curNumber]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 之前都没出现过，现在出现了，就给它置为1，下次再遇见就能够直接返回false了。</span></span><br><span class="line">                row[i][curNumber] = <span class="number">1</span>;</span><br><span class="line">                col[j][curNumber] = <span class="number">1</span>;</span><br><span class="line">                box[j / <span class="number">3</span> + (i / <span class="number">3</span>) * <span class="number">3</span>][curNumber] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#38--外观数列</title>
    <url>/2020/02/28/leetcode38/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#38–外观数列</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：外观数列（简单）"><a href="#1-题目：外观数列（简单）" class="headerlink" title="1.题目：外观数列（简单）"></a>1.题目：外观数列（简单）</h3><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p>
<ol>
<li>1</li>
<li>11</li>
<li>21</li>
<li>1211</li>
<li>111221</li>
</ol>
<p>1 被读作  “one 1”  (“一个一”) , 即 11。<br>11 被读作 “two 1s” (“两个一”）, 即 21。<br>21 被读作 “one 2”,  “one 1” （”一个二” ,  “一个一”) , 即 1211。</p>
<p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。</p>
<p>注意：整数序列中的每一项将表示为一个字符串。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 1<br>输出: “1”<br>解释：这是一个基本样例。</p>
<p>输入: 4<br>输出: “1211”<br>解释：当 n = 3 时，序列是 “21”，其中我们有 “2” 和 “1” 两组，”2” 可以读作 “12”，也就是出现频次 = 1 而 值 = 2；类似 “1” 可以读作 “11”。所以答案是 “12” 和 “11” 组合在一起，也就是 “1211”。</p>
</blockquote>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( n == <span class="number">1</span> ) <span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="built_in">string</span> last = countAndSay(n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; last.<span class="built_in">size</span>(); ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( last[i] == last[i + <span class="number">1</span>] ) ++count;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// res.push_back(count + '0');</span></span><br><span class="line">                <span class="comment">// res.push_back(last[i]);</span></span><br><span class="line">                res += to_string(count) + last[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#39--组合总和</title>
    <url>/2020/04/09/leetcode39/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#39–组合总和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：组合总和（中等）"><a href="#1-题目：组合总和（中等）" class="headerlink" title="1.题目：组合总和（中等）"></a>1.题目：组合总和（中等）</h3><p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<p>说明：</p>
<p>所有数字（包括 target）都是正整数。<br>解集不能包含重复的组合。</p>
<p><strong>示例:</strong></p>
<p>输入: candidates = [2,3,5], target = 8,<br>所求解集为:<br>[<br>  [2,2,2,2],<br>  [2,3,3],<br>  [3,5]<br>]</p>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( candidates.empty() ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 路径</span></span><br><span class="line">        sort(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        backtrack(candidates, target, res, path, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        <span class="keyword">if</span> ( target == <span class="number">0</span> ) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可选列表</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = start; i &lt; candidates.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( candidates[i] &gt; target ) <span class="keyword">continue</span>; <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="comment">// 操作</span></span><br><span class="line">            path.push_back(candidates[i]);</span><br><span class="line">            backtrack(candidates, target - candidates[i], res, path, i);</span><br><span class="line">            <span class="comment">// 撤销操作</span></span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#40--组合总和2</title>
    <url>/2020/04/09/leetcode40/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#40–组合总和2</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：组合总和（中等）"><a href="#1-题目：组合总和（中等）" class="headerlink" title="1.题目：组合总和（中等）"></a>1.题目：组合总和（中等）</h3><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>说明：</p>
<p>所有数字（包括目标数）都是正整数。<br>解集不能包含重复的组合。</p>
<p><strong>示例:</strong></p>
<p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>所求解集为:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]</p>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( candidates.empty() ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 路径</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(candidates.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        sort(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        backtrack(candidates, target, res, path, <span class="number">0</span>, visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        <span class="keyword">if</span> ( target == <span class="number">0</span> ) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可选列表</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = start; i &lt; candidates.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( candidates[i] &gt; target ) <span class="keyword">continue</span>; <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="keyword">if</span> ( i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; visited[i - <span class="number">1</span>] == <span class="literal">false</span>) <span class="keyword">continue</span>; <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="comment">// 操作</span></span><br><span class="line">            path.push_back(candidates[i]);</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            backtrack(candidates, target - candidates[i], res, path, i + <span class="number">1</span>, visited);</span><br><span class="line">            <span class="comment">// 撤销操作</span></span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#43--字符串相乘</title>
    <url>/2020/04/09/leetcode43/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#43–字符串相乘</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：字符串相乘（中等）"><a href="#1-题目：字符串相乘（中等）" class="headerlink" title="1.题目：字符串相乘（中等）"></a>1.题目：字符串相乘（中等）</h3><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</p>
<p><strong>示例:</strong></p>
<p>输入: num1 = “123”, num2 = “456”<br>输出: “56088”</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">if</span> ( num1 == <span class="string">"0"</span> || num2 == <span class="string">"0"</span> ) <span class="keyword">return</span> res;</span><br><span class="line">        reverse(num2.<span class="built_in">begin</span>(), num2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num2.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="built_in">string</span> temp = mul(num1, num2[i]);</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j ) temp.push_back(<span class="string">'0'</span>);</span><br><span class="line">            res = add(res, temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">mul</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> x = c - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = num.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i ) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = num[i] - <span class="string">'0'</span>;</span><br><span class="line">            temp += x * y;</span><br><span class="line">            res.push_back(temp % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">            temp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( temp != <span class="number">0</span> ) res.push_back(temp + <span class="string">'0'</span>);</span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = num1.<span class="built_in">size</span>() - <span class="number">1</span>, j = num2.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>; --i, --j ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( i &gt;= <span class="number">0</span> ) temp += num1[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> ( j &gt;= <span class="number">0</span> ) temp += num2[j] - <span class="string">'0'</span>;</span><br><span class="line">            res.push_back(temp % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">            temp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( temp != <span class="number">0</span> ) res.push_back(temp + <span class="string">'0'</span>);</span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#46--全排列</title>
    <url>/2020/04/10/leetcode46/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#46–全排列</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：全排列（中等）"><a href="#1-题目：全排列（中等）" class="headerlink" title="1.题目：全排列（中等）"></a>1.题目：全排列（中等）</h3><p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<p><strong>示例:</strong></p>
<p>输入: [1,2,3]<br>输出:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.empty() ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 路径</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(nums.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        backtrack(nums, res, path, visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        <span class="keyword">if</span> ( path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>() ) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可选列表</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( visited[i] == <span class="literal">true</span> ) <span class="keyword">continue</span>; <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="comment">// 操作</span></span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            backtrack(nums, res, path, visited);</span><br><span class="line">            <span class="comment">// 撤销操作</span></span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#47--全排列2</title>
    <url>/2020/04/10/leetcode47/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#47–全排列2</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：全排列2（中等）"><a href="#1-题目：全排列2（中等）" class="headerlink" title="1.题目：全排列2（中等）"></a>1.题目：全排列2（中等）</h3><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p><strong>示例:</strong></p>
<p>输入: [1,1,2]<br>输出:<br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]</p>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.empty() ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 路径</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(nums.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        backtrack(nums, res, path, visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        <span class="keyword">if</span> ( path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>() ) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可选列表</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( visited[i] == <span class="literal">true</span> ) <span class="keyword">continue</span>; <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="keyword">if</span> ( i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; visited[i - <span class="number">1</span>] == <span class="literal">false</span> ) <span class="keyword">continue</span>; <span class="comment">// 剪枝</span></span><br><span class="line">            <span class="comment">// 操作</span></span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            backtrack(nums, res, path, visited);</span><br><span class="line">            <span class="comment">// 撤销操作</span></span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#48--旋转图像</title>
    <url>/2020/04/11/leetcode48/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#48–旋转图像</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：旋转图像（中等）"><a href="#1-题目：旋转图像（中等）" class="headerlink" title="1.题目：旋转图像（中等）"></a>1.题目：旋转图像（中等）</h3><p>给定一个 n × n 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p>说明：</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<p><strong>示例:</strong></p>
<p>给定 matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p>
<p>原地旋转输入矩阵，使其变为:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( matrix.<span class="built_in">size</span>() &lt; <span class="number">2</span> )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; matrix.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( i != j )</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span> &amp;v : matrix )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = matrix.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j; ++i, --j)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(v[i], v[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#49--字母异位词分组</title>
    <url>/2020/04/11/leetcode49/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#49–字母异位词分组</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：字母异位词分组（中等）"><a href="#1-题目：字母异位词分组（中等）" class="headerlink" title="1.题目：字母异位词分组（中等）"></a>1.题目：字母异位词分组（中等）</h3><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p><strong>示例:</strong></p>
<p>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>输出:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;strs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; save;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> s = str;</span><br><span class="line">            sort(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span> (save.<span class="built_in">find</span>(s) == save.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;());</span><br><span class="line">                res[num].push_back(str);</span><br><span class="line">                save.insert(&#123;s, num&#125;);</span><br><span class="line">                ++num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res[save[s]].push_back(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#5--最长回文子串</title>
    <url>/2020/03/21/leetcode5/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#5–最长回文子串</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：最长回文子串（中等）"><a href="#1-题目：最长回文子串（中等）" class="headerlink" title="1.题目：最长回文子串（中等）"></a>1.题目：最长回文子串（中等）</h3><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: “babad”<br>输出: “bab”<br>注意: “aba” 也是一个有效答案。</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="(1) 动态规划"></a>(1) 动态规划</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( s.<span class="built_in">size</span>() &lt; <span class="number">2</span> ) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(s.<span class="built_in">size</span>()))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>; <span class="comment">// 记录最长回文子串的起始位置</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>; <span class="comment">// 记录最长回文子串的长度</span></span><br><span class="line">        <span class="comment">// l为子串左侧边界索引，r为子串右侧边界索引</span></span><br><span class="line">        <span class="comment">// 遍历所有子串，判断其是否是回文子串，并记录最长回文子串</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> r = <span class="number">1</span>; r &lt; s.<span class="built_in">size</span>(); ++r ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> l = <span class="number">0</span>; l &lt; r; ++l ) &#123;</span><br><span class="line">                <span class="comment">// 判断是否是回文子串(动态规划)</span></span><br><span class="line">                <span class="keyword">if</span> ( s[l] == s[r] ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( r - l &lt; <span class="number">3</span> ) dp[l][r] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[l][r] = dp[l + <span class="number">1</span>][r - <span class="number">1</span>]; <span class="comment">// 状态转移方程</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dp[l][r] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最长回文子串</span></span><br><span class="line">                <span class="keyword">if</span> ( dp[l][r] == <span class="literal">true</span> ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( r - l + <span class="number">1</span> &gt; maxLen ) &#123;</span><br><span class="line">                        maxLen = r - l + <span class="number">1</span>;</span><br><span class="line">                        start = l;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-中心扩散"><a href="#2-中心扩散" class="headerlink" title="(2) 中心扩散"></a>(2) 中心扩散</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( s.<span class="built_in">size</span>() &lt; <span class="number">2</span> ) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> maxLen&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i&#123;<span class="number">0</span>&#125;; i &lt; s.<span class="built_in">size</span>() - <span class="number">1</span>; ++i ) &#123;</span><br><span class="line">            <span class="built_in">string</span> oddStr = helper(s, i, i);</span><br><span class="line">            <span class="built_in">string</span> evenStr = helper(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">string</span> subStr = oddStr.<span class="built_in">size</span>() &gt; evenStr.<span class="built_in">size</span>() ? oddStr : evenStr;</span><br><span class="line">            <span class="keyword">if</span> ( subStr.<span class="built_in">size</span>() &gt;= maxLen ) &#123;</span><br><span class="line">                res = subStr;</span><br><span class="line">                maxLen = res.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ( i &gt;= <span class="number">0</span> &amp;&amp; j &lt; s.<span class="built_in">size</span>() ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( s[i] == s[j] ) --i, ++j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(i + <span class="number">1</span>, j - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#50--Pow(x,n)</title>
    <url>/2020/04/12/leetcode50/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#50–Pow(x,n)</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：Pow-x-n-（中等）"><a href="#1-题目：Pow-x-n-（中等）" class="headerlink" title="1.题目：Pow(x,n)（中等）"></a>1.题目：Pow(x,n)（中等）</h3><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>
<p><strong>示例:</strong></p>
<p>输入: 2.00000, 10<br>输出: 1024.00000</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> half = fastPow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> half * half;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> half * half * x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            N = -N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastPow(x, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#53--最大子序和</title>
    <url>/2020/03/02/leetcode53/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#53–最大子序和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：最大子序和（简单）"><a href="#1-题目：最大子序和（简单）" class="headerlink" title="1.题目：最大子序和（简单）"></a>1.题目：最大子序和（简单）</h3><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-暴力双循环-不好"><a href="#1-暴力双循环-不好" class="headerlink" title="(1)暴力双循环(不好)"></a>(1)暴力双循环(不好)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值</span></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = INT32_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="built_in">max</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">max</span> = sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="(2)动态规划"></a>(2)动态规划</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dp[i]表示nums中以nums[i]结尾的最大子序和</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = dp[<span class="number">0</span>]; <span class="comment">// 记录最大子序和</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + nums[i], nums[i]); <span class="comment">// 状态转移方程</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-贪心算法"><a href="#3-贪心算法" class="headerlink" title="(3)贪心算法"></a>(3)贪心算法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值</span></span><br><span class="line">        <span class="keyword">int</span> result = INT32_MIN;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            result = <span class="built_in">max</span>(result, sum);</span><br><span class="line">            <span class="comment">//如果sum &lt; 0，重新开始找子序串</span></span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#54--螺旋矩阵</title>
    <url>/2020/04/12/leetcode54/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#54–螺旋矩阵</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：螺旋矩阵（中等）"><a href="#1-题目：螺旋矩阵（中等）" class="headerlink" title="1.题目：螺旋矩阵（中等）"></a>1.题目：螺旋矩阵（中等）</h3><p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>
<p><strong>示例:</strong></p>
<p>输入:<br>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]<br>输出: [1,2,3,6,9,8,7,4,5]</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty()) <span class="keyword">return</span> ans; <span class="comment">//若数组为空，直接返回答案</span></span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>; <span class="comment">//赋值上下左右边界</span></span><br><span class="line">        <span class="keyword">int</span> d = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; ++i) ans.push_back(matrix[u][i]); <span class="comment">//向右移动直到最右</span></span><br><span class="line">            <span class="keyword">if</span>(++ u &gt; d) <span class="keyword">break</span>; <span class="comment">//重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = u; i &lt;= d; ++i) ans.push_back(matrix[i][r]); <span class="comment">//向下</span></span><br><span class="line">            <span class="keyword">if</span>(-- r &lt; l) <span class="keyword">break</span>; <span class="comment">//重新设定有边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &gt;= l; --i) ans.push_back(matrix[d][i]); <span class="comment">//向左</span></span><br><span class="line">            <span class="keyword">if</span>(-- d &lt; u) <span class="keyword">break</span>; <span class="comment">//重新设定下边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = d; i &gt;= u; --i) ans.push_back(matrix[i][l]); <span class="comment">//向上</span></span><br><span class="line">            <span class="keyword">if</span>(++ l &gt; r) <span class="keyword">break</span>; <span class="comment">//重新设定左边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#55--跳跃游戏</title>
    <url>/2020/04/13/leetcode55/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#55–跳跃游戏</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：跳跃游戏（中等）"><a href="#1-题目：跳跃游戏（中等）" class="headerlink" title="1.题目：跳跃游戏（中等）"></a>1.题目：跳跃游戏（中等）</h3><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<p><strong>示例:</strong></p>
<p>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lastPos = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + nums[i] &gt;= lastPos) &#123;</span><br><span class="line">                lastPos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastPos == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#56--合并区间</title>
    <url>/2020/04/13/leetcode56/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#56–合并区间</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：合并区间（中等）"><a href="#1-题目：合并区间（中等）" class="headerlink" title="1.题目：合并区间（中等）"></a>1.题目：合并区间（中等）</h3><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p><strong>示例:</strong></p>
<p>输入: [[1,3],[2,6],[8,10],[15,18]]<br>输出: [[1,6],[8,10],[15,18]]<br>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( intervals.empty() ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        sort(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; x, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; y) &#123; <span class="keyword">return</span> x[<span class="number">0</span>] &lt; y[<span class="number">0</span>]; &#125;);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">res</span><span class="params">(<span class="number">1</span>, intervals[<span class="number">0</span>])</span></span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( intervals[i][<span class="number">0</span>] &gt; res.back()[<span class="number">1</span>] ) res.push_back(intervals[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( intervals[i][<span class="number">1</span>] &gt; res.back()[<span class="number">1</span>] ) res.back()[<span class="number">1</span>] = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>CLeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#58--最后一个单词的长度</title>
    <url>/2020/03/02/leetcode58/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#58–最后一个单词的长度</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：外观数列（简单）"><a href="#1-题目：外观数列（简单）" class="headerlink" title="1.题目：外观数列（简单）"></a>1.题目：外观数列（简单）</h3><p>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串 s，返回其最后一个单词的长度。</p>
<p>如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。</p>
<p>如果不存在最后一个单词，请返回 0 。</p>
<p>说明：一个单词是指仅由字母组成、不包含任何空格的 最大子字符串。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: “Hello World”<br>输出: 5</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-使用sstream正序遍历-不好"><a href="#1-使用sstream正序遍历-不好" class="headerlink" title="(1)使用sstream正序遍历(不好)"></a>(1)使用sstream正序遍历(不好)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">in</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (in &gt;&gt; res)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-逆序遍历"><a href="#2-逆序遍历" class="headerlink" title="(2)逆序遍历"></a>(2)逆序遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( s[i] == <span class="string">' '</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( count == <span class="number">0</span> ) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ( count &gt; <span class="number">0</span> ) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#6--Z字形变换</title>
    <url>/2020/03/22/leetcode6/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#6–Z字形变换</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：Z字形变换（中等）"><a href="#1-题目：Z字形变换（中等）" class="headerlink" title="1.题目：Z字形变换（中等）"></a>1.题目：Z字形变换（中等）</h3><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: s = “LEETCODEISHIRING”, numRows = 4<br>输出: “LDREOEIIECIHNTSG”<br>解释:</p>
<p>L     D     R<br>E   O E   I I<br>E C   I H   N<br>T     S     G</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( numRows &lt; <span class="number">2</span> ) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">save</span><span class="params">(numRows)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, flag = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">char</span> c : s ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( i == <span class="number">0</span> || i == numRows - <span class="number">1</span> ) flag = -flag;</span><br><span class="line">            save[i].push_back(c);</span><br><span class="line">            i = i + flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">char</span> s : save ) &#123;</span><br><span class="line">            res += s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#59--螺旋矩阵2</title>
    <url>/2020/04/14/leetcode59/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#59–螺旋矩阵2</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：螺旋矩阵2（中等）"><a href="#1-题目：螺旋矩阵2（中等）" class="headerlink" title="1.题目：螺旋矩阵2（中等）"></a>1.题目：螺旋矩阵2（中等）</h3><p>给定一个正整数 <em>n</em>，生成一个包含 1 到 <em>n</em>2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
<p><strong>示例:</strong></p>
<blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line"> [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ],</span><br><span class="line"> [ <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span> ],</span><br><span class="line"> [ <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span> ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">generateMatrix</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( n == <span class="number">0</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">0</span>, down = n - <span class="number">1</span>, left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">res</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( num &lt;= n * n ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = left; i &lt;= right; ++i ) res[up][i] = num++;</span><br><span class="line">            up++;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = up; i &lt;= down; ++i ) res[i][right] = num++;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = right; i &gt;= left; --i ) res[down][i] = num++;</span><br><span class="line">            down--;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = down; i &gt;= up; --i ) res[i][left] = num++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id><a href="#" class="headerlink" title></a></h4>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#60--第K个排列</title>
    <url>/2020/04/14/leetcode60/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#60–第K个排列</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：第K个排列（中等）"><a href="#1-题目：第K个排列（中等）" class="headerlink" title="1.题目：第K个排列（中等）"></a>1.题目：第K个排列（中等）</h3><p>给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：</p>
<p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>给定 n 和 k，返回第 k 个排列。</p>
<p>说明：</p>
<p>给定 n 的范围是 [1, 9]。<br>给定 k 的范围是[1,  n!]。</p>
<p><strong>示例:</strong></p>
<blockquote>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">n</span> = <span class="number">3</span>, <span class="attr">k</span> = <span class="number">3</span></span><br><span class="line">输出: <span class="string">"213"</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">// 将 n! 种排列分为：n 组，每组有 (n - 1)! 种排列</span></span><br><span class="line">        <span class="keyword">return</span> recursive(n, factorial(n - <span class="number">1</span>), k, visited);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param n 剩余的数字个数，递减</span></span><br><span class="line"><span class="comment">     * @param f 每组的排列个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">recursive</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> f, <span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 计算组别与偏移量</span></span><br><span class="line">        <span class="keyword">int</span> offset = (k - <span class="number">1</span>) % f; <span class="comment">// 组内偏移量，从0开始计数</span></span><br><span class="line">        <span class="keyword">int</span> groupIndex = (k - <span class="number">1</span>) / f; <span class="comment">// 第几组，从0开始计数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据组别找到第一个数字</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; visited.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( visited[i] == <span class="literal">false</span> ) --groupIndex;</span><br><span class="line">            <span class="keyword">if</span> ( groupIndex &lt; <span class="number">0</span> ) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i] = <span class="literal">true</span>;<span class="comment">// 标记为已访问</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归求解</span></span><br><span class="line">        <span class="keyword">if</span> ( n &gt; <span class="number">1</span> ) <span class="keyword">return</span> to_string(i + <span class="number">1</span>) + recursive(n - <span class="number">1</span>, factorial(n - <span class="number">2</span>), offset + <span class="number">1</span>, visited);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> to_string(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求 n!</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">            res *= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#61--旋转链表</title>
    <url>/2020/04/15/leetcode61/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#61–旋转链表</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：旋转链表（中等）"><a href="#1-题目：旋转链表（中等）" class="headerlink" title="1.题目：旋转链表（中等）"></a>1.题目：旋转链表（中等）</h3><p>给定一个链表，旋转链表，将链表每个节点向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
<p><strong>示例:</strong></p>
<blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL, k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: <span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br><span class="line">向右旋转 <span class="number">2</span> 步: <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;NULL</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> ( head == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> ( head-&gt;next == <span class="literal">nullptr</span> ) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将链表连成环</span></span><br><span class="line">        ListNode* old_tail = head;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">for</span> ( n = <span class="number">1</span>; old_tail-&gt;next != <span class="literal">nullptr</span>; n++ )</span><br><span class="line">            old_tail = old_tail-&gt;next;</span><br><span class="line">        old_tail-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找新的链表尾 : (n - k % n - 1)th node</span></span><br><span class="line">        <span class="comment">// 和新的链表头 : (n - k % n)th node</span></span><br><span class="line">        ListNode* new_tail = head;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k % n - <span class="number">1</span>; i++ )</span><br><span class="line">            new_tail = new_tail-&gt;next;</span><br><span class="line">        ListNode* new_head = new_tail-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解开环</span></span><br><span class="line">        new_tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#62--不同路径</title>
    <url>/2020/04/15/leetcode62/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#62–不同路径</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：不同路径（中等）"><a href="#1-题目：不同路径（中等）" class="headerlink" title="1.题目：不同路径（中等）"></a>1.题目：不同路径（中等）</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><strong>示例:</strong></p>
<blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 <span class="number">3</span> 条路径可以到达右下角。</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line"><span class="number">3.</span> 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-题解-动态规划"><a href="#2-题解-动态规划" class="headerlink" title="2.题解 (动态规划)"></a>2.题解 (动态规划)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">        <span class="comment">// 计算dp数组第一行</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i ) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算dp数组第一列</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i ) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算dp数组其余位置</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j ) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j]; <span class="comment">// 状态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#63--不同路径2</title>
    <url>/2020/04/16/leetcode63/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#63–不同路径2</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：不同路径2（中等）"><a href="#1-题目：不同路径2（中等）" class="headerlink" title="1.题目：不同路径2（中等）"></a>1.题目：不同路径2（中等）</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><strong>示例:</strong></p>
<blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释:</span><br><span class="line"><span class="number">3</span>x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 <span class="number">2</span> 条不同的路径：</span><br><span class="line"><span class="number">1.</span> 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2.</span> 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-题解-动态规划"><a href="#2-题解-动态规划" class="headerlink" title="2.题解(动态规划)"></a>2.题解(动态规划)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || obstacleGrid.back().back() == <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt; <span class="title">dp</span><span class="params">(obstacleGrid.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;(obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>()))</span></span>;</span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算dp数组第一行</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span> ) dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算dp数组第二行</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; obstacleGrid.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span> ) dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算dp数组其余位置</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; obstacleGrid.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt; obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( obstacleGrid[i][j] == <span class="number">1</span> ) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]; <span class="comment">// 状态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back().back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#64--最小路径和</title>
    <url>/2020/04/16/leetcode64/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#63–最小路径和</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：最小路径和（中等）"><a href="#1-题目：最小路径和（中等）" class="headerlink" title="1.题目：最小路径和（中等）"></a>1.题目：最小路径和（中等）</h3><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<p><strong>示例:</strong></p>
<blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 因为路径 <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> 的总和最小。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-题解-动态规划"><a href="#2-题解-动态规划" class="headerlink" title="2.题解(动态规划)"></a>2.题解(动态规划)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span> ) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( i == <span class="number">0</span> ) grid[i][j] += grid[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( j == <span class="number">0</span> ) grid[i][j] += grid[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] += <span class="built_in">min</span>(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]); <span class="comment">//状态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid.back().back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#66--加1</title>
    <url>/2020/03/02/leetcode66/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#66–加1</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：加1（简单）"><a href="#1-题目：加1（简单）" class="headerlink" title="1.题目：加1（简单）"></a>1.题目：加1（简单）</h3><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: [1,2,3]<br>输出: [1,2,4]<br>解释: 输入数组表示数字 123。</p>
<p>输入: [4,3,2,1]<br>输出: [4,3,2,2]<br>解释: 输入数组表示数字 4321。</p>
</blockquote>
<h3 id="2-题解-倒序遍历"><a href="#2-题解-倒序遍历" class="headerlink" title="2.题解(倒序遍历)"></a>2.题解(倒序遍历)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        digits.back() += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = digits.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i ) &#123;</span><br><span class="line">            digits[i] += flag;</span><br><span class="line">            <span class="keyword">if</span> ( digits[i] == <span class="number">10</span> ) &#123;</span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( digits[<span class="number">0</span>] == <span class="number">0</span> ) &#123;</span><br><span class="line">            digits.insert(digits.cbegin(), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#67--二进制求和</title>
    <url>/2020/03/02/leetcode67/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#67–二进制求和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二进制求和（简单）"><a href="#1-题目：二进制求和（简单）" class="headerlink" title="1.题目：二进制求和（简单）"></a>1.题目：二进制求和（简单）</h3><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p>
<p>输入为非空字符串且只包含数字 1 和 0。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: a = “11”, b = “1”<br>输出: “100”</p>
<p>输入: a = “1010”, b = “1011”<br>输出: “10101”</p>
</blockquote>
<h3 id="2-题解-倒序遍历"><a href="#2-题解-倒序遍历" class="headerlink" title="2.题解(倒序遍历)"></a>2.题解(倒序遍历)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="keyword">int</span>(a.<span class="built_in">size</span>() - <span class="number">1</span>), j = <span class="keyword">int</span>(b.<span class="built_in">size</span>() - <span class="number">1</span>); i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>; --i, --j ) &#123;</span><br><span class="line">            temp += i &gt;= <span class="number">0</span> ? a[i] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            temp += j &gt;= <span class="number">0</span> ? b[j] - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            res.push_back( temp % <span class="number">2</span> + <span class="string">'0'</span>);</span><br><span class="line">            temp = temp / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( temp == <span class="number">1</span> ) res.push_back(<span class="string">'1'</span>);</span><br><span class="line">        reverse( res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>() );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#69--x的平方根</title>
    <url>/2020/03/02/leetcode69/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#69–x的平方根</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：x的平方根（简单）"><a href="#1-题目：x的平方根（简单）" class="headerlink" title="1.题目：x的平方根（简单）"></a>1.题目：x的平方根（简单）</h3><p>实现 int sqrt(int x) 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 4<br>输出: 2</p>
<p>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。</p>
</blockquote>
<h3 id="2-题解-二分法"><a href="#2-题解-二分法" class="headerlink" title="2.题解(二分法)"></a>2.题解(二分法)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> right = x;</span><br><span class="line">        <span class="keyword">while</span> ( left &lt;= right ) &#123;</span><br><span class="line">            <span class="keyword">long</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ( mid * mid == x ) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( mid * mid &gt; x ) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( mid * mid &lt; x ) left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#7--整数反转</title>
    <url>/2020/02/22/leetcode7/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#7–整数反转题解</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：整数反转（简单）"><a href="#1-题目：整数反转（简单）" class="headerlink" title="1.题目：整数反转（简单）"></a>1.题目：整数反转（简单）</h3><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 123<br>输出: 321</p>
<p>输入: -123<br>输出: -321</p>
<p>输入: 120<br>输出: 21</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( x != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> ( ans &gt; INT32_MAX / <span class="number">10</span> || (ans == INT32_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>) )</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> ( ans &lt; INT32_MIN / <span class="number">10</span> || (ans == INT32_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>) )</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            ans = ans * <span class="number">10</span> + pop;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主要处理int类型溢出问题<br>其中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> == INT32_MAX % <span class="number">10</span></span><br><span class="line"><span class="number">-8</span> == INT32_MIN % <span class="number">10</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#70--爬楼梯</title>
    <url>/2020/03/03/leetcode70/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#70–爬楼梯</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：爬楼梯（简单）"><a href="#1-题目：爬楼梯（简单）" class="headerlink" title="1.题目：爬楼梯（简单）"></a>1.题目：爬楼梯（简单）</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。<br>(1) 1 阶 + 1 阶<br>(2) 2 阶</p>
<p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。<br>(1) 1 阶 + 1 阶 + 1 阶<br>(2) 1 阶 + 2 阶<br>(3) 2 阶 + 1 阶</p>
</blockquote>
<h3 id="2-题解-动态规划"><a href="#2-题解-动态规划" class="headerlink" title="2.题解(动态规划)"></a>2.题解(动态规划)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( n == <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line">        dp.push_back(<span class="number">1</span>);</span><br><span class="line">        dp.push_back(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            dp.push_back( dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>] ); <span class="comment">// 状态转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#71--简化路径</title>
    <url>/2020/04/17/leetcode71/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#71–简化路径</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：简化路径（中等）"><a href="#1-题目：简化路径（中等）" class="headerlink" title="1.题目：简化路径（中等）"></a>1.题目：简化路径（中等）</h3><p>以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。</p>
<p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。</p>
<p>请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入：”/a/../../b/../c//.//“<br>输出：”/c”</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">simplifyPath</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">is</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">        <span class="built_in">string</span> res, tmp;</span><br><span class="line">        <span class="keyword">while</span> ( getline(is, tmp, <span class="string">'/'</span>) ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( tmp == <span class="string">""</span> || tmp == <span class="string">"."</span> )</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( tmp == <span class="string">".."</span> &amp;&amp; !strs.empty() )</span><br><span class="line">                strs.pop_back();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( tmp != <span class="string">".."</span> )</span><br><span class="line">                strs.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="built_in">string</span> str : strs )</span><br><span class="line">            res +=  <span class="string">"/"</span> + str;</span><br><span class="line">        <span class="keyword">if</span> ( res.empty() )</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"/"</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#73--矩阵置0</title>
    <url>/2020/04/17/leetcode73/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#73–矩阵置0</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：矩阵置0（中等）"><a href="#1-题目：矩阵置0（中等）" class="headerlink" title="1.题目：矩阵置0（中等）"></a>1.题目：矩阵置0（中等）</h3><p>给定一个 <em>m</em> x <em>n</em> 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用<strong><a href="http://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a></strong>算法<strong>。</strong></p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:<br>[<br>  [1,1,1],<br>  [1,0,1],<br>  [1,1,1]<br>]<br>输出:<br>[<br>  [1,0,1],<br>  [0,0,0],<br>  [1,0,1]<br>]</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( matrix.empty() ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; row, col;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); ++j ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( matrix[i][j] == <span class="number">0</span> ) &#123;</span><br><span class="line">                    row.insert(i);</span><br><span class="line">                    col.insert(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i : row ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>(); ++j ) &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i : col ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix.<span class="built_in">size</span>(); ++j ) &#123;</span><br><span class="line">                matrix[j][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#78--子集</title>
    <url>/2020/04/20/leetcode78/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#78–子集</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：子集（中等）"><a href="#1-题目：子集（中等）" class="headerlink" title="1.题目：子集（中等）"></a>1.题目：子集（中等）</h3><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p>
<p><strong>说明：</strong>解集不能包含重复的子集。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: nums = [1,2,3]<br>输出:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p>
</blockquote>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.empty() ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 路径</span></span><br><span class="line">        <span class="comment">// sort(nums.begin(), nums.end());</span></span><br><span class="line">        backtrack(nums, res, path, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        res.push_back(path);</span><br><span class="line">        <span class="comment">// 可选列表</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            backtrack(nums, res, path, i + <span class="number">1</span>);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#79--单词搜索</title>
    <url>/2020/04/21/leetcode79/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#79–单词搜索</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：单词搜索（中等）"><a href="#1-题目：单词搜索（中等）" class="headerlink" title="1.题目：单词搜索（中等）"></a>1.题目：单词搜索（中等）</h3><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>board =<br>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]</p>
<p>给定 word = “ABCCED”, 返回 true<br>给定 word = “SEE”, 返回 true<br>给定 word = “ABCB”, 返回 false</p>
</blockquote>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;board = board;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="keyword">word</span> = <span class="keyword">word</span>;</span><br><span class="line">        <span class="keyword">int</span> m = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( dfs(i, j, <span class="number">0</span>, visited) ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; board;</span><br><span class="line">    <span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( index == <span class="keyword">word</span>.<span class="built_in">size</span>() - <span class="number">1</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">word</span>[index] == board[x][y];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( <span class="keyword">word</span>[index] == board[x][y] ) &#123;</span><br><span class="line">            visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i ) &#123;</span><br><span class="line">                <span class="keyword">int</span> new_x = x + dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> new_y = y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ( new_x &gt;= <span class="number">0</span> &amp;&amp; new_x &lt; board.<span class="built_in">size</span>() &amp;&amp; new_y &gt;= <span class="number">0</span> &amp;&amp; new_y &lt; board[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; !visited[new_x][new_y] )</span><br><span class="line">                    <span class="keyword">if</span> ( dfs(new_x, new_y, index + <span class="number">1</span>, visited) ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[x][y] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#8--字符串转换整数</title>
    <url>/2020/03/22/leetcode8/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#8–字符串转换整数</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：字符串转换整数（中等）"><a href="#1-题目：字符串转换整数（中等）" class="headerlink" title="1.题目：字符串转换整数（中等）"></a>1.题目：字符串转换整数（中等）</h3><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: “4193 with words”<br>输出: 4193<br>解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( str.empty() ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//处理空格</span></span><br><span class="line">        <span class="keyword">while</span> ( str[i] == <span class="string">' '</span> &amp;&amp; i &lt; str.<span class="built_in">size</span>() ) &#123; ++i; &#125;</span><br><span class="line">        <span class="keyword">if</span> ( i == str.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//处理正负号</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( str[i] == <span class="string">'-'</span> ) &#123;</span><br><span class="line">            flag = <span class="number">-1</span>;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( str[i] == <span class="string">'+'</span> ) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( i &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[i]) ) &#123;</span><br><span class="line">            <span class="comment">//判断溢出</span></span><br><span class="line">            <span class="keyword">int</span> dig = flag * (str[i] - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span> ( res &gt; INT32_MAX / <span class="number">10</span> || ( res == INT32_MAX / <span class="number">10</span> &amp;&amp; dig &gt; INT32_MAX % <span class="number">10</span> ) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT32_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( res &lt; INT32_MIN / <span class="number">10</span> || ( res == INT32_MIN / <span class="number">10</span> &amp;&amp; dig &lt; INT32_MIN % <span class="number">10</span> ) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT32_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="number">10</span> * res + dig;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#80--删除排序数组中的重复项II</title>
    <url>/2020/04/21/leetcode80/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#80–删除排序数组中的重复项II</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：删除排序数组中的重复项II（中等）"><a href="#1-题目：删除排序数组中的重复项II（中等）" class="headerlink" title="1.题目：删除排序数组中的重复项II（中等）"></a>1.题目：删除排序数组中的重复项II（中等）</h3><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>给定 nums = [1,1,1,2,2,3],</p>
<p>函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。</p>
<p>你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.<span class="built_in">size</span>() &lt; <span class="number">2</span> ) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>, count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) count++;</span><br><span class="line">            <span class="keyword">else</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">2</span>) nums[j++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#81--搜索旋转排序数组II</title>
    <url>/2020/04/22/leetcode81/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#81–搜索旋转排序数组II</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：搜索旋转排序数组II（中等）"><a href="#1-题目：搜索旋转排序数组II（中等）" class="headerlink" title="1.题目：搜索旋转排序数组II（中等）"></a>1.题目：搜索旋转排序数组II（中等）</h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。</p>
<p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: nums = [2,5,6,0,0,1,2], target = 0<br>输出: true</p>
</blockquote>
<h3 id="2-题解-二分法"><a href="#2-题解-二分法" class="headerlink" title="2.题解(二分法)"></a>2.题解(二分法)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.empty() ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( left &lt;= right ) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ( nums[mid] == target ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> ( nums[mid] == nums[left] ) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( nums[left] &lt; nums[mid] ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( target &gt;= nums[left] &amp;&amp; target &lt; nums[mid] ) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( target &gt; nums[mid] &amp;&amp; target &lt;= nums[right] ) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#82--删除排序链表中的重复元素II</title>
    <url>/2020/04/22/leetcode82/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#82–删除排序链表中的重复元素II</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：删除排序链表中的重复元素II（中等）"><a href="#1-题目：删除排序链表中的重复元素II（中等）" class="headerlink" title="1.题目：删除排序链表中的重复元素II（中等）"></a>1.题目：删除排序链表中的重复元素II（中等）</h3><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 <em>没有重复出现</em> 的数字。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>输出: 1-&gt;2-&gt;5</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( head == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* first = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        first-&gt;next = head;</span><br><span class="line">        ListNode* ptr = first;</span><br><span class="line">        <span class="keyword">while</span> ( ptr-&gt;next != <span class="literal">nullptr</span> &amp;&amp; ptr-&gt;next-&gt;next != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( ptr-&gt;next-&gt;next-&gt;val &gt; ptr-&gt;next-&gt;val ) &#123;</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ListNode* search = ptr-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">while</span> ( search-&gt;next != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( search-&gt;next-&gt;val == search-&gt;val ) &#123;</span><br><span class="line">                        search = search-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ptr-&gt;next = search-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#83--删除排序链表中的重复元素</title>
    <url>/2020/03/03/leetcode83/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#83–删除排序链表中的重复元素</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：删除排序链表中的重复元素（简单）"><a href="#1-题目：删除排序链表中的重复元素（简单）" class="headerlink" title="1.题目：删除排序链表中的重复元素（简单）"></a>1.题目：删除排序链表中的重复元素（简单）</h3><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2</p>
<p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p>
</blockquote>
<h3 id="2-题解-链表"><a href="#2-题解-链表" class="headerlink" title="2.题解(链表)"></a>2.题解(链表)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* ptr = head;</span><br><span class="line">        <span class="keyword">while</span> ( ptr != <span class="literal">nullptr</span> &amp;&amp; ptr-&gt;next != <span class="literal">nullptr</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( ptr-&gt;val == ptr-&gt;next-&gt;val )</span><br><span class="line">            &#123;</span><br><span class="line">                ptr-&gt;next = ptr-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ptr = ptr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#86--分隔链表</title>
    <url>/2020/04/23/leetcode86/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#86–分隔链表</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：分隔链表（中等）"><a href="#1-题目：分隔链表（中等）" class="headerlink" title="1.题目：分隔链表（中等）"></a>1.题目：分隔链表（中等）</h3><p>给定一个链表和一个特定值 <em>x</em>，对链表进行分隔，使得所有小于 <em>x</em> 的节点都在大于或等于 <em>x</em> 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode* smallBeforeHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* small = smallBeforeHead;</span><br><span class="line">        ListNode* bigAfterHead = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* big = bigAfterHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val &lt; x) &#123;</span><br><span class="line">                small-&gt;next = head;</span><br><span class="line">                small = small-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                big-&gt;next = head;</span><br><span class="line">                big = big-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        big-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        small-&gt;next = bigAfterHead-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> smallBeforeHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#88--合并两个有序数组</title>
    <url>/2020/03/03/leetcode88/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#88–合并两个有序数组</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：合并两个有序数组（简单）"><a href="#1-题目：合并两个有序数组（简单）" class="headerlink" title="1.题目：合并两个有序数组（简单）"></a>1.题目：合并两个有序数组（简单）</h3><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p>
<p>说明:</p>
<p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p>
<p>输出: [1,2,2,3,5,6]</p>
</blockquote>
<h3 id="2-题解-倒序遍历"><a href="#2-题解-倒序遍历" class="headerlink" title="2.题解(倒序遍历)"></a>2.题解(倒序遍历)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( nums1[i] &gt; nums2[j] ) &#123;</span><br><span class="line">                nums1[len] = nums1[i];</span><br><span class="line">                --i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[len] = nums2[j];</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            --len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( i &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( j &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line">                nums1[j] = nums2[j];</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#89--格雷编码</title>
    <url>/2020/04/23/leetcode89/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#89–格雷编码</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：格雷编码（中等）"><a href="#1-题目：格雷编码（中等）" class="headerlink" title="1.题目：格雷编码（中等）"></a>1.题目：格雷编码（中等）</h3><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p>
<p>给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 2<br>输出: [0,1,3,2]<br>解释:<br>00 - 0<br>01 - 1<br>11 - 3<br>10 - 2</p>
<p>对于给定的 n，其格雷编码序列并不唯一。<br>例如，[0,2,3,1] 也是一个有效的格雷编码序列。</p>
<p>00 - 0<br>10 - 2<br>11 - 3<br>01 - 1</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.push_back(<span class="number">0</span>); <span class="comment">//初始的G(0)</span></span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = res.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j ) &#123; <span class="comment">//作为镜像翻转需倒序操作</span></span><br><span class="line">                <span class="keyword">int</span> t = res[j] | head; <span class="comment">//进行或逻辑运算。在他们的首位进1</span></span><br><span class="line">                res.push_back(t);</span><br><span class="line">            &#125;</span><br><span class="line">            head &lt;&lt;= <span class="number">1</span>; <span class="comment">//进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#9--回文数</title>
    <url>/2020/02/22/leetcode9/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#9–回文数题解</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：回文数（简单）"><a href="#1-题目：回文数（简单）" class="headerlink" title="1.题目：回文数（简单）"></a>1.题目：回文数（简单）</h3><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 121<br>输出: true</p>
<p>输入: -121<br>输出: false<br>解释: 从左向右读,为-121。从右向左读,为121-。因此它不是一个回文数。</p>
<p>输入: 10<br>输出: false<br>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-转化成字符串"><a href="#1-转化成字符串" class="headerlink" title="(1)转化成字符串"></a>(1)转化成字符串</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> rev;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//排除负数</span></span><br><span class="line">        <span class="built_in">string</span> str_x = to_string(x);  <span class="comment">//转换成字符串</span></span><br><span class="line">        reverse(str_x.<span class="built_in">begin</span>(), str_x.<span class="built_in">end</span>());  <span class="comment">//进行反转</span></span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(str_x)</span></span>;</span><br><span class="line">        in &gt;&gt; rev;  <span class="comment">//结果写入rev</span></span><br><span class="line">        <span class="keyword">return</span> x == rev;  <span class="comment">//比较得出结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-反转一半数字"><a href="#2-反转一半数字" class="headerlink" title="(2)反转一半数字"></a>(2)反转一半数字</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> midrev = <span class="number">0</span>;  <span class="comment">//存储后半部分数字的反转结果</span></span><br><span class="line">        <span class="comment">//排除负数和最后一位数字为0的数字</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; midrev)</span><br><span class="line">        &#123;</span><br><span class="line">            midrev = midrev * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> midrev == x || midrev / <span class="number">10</span> == x;  <span class="comment">//数字个数为偶数和奇数分两种情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#90--子集2</title>
    <url>/2020/04/24/leetcode90/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#90–子集2</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：子集2（中等）"><a href="#1-题目：子集2（中等）" class="headerlink" title="1.题目：子集2（中等）"></a>1.题目：子集2（中等）</h3><p>给定一个可能包含重复元素的整数数组 <strong><em>nums</em></strong>，返回该数组所有可能的子集（幂集）。</p>
<p><strong>说明：</strong>解集不能包含重复的子集。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: [1,2,2]<br>输出:<br>[<br>  [2],<br>  [1],<br>  [1,2,2],<br>  [2,2],<br>  [1,2],<br>  []<br>]</p>
</blockquote>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsetsWithDup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.empty() ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 路径</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(nums.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        backtrack(nums, res, path, <span class="number">0</span>, visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> start, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        res.push_back(path);</span><br><span class="line">        <span class="comment">// 可选列表</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; visited[i - <span class="number">1</span>] == <span class="literal">false</span> ) <span class="keyword">continue</span>; <span class="comment">// 剪枝</span></span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            backtrack(nums, res, path, i + <span class="number">1</span>, visited);</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#91--解码方法</title>
    <url>/2020/04/24/leetcode91/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#91–解码方法</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：解码方法（中等）"><a href="#1-题目：解码方法（中等）" class="headerlink" title="1.题目：解码方法（中等）"></a>1.题目：解码方法（中等）</h3><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>给定一个只包含数字的非空字符串，请计算解码方法的总数。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: “12”<br>输出: 2<br>解释: 它可以解码为 “AB”（1 2）或者 “L”（12）。</p>
</blockquote>
<h3 id="2-题解-动态规划"><a href="#2-题解-动态规划" class="headerlink" title="2.题解(动态规划)"></a>2.题解(动态规划)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( s[<span class="number">0</span>] == <span class="string">'0'</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.<span class="built_in">size</span>() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt; s.<span class="built_in">size</span>() + <span class="number">1</span>; ++i ) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 1. s[j]不能单独译码</span></span><br><span class="line">            <span class="keyword">if</span> ( s[j] == <span class="string">'0'</span> )</span><br><span class="line">                <span class="comment">// 1.1 s[j]能与s[j - 1]合并译码</span></span><br><span class="line">                <span class="keyword">if</span> (s[j - <span class="number">1</span>] == <span class="string">'1'</span> || s[j - <span class="number">1</span>] == <span class="string">'2'</span>) dp[i] = dp[i - <span class="number">2</span>]; <span class="comment">// 状态转移方程</span></span><br><span class="line">                <span class="comment">// 1.2 无法译码</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 2. s[j]可以单独译码，也可以与s[j - 1]合并译码</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[j - <span class="number">1</span>] == <span class="string">'1'</span> || (s[j - <span class="number">1</span>] == <span class="string">'2'</span> &amp;&amp; s[j] &gt;= <span class="string">'1'</span> &amp;&amp; s[j] &lt;= <span class="string">'6'</span>))</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]; <span class="comment">// 状态转移方程</span></span><br><span class="line">            <span class="comment">// 3. s[j]只能单独译码</span></span><br><span class="line">            <span class="keyword">else</span> dp[i] = dp[i - <span class="number">1</span>]; <span class="comment">// 状态转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#92--反转链表2</title>
    <url>/2020/04/25/leetcode92/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#92–反转链表2</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：反转链表2（中等）"><a href="#1-题目：反转链表2（中等）" class="headerlink" title="1.题目：反转链表2（中等）"></a>1.题目：反转链表2（中等）</h3><p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。</p>
<p><strong>说明:</strong><br>1 ≤ <em>m</em> ≤ <em>n</em> ≤ 链表长度。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//思路：head表示需要反转的头节点，pre表示需要反转头节点的前驱节点</span></span><br><span class="line">    <span class="comment">//我们需要反转n-m次，我们将head的next节点移动到需要反转链表部分的首部，需要反转链表部分剩余节点依旧保持相对顺序即可</span></span><br><span class="line">    <span class="comment">//比如1-&gt;2-&gt;3-&gt;4-&gt;5,m=1,n=5</span></span><br><span class="line">    <span class="comment">//第一次反转：1(head) 2(next) 3 4 5 反转为 2 1 3 4 5</span></span><br><span class="line">    <span class="comment">//第二次反转：2 1(head) 3(next) 4 5 反转为 3 2 1 4 5</span></span><br><span class="line">    <span class="comment">//第三次发转：3 2 1(head) 4(next) 5 反转为 4 3 2 1 5</span></span><br><span class="line">    <span class="comment">//第四次反转：4 3 2 1(head) 5(next) 反转为 5 4 3 2 1</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode *pre = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) pre = pre-&gt;next;</span><br><span class="line">        head = pre-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt; n; ++i) &#123;</span><br><span class="line">            ListNode *nxt = head-&gt;next;</span><br><span class="line">            <span class="comment">//head节点连接nxt节点之后链表部分，也就是向后移动一位</span></span><br><span class="line">            head-&gt;next = nxt-&gt;next;</span><br><span class="line">            <span class="comment">//nxt节点移动到需要反转链表部分的首部</span></span><br><span class="line">            nxt-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = nxt;<span class="comment">//pre继续为需要反转头节点的前驱节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#93--复原IP地址</title>
    <url>/2020/04/25/leetcode93/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#93–复原IP地址</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：复原IP地址（中等）"><a href="#1-题目：复原IP地址（中等）" class="headerlink" title="1.题目：复原IP地址（中等）"></a>1.题目：复原IP地址（中等）</h3><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: “25525511135”<br>输出: [“255.255.11.135”, “255.255.111.35”]</p>
</blockquote>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="comment">//字符串s长度</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">restoreIpAddresses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        n = s.<span class="built_in">size</span>();</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="string">""</span>, s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param start 当前开始的位置</span></span><br><span class="line"><span class="comment">     * @param depth 当前选出了几个段</span></span><br><span class="line"><span class="comment">     * @param path 传递的路径(一般字符串问题都将路径作为传递，可以解决回溯弹出问题)</span></span><br><span class="line"><span class="comment">     * @param s 给出的需要分割的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> depth, <span class="built_in">string</span> path, <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        <span class="keyword">if</span> ( depth == <span class="number">4</span> ) &#123;</span><br><span class="line">            path.pop_back(); <span class="comment">//除去传递参数时最后一次多加的'.'</span></span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可选列表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// endMin 表示最短可以在哪里结束, endMax 表示最长可以在哪里结束</span></span><br><span class="line">        <span class="comment">// 3 - depth 表示剩余的 ip 段个数 (EG.当depth=0,现在正在处理第一段,还剩3段)</span></span><br><span class="line">        <span class="comment">// n - (3 - depth) * 3 表示剩余的 ip 段如果都是 3 位数，当前 ip 段的结束位置（取不到）</span></span><br><span class="line">        <span class="comment">// start + 1 也是因为取不到</span></span><br><span class="line">        <span class="keyword">int</span> endMin = <span class="built_in">max</span>(start + <span class="number">1</span>, n - (<span class="number">3</span> - depth) * <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// n - (3 - depth) * 1 表示剩余的 ip 段如果都是 1 位数，当前 ip 段的结束位置（取不到）</span></span><br><span class="line">        <span class="keyword">int</span> endMax = <span class="built_in">min</span>(start + <span class="number">3</span>, n - (<span class="number">3</span> - depth));</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> <span class="built_in">end</span> = endMin; <span class="built_in">end</span> &lt;= endMax; ++<span class="built_in">end</span> ) &#123;</span><br><span class="line">            <span class="built_in">string</span> split = s.substr(start, <span class="built_in">end</span> - start); <span class="comment">// end - start 表示截取长度</span></span><br><span class="line">            <span class="comment">// 剪枝；当长度&gt;1时, 第一位不能为0；每一段不能多于255</span></span><br><span class="line">            <span class="keyword">if</span> ( split.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; split[<span class="number">0</span>] == <span class="string">'0'</span> || stoi(split) &gt; <span class="number">255</span> ) <span class="keyword">break</span>;</span><br><span class="line">            dfs(<span class="built_in">end</span>, depth + <span class="number">1</span>, path + (split + <span class="string">'.'</span>), s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#94--二叉树的中序遍历</title>
    <url>/2020/04/30/leetcode94/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#94–二叉树的中序遍历</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：二叉树的中序遍历（中等）"><a href="#1-题目：二叉树的中序遍历（中等）" class="headerlink" title="1.题目：二叉树的中序遍历（中等）"></a>1.题目：二叉树的中序遍历（中等）</h3><p>给定一个二叉树，返回它的中序遍历。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="(1) 递归"></a>(1) 递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">		helper(root, res);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( root-&gt;left != <span class="literal">nullptr</span> ) helper(root-&gt;left, res);</span><br><span class="line">		res.push_back(root-&gt;val);</span><br><span class="line">		<span class="keyword">if</span> ( root-&gt;right != <span class="literal">nullptr</span> ) helper(root-&gt;right, res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-迭代"><a href="#2-迭代" class="headerlink" title="(2) 迭代"></a>(2) 迭代</h4><h5 id="a-模拟递归调用栈"><a href="#a-模拟递归调用栈" class="headerlink" title="(a) 模拟递归调用栈"></a>(a) 模拟递归调用栈</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">		<span class="built_in">stack</span>&lt;TreeNode*&gt; auxStack;</span><br><span class="line">		TreeNode* node = root;</span><br><span class="line">		<span class="keyword">while</span> ( !auxStack.empty() || node != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">			<span class="keyword">if</span> ( node != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">				auxStack.push(node);</span><br><span class="line">				node = node-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				node = auxStack.top();</span><br><span class="line">				auxStack.pop();</span><br><span class="line">				res.push_back(node-&gt;val);</span><br><span class="line">				node = node-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="b-颜色标记法"><a href="#b-颜色标记法" class="headerlink" title="(b) 颜色标记法"></a>(b) 颜色标记法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">		<span class="keyword">int</span> WHITE = <span class="number">0</span>, GRAY = <span class="number">1</span>;  <span class="comment">//白色代表遍历过0次，灰色代表遍历过1次</span></span><br><span class="line">		<span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, TreeNode*&gt;&gt; auxStack;  <span class="comment">//辅助栈</span></span><br><span class="line">		auxStack.push(make_pair(WHITE, root));</span><br><span class="line">		<span class="keyword">while</span> ( !auxStack.empty() )</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">int</span> color = auxStack.top().first;</span><br><span class="line">			TreeNode* node = auxStack.top().second;</span><br><span class="line">			auxStack.pop();</span><br><span class="line">			<span class="keyword">if</span> ( node == <span class="literal">nullptr</span> ) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> ( color == WHITE )</span><br><span class="line">			&#123;</span><br><span class="line">				auxStack.push(make_pair(WHITE, node-&gt;right));</span><br><span class="line">				auxStack.push(make_pair(GRAY, node));</span><br><span class="line">				auxStack.push(make_pair(WHITE, node-&gt;left));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> res.push_back(node-&gt;val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#95--不同的二叉搜索树2</title>
    <url>/2020/04/30/leetcode95/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#95–不同的二叉搜索树2</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：不同的二叉搜索树2（中等）"><a href="#1-题目：不同的二叉搜索树2（中等）" class="headerlink" title="1.题目：不同的二叉搜索树2（中等）"></a>1.题目：不同的二叉搜索树2（中等）</h3><p>给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( n == <span class="number">0</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">        res = helper(<span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">helper</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( start &gt; <span class="built_in">end</span> ) <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = start; i &lt;= <span class="built_in">end</span>; ++i ) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; lTreeSet = helper(start, i - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; rTreeSet = helper(i + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">            <span class="keyword">for</span> ( TreeNode* lTree : lTreeSet ) &#123;</span><br><span class="line">                <span class="keyword">for</span> ( TreeNode* rTree : rTreeSet ) &#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root-&gt;left = lTree;</span><br><span class="line">                    root-&gt;right = rTree;</span><br><span class="line">                    ans.push_back(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#96--不同的二叉搜索树</title>
    <url>/2020/04/30/leetcode96/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#95–不同的二叉搜索树</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：不同的二叉搜索树（中等）"><a href="#1-题目：不同的二叉搜索树（中等）" class="headerlink" title="1.题目：不同的二叉搜索树（中等）"></a>1.题目：不同的二叉搜索树（中等）</h3><p>给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？</p>
<h3 id="2-题解-动态规划"><a href="#2-题解-动态规划" class="headerlink" title="2.题解(动态规划)"></a>2.题解(动态规划)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i ) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j ) &#123; <span class="comment">// 状态转移方程</span></span><br><span class="line">                num += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#98--验证二叉搜索树</title>
    <url>/2020/04/30/leetcode98/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#98–验证二叉搜索树</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：验证二叉搜索树（中等）"><a href="#1-题目：验证二叉搜索树（中等）" class="headerlink" title="1.题目：验证二叉搜索树（中等）"></a>1.题目：验证二叉搜索树（中等）</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="(1) 递归"></a>(1) 递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, INT64_MIN, INT64_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由顶自下，节点的取值范围逐渐缩小</span></span><br><span class="line"><span class="comment">     * 左儿子的上限变为父节点值</span></span><br><span class="line"><span class="comment">     * 右儿子的下限变为父节点值</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param node : 待检测节点</span></span><br><span class="line"><span class="comment">     * @param lowerLimit : 待检测节点的下限</span></span><br><span class="line"><span class="comment">     * @param upperLimit : 待检测节点的上限</span></span><br><span class="line"><span class="comment">     * @return : 以root为根节点的树是否是二叉搜索树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* node, <span class="keyword">long</span> lowerLimit, <span class="keyword">long</span> upperLimit)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//若树根节点为空，认为是二叉搜索树</span></span><br><span class="line">        <span class="keyword">if</span> ( node == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//判断树的根节点是否满足上下限</span></span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;val &lt;= lowerLimit ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;val &gt;= upperLimit ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断左子树和右子树是否是二叉搜索树</span></span><br><span class="line">        <span class="keyword">return</span> helper(node-&gt;left, lowerLimit, node-&gt;val) &amp;&amp; helper(node-&gt;right, node-&gt;val, upperLimit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-中序遍历-迭代"><a href="#2-中序遍历-迭代" class="headerlink" title="(2) 中序遍历(迭代)"></a>(2) 中序遍历(迭代)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//利用二叉搜索树中序遍历的结果是一个递增序列来判断</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; auxStack;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="keyword">long</span> order = INT64_MIN;</span><br><span class="line">        <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> || !auxStack.empty() ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( node != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                auxStack.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                node = auxStack.top();</span><br><span class="line">                auxStack.pop();</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;val &lt;= order ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                order = node-&gt;val;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Linux系统下printf函数的输出问题</title>
    <url>/2019/08/21/linux-printf/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍了linux系统中，C语言调试过程中，printf函数中的内容不能及时输出的原因和解决方案</p>
</blockquote>
<a id="more"></a>

<h3 id="1-原因"><a href="#1-原因" class="headerlink" title="1. 原因"></a>1. 原因</h3><p>unix上标准输入输出都是带有缓存的，一般是行缓存。</p>
<p>对于标准输出，需要输出的数据并不是直接输出到终端上，而是首先缓存到某个地方，当遇到行刷新标志或者该缓存已满的情况下，才会把缓存的数据显示到终端设备上。</p>
<p>ANSI C中定义换行符’\n’可以认为是行刷新标志。所以，printf函数没有带’\n’是不会自动刷新输出流，直至缓存被填满。</p>
<h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h3><p>(1) 在printf里加”\n”</p>
<p>(2) 刷新标准输出缓冲区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ fflush(stdout);               <span class="comment"># 在printf 之后调用它,刷新一下缓冲区,让它马上输出。</span></span><br><span class="line">$ setvbuf(stdout,NULL,_IONBF,0);</span><br><span class="line">$ setbuf(stdout,NULL);          <span class="comment"># 直接将缓冲区禁止了. 它就直接输出了。</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++动态申请内存</title>
    <url>/2019/11/25/new-array/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了C++中动态申请内存的方法</p>
</blockquote>
<a id="more"></a>

<h3 id="1-动态申请一个值的内存"><a href="#1-动态申请一个值的内存" class="headerlink" title="1. 动态申请一个值的内存"></a>1. 动态申请一个值的内存</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">//这样可以动态分配一个int型变量的内存</span></span><br></pre></td></tr></table></figure>

<h3 id="2-动态申请一个一维数组的内存"><a href="#2-动态申请一个一维数组的内存" class="headerlink" title="2. 动态申请一个一维数组的内存"></a>2. 动态申请一个一维数组的内存</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];  <span class="comment">//这样可以动态分配一个int型一维数组的内存</span></span><br></pre></td></tr></table></figure>

<h3 id="3-动态申请一个二维数组的内存"><a href="#3-动态申请一个二维数组的内存" class="headerlink" title="3. 动态申请一个二维数组的内存"></a>3. 动态申请一个二维数组的内存</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>** ptr = <span class="keyword">new</span> <span class="keyword">int</span>* [row];  <span class="comment">//先申请一个一维数组，用来存放指针</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">    *(ptr + i) = <span class="keyword">new</span> <span class="keyword">int</span>[col];  <span class="comment">//为一维数组中的每个指针再次分配空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2019/11/25/new-array/二维数组.jpg">]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的赋值运算符重载函数</title>
    <url>/2019/11/25/operator/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了C++中的赋值运算符重载函数</p>
</blockquote>
<a id="more"></a>

<h3 id="1-什么时候调用赋值函数"><a href="#1-什么时候调用赋值函数" class="headerlink" title="1. 什么时候调用赋值函数"></a>1. 什么时候调用赋值函数</h3><p>当一个类的对象向该类的另一个对象赋值时，被赋值对象就会调用该类的赋值函数</p>
<blockquote>
<p>该类必须是已经存在的，不能是新创建的，否则将调用拷贝构造函数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ClassExample obj1;</span><br><span class="line">ClassExample obj2;</span><br><span class="line">obj2 = obj1;  <span class="comment">//obj2已存在，用obj1向obj2赋值，调用赋值函数</span></span><br><span class="line"></span><br><span class="line">ClassExample obj3 = obj2;  <span class="comment">//obj3不存在，用obj2初始化obj3，调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<h3 id="2-常见定义形式"><a href="#2-常见定义形式" class="headerlink" title="2. 常见定义形式"></a>2. 常见定义形式</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ClassExample&amp; <span class="keyword">operator</span>=（<span class="keyword">const</span> ClassExample&amp; obj)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;obj)&#123;</span><br><span class="line">        <span class="comment">// 赋值函数主体</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h3><p>(1) 避免自赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;obj)&#123;</span><br><span class="line">    <span class="comment">// 赋值函数主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 释放原对象申请的内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] ptr;</span><br></pre></td></tr></table></figure>

<p>(3) 申请新的内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ptr = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>(4) 将原对象的成员复制给被赋值对象</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下常用快捷键</title>
    <url>/2020/04/29/shortcut/</url>
    <content><![CDATA[<blockquote>
<p>本文收集了一些在linux系统中常用的快捷键</p>
</blockquote>
<a id="more"></a>

<h3 id="1-终端控制符"><a href="#1-终端控制符" class="headerlink" title="1. 终端控制符"></a>1. 终端控制符</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ctrl + c  <span class="comment"># 强制中断程序的执行,进程已经终止</span></span><br><span class="line">$ ctrl + z  <span class="comment"># 将任务中止（暂停的意思）</span></span><br><span class="line">$ ctrl + d  <span class="comment"># 表示一个特殊的二进制值，表示 EOF；在shell中，ctrl-d表示推出当前shell</span></span><br></pre></td></tr></table></figure>
<p>ctrl + z 表示此任务并没有结束,他仍然在进程中他只是维持挂起的状态,用户可以使用fg/bg操作继续前台或后台的任务,fg命令重新启动前台被中断的任务,bg命令把被中断的任务放在后台执行.<br>例如:当你vi一个文件时,如果需要用shell执行别的操作,但是你又不打算关闭vi,因为你得存盘推出,你可以简单的按下ctrl+z,shell会将vi进程挂起,当你结束了那个shell操作之后,你可以用fg命令继续vi你的文件。</p>
<h3 id="2-终端常用快捷键"><a href="#2-终端常用快捷键" class="headerlink" title="2. 终端常用快捷键"></a>2. 终端常用快捷键</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Tab</td>
<td>补全</td>
</tr>
<tr>
<td>Ctrl+Alt+T</td>
<td>启动终端</td>
</tr>
<tr>
<td>Ctrl+D</td>
<td>关闭终端</td>
</tr>
<tr>
<td>Ctrl+Shift+C</td>
<td>复制</td>
</tr>
<tr>
<td>Ctrl+Shift+V</td>
<td>粘贴</td>
</tr>
<tr>
<td>Ctrl+A</td>
<td>光标移到行的开头</td>
</tr>
<tr>
<td>Ctrl+E</td>
<td>光标移到行的结尾</td>
</tr>
<tr>
<td>Ctrl+Left-Arrow</td>
<td>光标移到上一个单词的词首</td>
</tr>
<tr>
<td>Ctrl+Right-Arrow</td>
<td>光标移到下一个单词的词尾</td>
</tr>
<tr>
<td>Ctrl+U</td>
<td>剪切此处至开始的所有内容</td>
</tr>
<tr>
<td>Ctrl+K</td>
<td>剪切此处至末尾的所有内容</td>
</tr>
<tr>
<td>Ctrl+Y</td>
<td>粘贴由Ctrl+U和Ctrl+K剪切的内容</td>
</tr>
<tr>
<td>Ctrl+L</td>
<td>清屏</td>
</tr>
</tbody></table>
<h3 id="3-vim常用快捷键"><a href="#3-vim常用快捷键" class="headerlink" title="3. vim常用快捷键"></a>3. vim常用快捷键</h3><h4 id="1-删除命令"><a href="#1-删除命令" class="headerlink" title="(1) 删除命令"></a>(1) 删除命令</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>dd</td>
<td>删除光标当前行</td>
</tr>
<tr>
<td>d$</td>
<td>删除本行光标后面的内容</td>
</tr>
<tr>
<td>d0</td>
<td>删除本行光标前面的内容</td>
</tr>
<tr>
<td>ndd</td>
<td>删除当前行以及其后的 n - 1 行</td>
</tr>
<tr>
<td>x</td>
<td>删除光标后的一个字符</td>
</tr>
</tbody></table>
<h4 id="2-指令模式"><a href="#2-指令模式" class="headerlink" title="(2) 指令模式"></a>(2) 指令模式</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>:q</td>
<td>一般退出</td>
</tr>
<tr>
<td>:q!</td>
<td>退出不保存</td>
</tr>
<tr>
<td>:wq</td>
<td>保存退出</td>
</tr>
<tr>
<td>:set nu</td>
<td>设置行号显示</td>
</tr>
<tr>
<td>:set nonu</td>
<td>取消行号显示</td>
</tr>
<tr>
<td>u</td>
<td>撤销</td>
</tr>
</tbody></table>
<h4 id="3-查找命令"><a href="#3-查找命令" class="headerlink" title="(3) 查找命令"></a>(3) 查找命令</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>/code</td>
<td>查找和code一样的内容，向后</td>
</tr>
<tr>
<td>?code</td>
<td>查找和code一样的内容，向前</td>
</tr>
<tr>
<td>n</td>
<td>查找下一处</td>
</tr>
<tr>
<td>N</td>
<td>查找上一处</td>
</tr>
<tr>
<td>:%s/word1/word2/g</td>
<td>替换每一行的每个word1为word2</td>
</tr>
<tr>
<td>:%s#word1#word2#g</td>
<td>同上</td>
</tr>
</tbody></table>
<h4 id="4-光标操作"><a href="#4-光标操作" class="headerlink" title="(4) 光标操作"></a>(4) 光标操作</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>b</td>
<td>按单词向前移动，字首</td>
</tr>
<tr>
<td>e</td>
<td>按单词向后移动，字尾</td>
</tr>
<tr>
<td>G</td>
<td>移动到文档最后一行</td>
</tr>
<tr>
<td>gg</td>
<td>移动到文档第一行</td>
</tr>
<tr>
<td>0</td>
<td>移动到行首</td>
</tr>
<tr>
<td>$</td>
<td>移动到行尾</td>
</tr>
</tbody></table>
<h4 id="5-复制粘贴"><a href="#5-复制粘贴" class="headerlink" title="(5) 复制粘贴"></a>(5) 复制粘贴</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>v</td>
<td>进入可视模式</td>
</tr>
<tr>
<td>y</td>
<td>复制</td>
</tr>
<tr>
<td>yy</td>
<td>复制1行</td>
</tr>
<tr>
<td>nyy</td>
<td>复制n行</td>
</tr>
<tr>
<td>p</td>
<td>粘贴</td>
</tr>
</tbody></table>
<h4 id="6-代码自动补全"><a href="#6-代码自动补全" class="headerlink" title="(6) 代码自动补全"></a>(6) 代码自动补全</h4><p>ctrl + n</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu中连接远程服务器</title>
    <url>/2020/04/30/ubuntu-ssh/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍了在ubuntu20.04中连接远程服务器的方法</p>
</blockquote>
<a id="more"></a>
<h3 id="1-使用Remmina连接远程服务器"><a href="#1-使用Remmina连接远程服务器" class="headerlink" title="1. 使用Remmina连接远程服务器"></a>1. 使用Remmina连接远程服务器</h3><p>（1）安装并打开Remmina远程桌面客户端，点击新建按钮；</p>
<img src="/2020/04/30/ubuntu-ssh/ubuntu-ssh1.png">

<p>（2）协议选择<strong>SSH-安全Shell连接</strong>，填入服务器地址(服务器IP:端口号)及用户名，并验证密码；</p>
<img src="/2020/04/30/ubuntu-ssh/ubuntu-ssh2.png">

<p>（3）成功连接服务器</p>
<img src="/2020/04/30/ubuntu-ssh/ubuntu-ssh3.png">

<h3 id="2-使用ssh连接远程服务器"><a href="#2-使用ssh连接远程服务器" class="headerlink" title="2. 使用ssh连接远程服务器"></a>2. 使用ssh连接远程服务器</h3><p>连接服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh zhangshuo@192.168.200.66  <span class="comment"># 内网直接连</span></span><br><span class="line">$ ssh zhangshuo@47.96.129.63 -p 6000 <span class="comment"># 从外网穿透 其中，-p 6000 为设置端口</span></span><br></pre></td></tr></table></figure>

<p>其中，zhangshuo为192.168.200.66机器上的用户，需要输入密码。</p>
<img src="/2020/04/30/ubuntu-ssh/ubuntu-ssh4.png">

<p>断开连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu通过Anaconda安装TensorFlow(CPU)的方法</title>
    <url>/2019/09/15/ubuntu-tensorflow/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍了在ubuntu16.04中通过anaconda安装tensorflow(CPU)的操作流程</p>
</blockquote>
<a id="more"></a>

<h3 id="1-安装anaconda"><a href="#1-安装anaconda" class="headerlink" title="1. 安装anaconda"></a>1. 安装anaconda</h3><p>（1）从清华镜像下载anaconda <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">链接</a></p>
<p>（2）在终端安装anaconda</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bash Anaconda3-5.2.0-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/u012318074/article/details/77074665" target="_blank" rel="noopener">参考</a></p>
<h3 id="2-从国内源建立虚拟环境tf"><a href="#2-从国内源建立虚拟环境tf" class="headerlink" title="2. 从国内源建立虚拟环境tf"></a>2. 从国内源建立虚拟环境tf</h3><p>（1）填加国内镜像源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge </span><br><span class="line">$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">$ conda config --<span class="built_in">set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure>

<p>（2）建立虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda create -n tf python=3.5</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/6679cdeb3513" target="_blank" rel="noopener">参考</a></p>
<h3 id="3-激活tf环境"><a href="#3-激活tf环境" class="headerlink" title="3. 激活tf环境"></a>3. 激活tf环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">source</span> activate tf</span><br></pre></td></tr></table></figure>
<p>conda使用方法：<a href="https://www.jianshu.com/p/eaee1fadc1e9" target="_blank" rel="noopener">参考</a></p>
<h3 id="4-从国内源安装tensorflow"><a href="#4-从国内源安装tensorflow" class="headerlink" title="4. 从国内源安装tensorflow"></a>4. 从国内源安装tensorflow</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pip install -i https://pypi.tuna.tsinghua.edu.cn/simple tensorflow</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/qq_17854471/article/details/89299311" target="_blank" rel="noopener">参考</a></p>
<h3 id="5-可能出现的问题"><a href="#5-可能出现的问题" class="headerlink" title="5. 可能出现的问题"></a>5. 可能出现的问题</h3><p><a href="https://blog.csdn.net/weixin_42081389/article/details/98185411" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#75--颜色分类</title>
    <url>/2020/04/19/leetcode75/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#75–颜色分类</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：颜色分类（中等）"><a href="#1-题目：颜色分类（中等）" class="headerlink" title="1.题目：颜色分类（中等）"></a>1.题目：颜色分类（中等）</h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对于所有 idx &lt; p0 : nums[idx &lt; p0] = 0</span></span><br><span class="line">        <span class="comment">// 对于所有 idx &gt; p2 : nums[idx &gt; p2] = 2</span></span><br><span class="line">        <span class="comment">// curr 是当前考虑元素的下标</span></span><br><span class="line">        <span class="keyword">int</span> p0 = <span class="number">0</span>, p2 = nums.<span class="built_in">size</span>() - <span class="number">1</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( curr &lt;= p2 ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( nums[curr] == <span class="number">0</span> ) &#123;</span><br><span class="line">                swap(nums[curr++], nums[p0++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( nums[curr] == <span class="number">2</span> ) &#123;</span><br><span class="line">                swap(nums[curr], nums[p2--]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> curr++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#74--搜索二维矩阵</title>
    <url>/2020/04/19/leetcode74/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#74–搜索二维矩阵</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：搜索二维矩阵（中等）"><a href="#1-题目：搜索二维矩阵（中等）" class="headerlink" title="1.题目：搜索二维矩阵（中等）"></a>1.题目：搜索二维矩阵（中等）</h3><p>编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<p>每行中的整数从左到右按升序排列。<br>每行的第一个整数大于前一行的最后一个整数。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:<br>matrix = [<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]<br>target = 3<br>输出: true</p>
</blockquote>
<h3 id="2-题解-二分法"><a href="#2-题解-二分法" class="headerlink" title="2.题解(二分法)"></a>2.题解(二分法)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( matrix.empty() || matrix[<span class="number">0</span>].empty() ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = matrix.<span class="built_in">size</span>() * matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( left &lt;= right ) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> num = matrix[mid / matrix[<span class="number">0</span>].<span class="built_in">size</span>()][mid % matrix[<span class="number">0</span>].<span class="built_in">size</span>()];</span><br><span class="line">            <span class="keyword">if</span> ( num == target ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( num &lt; target ) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( target &lt; num ) right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu中用zjunet连接浙大有线网</title>
    <url>/2019/09/18/ubuntu-zjunet/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍了在ubuntu20.04中通过zjunet工具连接浙大校园有线网的方法</p>
</blockquote>
<a id="more"></a>

<h3 id="1-下载-zjunet"><a href="#1-下载-zjunet" class="headerlink" title="1. 下载 zjunet"></a>1. 下载 zjunet</h3><p>在有网的环境下，下载 <a href="https://github.com/QSCTech/zjunet/releases" target="_blank" rel="noopener">zjunet_0.3.2-2_all.deb</a>；</p>
<h3 id="2-安装-zjunet"><a href="#2-安装-zjunet" class="headerlink" title="2. 安装 zjunet"></a>2. 安装 zjunet</h3><p>进入root权限，在命令行中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dpkg -i zjunet_0.3.2-2_all.deb</span><br></pre></td></tr></table></figure>

<p>若存在依赖关系问题无法安装，则在命令行中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt-get -f -y install</span><br></pre></td></tr></table></figure>

<p>修复依赖关系问题后，再次安装deb文件</p>
<h3 id="3-输入校园vpn账号密码"><a href="#3-输入校园vpn账号密码" class="headerlink" title="3. 输入校园vpn账号密码"></a>3. 输入校园vpn账号密码</h3><p>在命令行中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ zjunet user add 学号</span><br></pre></td></tr></table></figure>

<p>然后按照提示输入vpn账号和密码；</p>
<h3 id="4-连接有线网"><a href="#4-连接有线网" class="headerlink" title="4. 连接有线网"></a>4. 连接有线网</h3><p>插入网线后，在命令行输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ zjunet vpn -c</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cc98.org/topic/4801518" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#77--组合</title>
    <url>/2020/04/20/leetcode77/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#77–组合</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：组合（中等）"><a href="#1-题目：组合（中等）" class="headerlink" title="1.题目：组合（中等）"></a>1.题目：组合（中等）</h3><p>给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: n = 4, k = 2<br>输出:<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p>
</blockquote>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">// 路径</span></span><br><span class="line">        backtrack(res, path, n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结束条件</span></span><br><span class="line">        <span class="keyword">if</span> ( path.<span class="built_in">size</span>() == k ) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可选列表</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = start; i &lt;= n; ++i ) &#123;</span><br><span class="line">            path.push_back(i);</span><br><span class="line">            backtrack(res, path, n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu中kworker占用CPU过高的问题</title>
    <url>/2020/05/02/ubuntu-kworker/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍了在ubuntu20.04中解决kworker占用CPU过高问题的方法</p>
</blockquote>
<a id="more"></a>
<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h3><h4 id="1-配置"><a href="#1-配置" class="headerlink" title="(1) 配置"></a>(1) 配置</h4><p>电脑： HUAWEI matebook x pro 2019 (集显版本)<br>CPU： Intel® Core™ i5-8265U CPU @ 1.60GHz × 8 (64位)<br>显卡： Mesa Intel® UHD Graphics 620 (WHL GT2)<br>内存： 8G<br>硬盘： 512G SSD<br>系统： Windows 10 / Ubuntu 20.04 LTS 双系统</p>
<h4 id="2-问题"><a href="#2-问题" class="headerlink" title="(2) 问题"></a>(2) 问题</h4><p>在安装ubuntu20.04双系统后出现电脑发热，风扇一直转。即使不运行任何程序也是如此</p>
<h4 id="3-原因"><a href="#3-原因" class="headerlink" title="(3) 原因"></a>(3) 原因</h4><p>在终端中输入 <code>top</code> 命令检查各个进程的资源占用情况，发现，一个叫做<strong>kworker</strong>的进程占用了80%的CPU资源</p>
<h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h3><p>在终端中输入 su 并输入密码进入root权限之后，输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"disable"</span> &gt; /sys/firmware/acpi/interrupts/gpe6F</span><br></pre></td></tr></table></figure>

<p>即可解决问题，再使用 <code>top</code> 命令查看发现，<strong>kworker</strong>进程已经消失了</p>
<h3 id="3-设置开机自启动"><a href="#3-设置开机自启动" class="headerlink" title="3. 设置开机自启动"></a>3. 设置开机自启动</h3><p>为了避免每次开机都要进行上述的操作来kill掉<strong>kworker</strong>进程，可以通过将上述的命令设置为开机自启动命令<br>这样每次开机，系统就会自动帮我们执行上述命令，而无需手动操作</p>
<h4 id="1-建立-rc-local-service-文件"><a href="#1-建立-rc-local-service-文件" class="headerlink" title="(1) 建立 rc-local.service 文件"></a>(1) 建立 rc-local.service 文件</h4><p>在终端中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vi /etc/systemd/system/rc-local.service</span><br></pre></td></tr></table></figure>

<p>然后，复制以下内容到该文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=/etc/rc.local Compatibility</span><br><span class="line">ConditionPathExists=/etc/rc.local</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/etc/rc.local start</span><br><span class="line">TimeoutSec=0</span><br><span class="line">StandardOutput=tty</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">SysVStartPriority=99</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<h4 id="2-创建我们自定义的启动脚本"><a href="#2-创建我们自定义的启动脚本" class="headerlink" title="(2) 创建我们自定义的启动脚本"></a>(2) 创建我们自定义的启动脚本</h4><p>在终端中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vi /etc/rc.local</span><br></pre></td></tr></table></figure>

<p>在文件中写入需要自启动的命令<br><strong>注意：</strong> 所有的自启动命令都需要写在 <code>exit 0</code> 之前</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh -e</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># rc.local</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This script is executed at the end of each multiuser runlevel.</span></span><br><span class="line"><span class="comment"># Make sure that the script will "exit 0" on success or any other</span></span><br><span class="line"><span class="comment"># value on error.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In order to enable or disable this script just change the execution</span></span><br><span class="line"><span class="comment"># bits.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default this script does nothing.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"看到这行字，说明添加自启动脚本成功。"</span> &gt; /usr/<span class="built_in">local</span>/test.log <span class="comment"># 用于测试</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"disable"</span> &gt; /sys/firmware/acpi/interrupts/gpe6F</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

<h4 id="3-使启动脚本有效"><a href="#3-使启动脚本有效" class="headerlink" title="(3) 使启动脚本有效"></a>(3) 使启动脚本有效</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo chmod +x /etc/rc.local &amp;&amp; sudo systemctl <span class="built_in">enable</span> rc-local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务并检查服务</span></span><br><span class="line">$ sudo systemctl start rc-local.service</span><br><span class="line">$ sudo systemctl status rc-local.service</span><br></pre></td></tr></table></figure>

<p>若出现绿色字样，则设置成功</p>
<p>重新启动，再次用 <code>top</code> 命令检查CPU占用情况，发现<strong>kworker</strong>进程已经没有了，问题解决！</p>
<h3 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h3><p><a href="https://blog.csdn.net/qq_35868811/article/details/99679185" target="_blank" rel="noopener">结束kworker进程</a><br><a href="https://www.cnblogs.com/schips/p/10318078.html" target="_blank" rel="noopener">设置开机自启动</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划题目总结</title>
    <url>/2020/05/02/dp/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了动态规划方法在leetcode上的有关习题</p>
<a id="more"></a>
</blockquote>
<h3 id="1-leetcode上的相关题目"><a href="#1-leetcode上的相关题目" class="headerlink" title="1. leetcode上的相关题目"></a>1. leetcode上的相关题目</h3><table>
<thead>
<tr>
<th>题号</th>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td><a href="https://shuoshuo666.github.io/2020/03/21/leetcode5/">最长回文子串</a></td>
<td>中等</td>
</tr>
<tr>
<td>10</td>
<td><a href="https://shuoshuo666.github.io/2020/07/21/leetcode10/">正则表达式匹配</a></td>
<td>困难</td>
</tr>
<tr>
<td>42</td>
<td><a href="https://shuoshuo666.github.io/2020/07/24/leetcode42/">接雨水</a></td>
<td>困难</td>
</tr>
<tr>
<td>53</td>
<td><a href="https://shuoshuo666.github.io/2020/03/02/leetcode53/">最大子序和</a></td>
<td>简单</td>
</tr>
<tr>
<td>62</td>
<td><a href="https://shuoshuo666.github.io/2020/04/15/leetcode62/">不同路径</a></td>
<td>中等</td>
</tr>
<tr>
<td>63</td>
<td><a href="https://shuoshuo666.github.io/2020/04/16/leetcode63/">不同路径II</a></td>
<td>中等</td>
</tr>
<tr>
<td>64</td>
<td><a href="https://shuoshuo666.github.io/2020/04/16/leetcode64/">最小路径和</a></td>
<td>中等</td>
</tr>
<tr>
<td>70</td>
<td><a href="https://shuoshuo666.github.io/2020/03/03/leetcode70/">爬楼梯</a></td>
<td>简单</td>
</tr>
<tr>
<td>91</td>
<td><a href="https://shuoshuo666.github.io/2020/04/24/leetcode91/">解码方法</a></td>
<td>中等</td>
</tr>
<tr>
<td>96</td>
<td><a href="https://shuoshuo666.github.io/2020/04/30/leetcode96/">不同的二叉搜索树</a></td>
<td>中等</td>
</tr>
<tr>
<td>121</td>
<td><a href="https://shuoshuo666.github.io/2020/03/14/leetcode121/">买卖股票的最佳时机</a></td>
<td>简单</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法总结</title>
    <url>/2020/05/03/backtrack/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了回溯算法的基本框架以及leetcode上的有关习题</p>
<a id="more"></a>
</blockquote>
<h3 id="1-基本框架"><a href="#1-基本框架" class="headerlink" title="1. 基本框架"></a>1. 基本框架</h3><h4 id="0-内容来源"><a href="#0-内容来源" class="headerlink" title="(0) 内容来源:"></a>(0) 内容来源:</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484709&idx=1&sn=1c24a5c41a5a255000532e83f38f2ce4&chksm=9bd7fb2daca0723be888b30345e2c5e64649fc31a00b05c27a0843f349e2dd9363338d0dac61&scene=21#wechat_redirect" target="_blank" rel="noopener">链接</a></p>
<h4 id="1-基本框架-1"><a href="#1-基本框架-1" class="headerlink" title="(1) 基本框架"></a>(1) 基本框架</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<h3 id="2-leetcode上的相关题目"><a href="#2-leetcode上的相关题目" class="headerlink" title="2. leetcode上的相关题目"></a>2. leetcode上的相关题目</h3><table>
<thead>
<tr>
<th>题号</th>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>17</td>
<td><a href="https://shuoshuo666.github.io/2020/03/26/leetcode17/">电话号码的字母组合</a></td>
<td>中等</td>
</tr>
<tr>
<td>22</td>
<td><a href="https://shuoshuo666.github.io/2020/03/28/leetcode22/">括号生成</a></td>
<td>中等</td>
</tr>
<tr>
<td>39</td>
<td><a href="https://shuoshuo666.github.io/2020/04/09/leetcode39/">组合总和</a></td>
<td>中等</td>
</tr>
<tr>
<td>40</td>
<td><a href="https://shuoshuo666.github.io/2020/04/09/leetcode40/">组合总和II</a></td>
<td>中等</td>
</tr>
<tr>
<td>46</td>
<td><a href="https://shuoshuo666.github.io/2020/04/10/leetcode46/">全排列</a></td>
<td>中等</td>
</tr>
<tr>
<td>47</td>
<td><a href="https://shuoshuo666.github.io/2020/04/10/leetcode47/">全排列II</a></td>
<td>中等</td>
</tr>
<tr>
<td>77</td>
<td><a href="https://shuoshuo666.github.io/2020/04/20/leetcode77/">组合</a></td>
<td>中等</td>
</tr>
<tr>
<td>78</td>
<td><a href="https://shuoshuo666.github.io/2020/04/20/leetcode78/">子集</a></td>
<td>中等</td>
</tr>
<tr>
<td>79</td>
<td><a href="https://shuoshuo666.github.io/2020/04/21/leetcode79/">单词搜索</a></td>
<td>中等</td>
</tr>
<tr>
<td>90</td>
<td><a href="https://shuoshuo666.github.io/2020/04/24/leetcode90/">子集II</a></td>
<td>中等</td>
</tr>
<tr>
<td>93</td>
<td><a href="https://shuoshuo666.github.io/2020/04/25/leetcode93/">复原IP地址</a></td>
<td>中等</td>
</tr>
<tr>
<td>113</td>
<td><a href="https://shuoshuo666.github.io/2020/05/09/leetcode113/">路径总和II</a></td>
<td>中等</td>
</tr>
<tr>
<td>129</td>
<td><a href="https://shuoshuo666.github.io/2020/05/12/leetcode129/">求根到叶子节点数字之和</a></td>
<td>中等</td>
</tr>
<tr>
<td>257</td>
<td><a href="https://shuoshuo666.github.io/2020/05/23/leetcode257/">二叉树的所有路径</a></td>
<td>简单</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>广度优先搜索总结</title>
    <url>/2020/05/04/bfs/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了广度优先搜索的基本框架以及leetcode上的有关习题</p>
<a id="more"></a>
</blockquote>
<h3 id="1-基本框架"><a href="#1-基本框架" class="headerlink" title="1. 基本框架"></a>1. 基本框架</h3><h4 id="0-内容来源"><a href="#0-内容来源" class="headerlink" title="(0) 内容来源:"></a>(0) 内容来源:</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485134&idx=1&sn=fd345f8a93dc4444bcc65c57bb46fc35&chksm=9bd7f8c6aca071d04c4d383f96f2b567ad44dc3e67d1c3926ec92d6a3bcc3273de138b36a0d9&scene=21#wechat_redirect" target="_blank" rel="noopener">链接</a></p>
<h4 id="1-基本框架-1"><a href="#1-基本框架-1" class="headerlink" title="(1) 基本框架"></a>(1) 基本框架</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line"></span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj())</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-leetcode上的相关题目"><a href="#2-leetcode上的相关题目" class="headerlink" title="2. leetcode上的相关题目"></a>2. leetcode上的相关题目</h3><table>
<thead>
<tr>
<th>题号</th>
<th>题目</th>
<th>难度</th>
</tr>
</thead>
<tbody><tr>
<td>101</td>
<td><a href="https://shuoshuo666.github.io/2020/03/10/leetcode101/">对称二叉树</a></td>
<td>简单</td>
</tr>
<tr>
<td>102</td>
<td><a href="https://shuoshuo666.github.io/2020/04/30/leetcode102/">二叉树的层序遍历</a></td>
<td>中等</td>
</tr>
<tr>
<td>103</td>
<td><a href="https://shuoshuo666.github.io/2020/04/30/leetcode103/">二叉树的锯齿形层次遍历</a></td>
<td>中等</td>
</tr>
<tr>
<td>107</td>
<td><a href="https://shuoshuo666.github.io/2020/03/11/leetcode107/">二叉树的层次遍历II</a></td>
<td>简单</td>
</tr>
<tr>
<td>111</td>
<td><a href="https://shuoshuo666.github.io/2020/03/13/leetcode111/">二叉树的最小深度</a></td>
<td>简单</td>
</tr>
<tr>
<td>199</td>
<td><a href="https://shuoshuo666.github.io/2020/05/16/leetcode199/">二叉树的右视图</a></td>
<td>中等</td>
</tr>
<tr>
<td>429</td>
<td><a href="https://shuoshuo666.github.io/2020/05/27/leetcode429/">N叉树的层序遍历</a></td>
<td>中等</td>
</tr>
<tr>
<td>513</td>
<td><a href="https://shuoshuo666.github.io/2020/06/02/leetcode513/">找树左下角的值</a></td>
<td>中等</td>
</tr>
<tr>
<td>515</td>
<td><a href="https://shuoshuo666.github.io/2020/06/03/leetcode515/">在每个树行中找最大值</a></td>
<td>中等</td>
</tr>
<tr>
<td>559</td>
<td><a href="https://shuoshuo666.github.io/2020/06/07/leetcode559/">N叉树的最大深度</a></td>
<td>简单</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#105--从前序与中序遍历序列构造二叉树</title>
    <url>/2020/05/08/leetcode105/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#105–从前序与中序遍历序列构造二叉树</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：从前序与中序遍历序列构造二叉树（中等）"><a href="#1-题目：从前序与中序遍历序列构造二叉树（中等）" class="headerlink" title="1.题目：从前序与中序遍历序列构造二叉树（中等）"></a>1.题目：从前序与中序遍历序列构造二叉树（中等）</h3><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(preorder.cbegin(), preorder.cend(), inorder.cbegin(), inorder.cend());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> citer = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator; <span class="comment">// vector&lt;int&gt;::const_iterator的类型别名</span></span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(citer preStart, citer preEnd, citer inStart, citer inEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( preStart == preEnd ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootValue = *preStart; <span class="comment">// 根节点的值</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootValue); <span class="comment">// 建立根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中序遍历中找到根节点的位置</span></span><br><span class="line">        <span class="keyword">auto</span> iter = inStart;</span><br><span class="line">        <span class="keyword">while</span> ( *iter != rootValue ) ++iter;</span><br><span class="line">        <span class="keyword">int</span> leftCount = iter - inStart; <span class="comment">// 左子树节点数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归建立左子树与右子树</span></span><br><span class="line">        root-&gt;left = helper(preStart + <span class="number">1</span>, preStart + <span class="number">1</span> + leftCount, inStart, iter);</span><br><span class="line">        root-&gt;right = helper(preStart + <span class="number">1</span> + leftCount, preEnd, iter + <span class="number">1</span>, inEnd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#99--恢复二叉搜索树</title>
    <url>/2020/05/08/leetcode99/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#99–恢复二叉搜索树</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：恢复二叉搜索树（困难）"><a href="#1-题目：恢复二叉搜索树（困难）" class="headerlink" title="1.题目：恢复二叉搜索树（困难）"></a>1.题目：恢复二叉搜索树（困难）</h3><p>二叉搜索树中的两个节点被错误地交换。</p>
<p>请在不改变其结构的情况下，恢复这棵树。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-中序遍历-递归"><a href="#1-中序遍历-递归" class="headerlink" title="(1) 中序遍历(递归)"></a>(1) 中序遍历(递归)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        TreeNode* temp = <span class="keyword">new</span> TreeNode(firstNode-&gt;val);</span><br><span class="line">        firstNode-&gt;val = secondNode-&gt;val;</span><br><span class="line">        secondNode-&gt;val = temp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* firstNode = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* secondNode = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* preNode = <span class="keyword">new</span> TreeNode(INT32_MIN);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( node == <span class="literal">nullptr</span> ) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(node-&gt;left);</span><br><span class="line">        <span class="comment">// ********操作********</span></span><br><span class="line">        <span class="keyword">if</span> ( firstNode == <span class="literal">nullptr</span> &amp;&amp; preNode-&gt;val &gt; node-&gt;val ) firstNode = preNode;</span><br><span class="line">        <span class="keyword">if</span> ( firstNode != <span class="literal">nullptr</span> &amp;&amp; preNode-&gt;val &gt; node-&gt;val ) secondNode = node;</span><br><span class="line">        preNode = node;</span><br><span class="line">        <span class="comment">// *******************</span></span><br><span class="line">        inOrder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-中序遍历-迭代"><a href="#2-中序遍历-迭代" class="headerlink" title="(2) 中序遍历(迭代)"></a>(2) 中序遍历(迭代)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; auxStack;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        TreeNode* firstNode = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* secondNode = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* preNode = <span class="keyword">new</span> TreeNode(INT32_MIN);</span><br><span class="line">        <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> || !auxStack.empty() ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                auxStack.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = auxStack.top();</span><br><span class="line">            auxStack.pop();</span><br><span class="line">            <span class="comment">// ********操作********</span></span><br><span class="line">            <span class="keyword">if</span> ( firstNode == <span class="literal">nullptr</span> &amp;&amp; preNode-&gt;val &gt; node-&gt;val ) firstNode = preNode;</span><br><span class="line">            <span class="keyword">if</span> ( firstNode != <span class="literal">nullptr</span> &amp;&amp; preNode-&gt;val &gt; node-&gt;val ) secondNode = node;</span><br><span class="line">            preNode = node;</span><br><span class="line">            <span class="comment">// *******************</span></span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换两个节点</span></span><br><span class="line">        TreeNode* temp = <span class="keyword">new</span> TreeNode(firstNode-&gt;val);</span><br><span class="line">        firstNode-&gt;val = secondNode-&gt;val;</span><br><span class="line">        secondNode-&gt;val = temp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#106--从中序与后序遍历序列构造二叉树</title>
    <url>/2020/05/09/leetcode106/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#106–从中序与后序遍历序列构造二叉树</p>
<a id="more"></a>
</blockquote>
<h3 id="1-题目：从中序与后序遍历序列构造二叉树（中等）"><a href="#1-题目：从中序与后序遍历序列构造二叉树（中等）" class="headerlink" title="1.题目：从中序与后序遍历序列构造二叉树（中等）"></a>1.题目：从中序与后序遍历序列构造二叉树（中等）</h3><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>注意:<br>你可以假设树中没有重复的元素。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(inorder.cbegin(), inorder.cend(), postorder.cbegin(), postorder.cend());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> citer = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(citer inStart, citer inEnd, citer postStart, citer postEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( inStart == inEnd ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rootValue = *(postEnd - <span class="number">1</span>); <span class="comment">// 根节点的值</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(rootValue); <span class="comment">// 建立根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在中序遍历中找到根节点的位置</span></span><br><span class="line">        citer iter = inStart;</span><br><span class="line">        <span class="keyword">while</span> ( *iter != rootValue ) ++iter;</span><br><span class="line">        <span class="keyword">int</span> leftCount = iter - inStart;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归建立左子树与右子树</span></span><br><span class="line">        root-&gt;left = helper(inStart, iter, postStart, postStart + leftCount);</span><br><span class="line">        root-&gt;right = helper(iter + <span class="number">1</span>, inEnd, postStart + leftCount, postEnd - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#113--路径总和II</title>
    <url>/2020/05/09/leetcode113/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#113–路径总和II</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：路径总和II（简单）"><a href="#1-题目：路径总和II（简单）" class="headerlink" title="1.题目：路径总和II（简单）"></a>1.题目：路径总和II（简单）</h3><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        dfs(res, path, root, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; sum == root-&gt;val ) &#123;</span><br><span class="line">            path.push_back(root-&gt;val);</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            path.pop_back();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span> ) dfs(res, path, root-&gt;left, sum - root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span> ) dfs(res, path, root-&gt;right, sum - root-&gt;val);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#114--二叉树展开为链表</title>
    <url>/2020/05/10/leetcode114/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#114–二叉树展开为链表</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树展开为链表（中等）"><a href="#1-题目：二叉树展开为链表（中等）" class="headerlink" title="1.题目：二叉树展开为链表（中等）"></a>1.题目：二叉树展开为链表（中等）</h3><p>给定一个二叉树，原地将它展开为链表。</p>
<h3 id="2-题解-前序遍历"><a href="#2-题解-前序遍历" class="headerlink" title="2.题解(前序遍历)"></a>2.题解(前序遍历)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; auxStack;</span><br><span class="line"></span><br><span class="line">        TreeNode* preBegin = <span class="keyword">new</span> TreeNode(<span class="number">-1</span>);</span><br><span class="line">        preBegin-&gt;right = root;</span><br><span class="line"></span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        TreeNode* ptr = preBegin;</span><br><span class="line">        <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> || !auxStack.empty() ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                auxStack.push(node-&gt;right);</span><br><span class="line">                <span class="comment">// ****操作****</span></span><br><span class="line">                ptr-&gt;right = node;</span><br><span class="line">                ptr = ptr-&gt;right;</span><br><span class="line">                <span class="comment">// ***********</span></span><br><span class="line">                TreeNode* temp = node-&gt;left;</span><br><span class="line">                node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                node = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            node = auxStack.top();</span><br><span class="line">            auxStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#116--填充每个节点的下一个右侧节点指针</title>
    <url>/2020/05/10/leetcode116/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#116–填充每个节点的下一个右侧节点指针</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：填充每个节点的下一个右侧节点指针（中等）"><a href="#1-题目：填充每个节点的下一个右侧节点指针（中等）" class="headerlink" title="1.题目：填充每个节点的下一个右侧节点指针（中等）"></a>1.题目：填充每个节点的下一个右侧节点指针（中等）</h3><p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>初始状态下，所有 next 指针都被设置为 NULL。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> root;</span><br><span class="line">		Node* pre = root; <span class="comment">// 每一层的左边第一个节点</span></span><br><span class="line">		<span class="comment">// 循环条件是当前节点的left不为空，当只有根节点</span></span><br><span class="line">		<span class="comment">// 或所有叶子节点都出串联完后循环就退出了</span></span><br><span class="line">		<span class="keyword">while</span> ( pre-&gt;left != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">			Node* tmp = pre; <span class="comment">// 该层的每一个节点</span></span><br><span class="line">			<span class="keyword">while</span> ( tmp != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">				<span class="comment">// 将tmp的左右节点都串联起来</span></span><br><span class="line">				<span class="comment">// 注:外层循环已经判断了当前节点的left不为空</span></span><br><span class="line">				tmp-&gt;left-&gt;next = tmp-&gt;right;</span><br><span class="line">				<span class="comment">// 下一个不为空说明上一层已经帮我们完成串联了</span></span><br><span class="line">				<span class="keyword">if</span> ( tmp-&gt;next != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">					tmp-&gt;right-&gt;next = tmp-&gt;next-&gt;left;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 继续右边遍历</span></span><br><span class="line">				tmp = tmp-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 从下一层的最左边开始遍历</span></span><br><span class="line">			pre = pre-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#117--填充每个节点的下一个右侧节点指针II</title>
    <url>/2020/05/11/leetcode117/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#117–填充每个节点的下一个右侧节点指针II</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：填充每个节点的下一个右侧节点指针II（中等）"><a href="#1-题目：填充每个节点的下一个右侧节点指针II（中等）" class="headerlink" title="1.题目：填充每个节点的下一个右侧节点指针II（中等）"></a>1.题目：填充每个节点的下一个右侧节点指针II（中等）</h3><p>给定一个二叉树<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>初始状态下，所有 next 指针都被设置为 NULL。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> root;</span><br><span class="line">        Node* curRoot = root;</span><br><span class="line">        Node* dummy = <span class="keyword">new</span> Node(<span class="number">-1</span>); <span class="comment">// 哑节点十分精髓！！！</span></span><br><span class="line">        Node* pre = dummy; <span class="comment">// 每层的第一个节点</span></span><br><span class="line">        <span class="keyword">while</span> ( curRoot != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( curRoot-&gt;left ) &#123;</span><br><span class="line">                pre-&gt;next = curRoot-&gt;left;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( curRoot-&gt;right )&#123;</span><br><span class="line">                pre-&gt;next = curRoot-&gt;right;</span><br><span class="line">                pre = pre-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( curRoot-&gt;next != <span class="literal">nullptr</span> ) curRoot = curRoot-&gt;next;</span><br><span class="line">            <span class="comment">//遍历到某层的最后一个节点就跳到下一层</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( curRoot-&gt;next == <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                curRoot = dummy-&gt;next;</span><br><span class="line">                dummy-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                pre = dummy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#124--二叉树中的最大路径和</title>
    <url>/2020/05/11/leetcode124/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#124–二叉树中的最大路径和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树中的最大路径和（困难）"><a href="#1-题目：二叉树中的最大路径和（困难）" class="headerlink" title="1.题目：二叉树中的最大路径和（困难）"></a>1.题目：二叉树中的最大路径和（困难）</h3><p>给定一个非空二叉树，返回其最大路径和。</p>
<p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> maxValue = INT32_MIN;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回经过root的单边分支最大和， 即Math.max(root, root+left, root+right)</span></span><br><span class="line"><span class="comment">     * @param root</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//计算左边分支最大值，左边分支如果为负数还不如不选择</span></span><br><span class="line">        <span class="keyword">int</span> leftMax = <span class="built_in">max</span>(<span class="number">0</span>, dfs(root-&gt;left));</span><br><span class="line">        <span class="comment">//计算右边分支最大值，右边分支如果为负数还不如不选择</span></span><br><span class="line">        <span class="keyword">int</span> rightMax = <span class="built_in">max</span>(<span class="number">0</span>, dfs(root-&gt;right));</span><br><span class="line">        <span class="comment">//left-&gt;root-&gt;right 作为路径与历史最大值做比较</span></span><br><span class="line">        maxValue = <span class="built_in">max</span>(maxValue, root-&gt;val + leftMax + rightMax);</span><br><span class="line">        <span class="comment">// 返回经过root的单边最大分支给上游</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(leftMax, rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#129--求根到叶子节点数字之和</title>
    <url>/2020/05/12/leetcode129/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#129–求根到叶子节点数字之和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：求根到叶子节点数字之和（中等）"><a href="#1-题目：求根到叶子节点数字之和（中等）" class="headerlink" title="1.题目：求根到叶子节点数字之和（中等）"></a>1.题目：求根到叶子节点数字之和（中等）</h3><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p>
<p>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。</p>
<p>计算从根到叶子节点生成的所有数字之和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        dfs(root, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> accumulate(res.cbegin(), res.cend(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res, <span class="keyword">int</span> pathSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            res.push_back(<span class="number">10</span> * pathSum + node-&gt;val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;left != <span class="literal">nullptr</span> ) dfs(node-&gt;left, res, <span class="number">10</span> * pathSum + node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;right != <span class="literal">nullptr</span> ) dfs(node-&gt;right, res, <span class="number">10</span> * pathSum + node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#144--二叉树的前序遍历</title>
    <url>/2020/05/13/leetcode144/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#144–二叉树的前序遍历</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树的前序遍历（中等）"><a href="#1-题目：二叉树的前序遍历（中等）" class="headerlink" title="1.题目：二叉树的前序遍历（中等）"></a>1.题目：二叉树的前序遍历（中等）</h3><p>给定一个二叉树，返回它的 前序 遍历。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; auxStack;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> || !auxStack.empty() ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                auxStack.push(node-&gt;right);</span><br><span class="line">                res.push_back(node-&gt;val);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = auxStack.top();</span><br><span class="line">            auxStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#145--二叉树的后序遍历</title>
    <url>/2020/05/14/leetcode145/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#145–二叉树的后序遍历</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树的后序遍历（困难）"><a href="#1-题目：二叉树的后序遍历（困难）" class="headerlink" title="1.题目：二叉树的后序遍历（困难）"></a>1.题目：二叉树的后序遍历（困难）</h3><p>给定一个二叉树，返回它的 后序 遍历。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> ( !stk.empty() ) &#123;</span><br><span class="line">            TreeNode* node = stk.top();</span><br><span class="line">            <span class="keyword">if</span> ( node == <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                res.push_back(stk.top()-&gt;val);</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">if</span> ( node-&gt;right ) stk.push(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> ( node-&gt;left ) stk.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#173--二叉搜索树迭代器</title>
    <url>/2020/05/15/leetcode173/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#173–二叉搜索树迭代器</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉搜索树迭代器（中等）"><a href="#1-题目：二叉搜索树迭代器（中等）" class="headerlink" title="1.题目：二叉搜索树迭代器（中等）"></a>1.题目：二叉搜索树迭代器（中等）</h3><p>实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。</p>
<p>调用 next() 将返回二叉搜索树中的下一个最小的数。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-中序遍历"><a href="#1-中序遍历" class="headerlink" title="(1) 中序遍历"></a>(1) 中序遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BSTIterator(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> || !stk.empty() ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                stk.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            midorder.push_back(node-&gt;val);</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        iter = midorder.cbegin();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iter != midorder.cend();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; midorder;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator iter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-受控的中序遍历"><a href="#2-受控的中序遍历" class="headerlink" title="(2) 受控的中序遍历"></a>(2) 受控的中序遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    BSTIterator(TreeNode* root) &#123;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        leftInorder(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode* tmp = stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">        <span class="keyword">if</span> ( tmp-&gt;right != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            leftInorder(tmp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** @return whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">leftInorder</span><span class="params">( TreeNode* node )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            stk.push(node);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#199--二叉树的右视图</title>
    <url>/2020/05/16/leetcode199/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#199–二叉树的右视图</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树的右视图（中等）"><a href="#1-题目：二叉树的右视图（中等）" class="headerlink" title="1.题目：二叉树的右视图（中等）"></a>1.题目：二叉树的右视图（中等）</h3><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-BFS"><a href="#1-BFS" class="headerlink" title="(1) BFS"></a>(1) BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(node);</span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() ) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; sz; ++i ) &#123;</span><br><span class="line">                TreeNode* tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> ( tmp-&gt;left != <span class="literal">nullptr</span> ) q.push(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> ( tmp-&gt;right != <span class="literal">nullptr</span> ) q.push(tmp-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> ( i == sz - <span class="number">1</span> ) res.push_back(tmp-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-DFS"><a href="#2-DFS" class="headerlink" title="(2) DFS"></a>(2) DFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        dfs(root, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="keyword">int</span> depth, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( node == <span class="literal">nullptr</span> ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> ( depth == res.<span class="built_in">size</span>() ) res.push_back(node-&gt;val);</span><br><span class="line">        ++depth;</span><br><span class="line">        dfs(node-&gt;right, depth, res);</span><br><span class="line">        dfs(node-&gt;left, depth, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>BFS</tag>
        <tag>树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#222--完全二叉树的节点个数</title>
    <url>/2020/05/17/leetcode222/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#222–完全二叉树的节点个数</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：完全二叉树的节点个数（中等）"><a href="#1-题目：完全二叉树的节点个数（中等）" class="headerlink" title="1.题目：完全二叉树的节点个数（中等）"></a>1.题目：完全二叉树的节点个数（中等）</h3><p>给出一个完全二叉树，求出该树的节点个数。</p>
<p>说明：<br>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-DFS"><a href="#1-DFS" class="headerlink" title="(1) DFS"></a>(1) DFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">1</span>;</span><br><span class="line">        dfs(root, <span class="number">1</span>, <span class="built_in">max</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="keyword">int</span> count, <span class="keyword">int</span>&amp; <span class="built_in">max</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( node == <span class="literal">nullptr</span> ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> ( count &gt; <span class="built_in">max</span> ) <span class="built_in">max</span> = count;</span><br><span class="line">        dfs(node-&gt;left, <span class="number">2</span> * count, <span class="built_in">max</span>);</span><br><span class="line">        dfs(node-&gt;right, <span class="number">2</span> * count + <span class="number">1</span>, <span class="built_in">max</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-递归"><a href="#2-递归" class="headerlink" title="(2) 递归"></a>(2) 递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> left = countLevel(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = countLevel(root-&gt;right);</span><br><span class="line">        <span class="comment">// 若left == right，则左子树满了</span></span><br><span class="line">        <span class="keyword">if</span> ( left == right ) <span class="keyword">return</span> countNodes(root-&gt;right) + <span class="built_in">pow</span>(<span class="number">2</span>, left);</span><br><span class="line">        <span class="comment">// left &gt; right，则右子树满了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> countNodes(root-&gt;left) + <span class="built_in">pow</span>(<span class="number">2</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="comment">// 计算完全二叉树的层数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countLevel</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( root != <span class="literal">nullptr</span> )&#123;</span><br><span class="line">            level++;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#226--翻转二叉树</title>
    <url>/2020/05/18/leetcode226/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#226–翻转二叉树</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：翻转二叉树（简单）"><a href="#1-题目：翻转二叉树（简单）" class="headerlink" title="1.题目：翻转二叉树（简单）"></a>1.题目：翻转二叉树（简单）</h3><p>翻转一棵二叉树。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="(1) 递归"></a>(1) 递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        invertTree(root-&gt;left);</span><br><span class="line">        invertTree(root-&gt;right);</span><br><span class="line">        TreeNode* tmp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = tmp;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-BFS"><a href="#2-BFS" class="headerlink" title="(2) BFS"></a>(2) BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() ) &#123;</span><br><span class="line">            TreeNode* node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            TreeNode* tmp = node-&gt;left;</span><br><span class="line">            node-&gt;left = node-&gt;right;</span><br><span class="line">            node-&gt;right = tmp;</span><br><span class="line">            <span class="keyword">if</span> ( node-&gt;left != <span class="literal">nullptr</span> ) q.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> ( node-&gt;right != <span class="literal">nullptr</span> ) q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2020/05/18/sort/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了常用的排序算法</p>
</blockquote>
<a id="more"></a>

<h3 id="1-排序类算法的模板"><a href="#1-排序类算法的模板" class="headerlink" title="1. 排序类算法的模板"></a>1. 排序类算法的模板</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体的算法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对元素进行比较</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.compareTo(w) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换数组中的两个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable t = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在单行打印数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Comparable comparable : a) System.out.print(comparable + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试元素是否有序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( less(a[i], a[i - <span class="number">1</span>]) ) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从输入读取字符串，将它们排序并输出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入待排序数组元素，以空格分隔："</span>);</span><br><span class="line">        String str = in.nextLine();</span><br><span class="line">        String[] arr = str.split(<span class="string">" "</span>);</span><br><span class="line">        Integer[] a = <span class="keyword">new</span> Integer[arr.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            a[j] = Integer.parseInt(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a);</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a)</span></span>;</span><br><span class="line">        show(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-排序算法"><a href="#2-排序算法" class="headerlink" title="2. 排序算法"></a>2. 排序算法</h3><h4 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="(1) 选择排序"></a>(1) 选择排序</h4><p><strong>动画演示</strong></p>
<img src="/2020/05/18/sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" class>

<p><strong>特点</strong></p>
<ol>
<li><p>运行时间和输入无关</p>
</li>
<li><p>数据移动最少：对于长度为N的数组，选择排序需要大约N<sup>2</sup>/2次比较和N次交换</p>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i ) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; ++j ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( less(a[j], a[minIndex]) ) minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">        exch(a, i, minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="(2) 插入排序"></a>(2) 插入排序</h4><h5 id="I-一般的插入排序"><a href="#I-一般的插入排序" class="headerlink" title="(I) 一般的插入排序"></a>(I) 一般的插入排序</h5><p><strong>动画演示</strong></p>
<img src="/2020/05/18/sort/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" class>

<p><strong>特点</strong></p>
<ol>
<li><p>对于随机排列的长度为N且主键不重复的数组，<strong>平均</strong>情况下插入排序需要 ~N<sup>2</sup>/4次<strong>比较</strong>以及 ~N<sup>2</sup>/4<strong>交换</strong>；<strong>最坏</strong>情况下需要 ~N<sup>2</sup>/2次<strong>比较</strong>和 ~N<sup>2</sup>/2次<strong>交换</strong>；<strong>最好</strong>情况下需要 N-1 次<strong>比较</strong>和0次<strong>交换</strong></p>
</li>
<li><p>插入排序中需要的<strong>交换</strong>操作和数组中倒置的数量相同，需要的<strong>比较</strong>次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一</p>
</li>
<li><p>插入排序对于<strong>部分有序</strong>的数组十分高效，也很适合<strong>小规模数组</strong></p>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i ) &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j], a[j - <span class="number">1</span>]); --j ) &#123;</span><br><span class="line">            exch(a, j, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="II-希尔排序"><a href="#II-希尔排序" class="headerlink" title="(II) 希尔排序"></a>(II) 希尔排序</h5><p><strong>动画演示</strong></p>
<img src="/2020/05/18/sort/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.gif" class>

<p><strong>特点</strong></p>
<p>希尔排序比选择排序和插入排序快得多，并且数组越大，优势越大</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( h &lt; N / <span class="number">3</span> ) h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( h &gt;= <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = h; i &lt; N; ++i ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j], a[j - h]); j -= h ) &#123;</span><br><span class="line">                exch(a, j, j - h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="(3) 归并排序"></a>(3) 归并排序</h4><p><strong>动画演示</strong></p>
<img src="/2020/05/18/sort/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif" class>

<p><strong>特点</strong></p>
<ol>
<li><p>归并排序所需要的时间和NlogN成正比</p>
</li>
<li><p>辅助数组所使用的额外空间和N的大小成正比</p>
</li>
</ol>
<p><strong>代码实现</strong></p>
<h5 id="I-自顶向下的归并排序"><a href="#I-自顶向下的归并排序" class="headerlink" title="(I) 自顶向下的归并排序"></a>(I) 自顶向下的归并排序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux; <span class="comment">// 归并所需的辅助数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自顶向下的归并排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">    sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( left &gt;= right ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    sort(a, left, mid);</span><br><span class="line">    sort(a, mid + <span class="number">1</span>, right);</span><br><span class="line">    merge(a, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原地归并</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 归并左边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid 分治边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 归并右边界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将 a[left, right] 拷贝到 aux[left, right]</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> k = left; k &lt;= right; ++k ) &#123;</span><br><span class="line">        aux[k] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 归并回到 a[left, right]</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> k = left; k &lt;= right; ++k ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( i &gt; mid ) a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( j &gt; right ) a[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( less(aux[j], aux[i]) ) a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span> a[k] = aux[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="II-自底向上的归并排序"><a href="#II-自底向上的归并排序" class="headerlink" title="(II) 自底向上的归并排序"></a>(II) 自底向上的归并排序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自底向上的归并排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N; sz = sz + sz ) &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> left = <span class="number">0</span>; left &lt; N - sz; left += sz + sz ) &#123;</span><br><span class="line">            merge(a, left, left + sz - <span class="number">1</span>, Math.min(left + sz + sz - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="(4) 快速排序"></a>(4) 快速排序</h4><p><strong>动画演示</strong></p>
<img src="/2020/05/18/sort/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.gif" class>

<p><strong>特点</strong></p>
<p>快速排序是最快的通用排序算法</p>
<p><strong>代码实现</strong></p>
<h5 id="I-一般的快速排序"><a href="#I-一般的快速排序" class="headerlink" title="(I) 一般的快速排序"></a>(I) 一般的快速排序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( left &gt;= right ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> j = partition(a, left, right);</span><br><span class="line">    sort(a, left, j - <span class="number">1</span>);</span><br><span class="line">    sort(a, j + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序的切分</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 待排序子数组左边界</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 待排序子数组右边界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = right + <span class="number">1</span>;</span><br><span class="line">    Comparable v = a[left]; <span class="comment">// 切分元素</span></span><br><span class="line">    <span class="keyword">while</span> ( <span class="keyword">true</span> ) &#123;</span><br><span class="line">        <span class="keyword">while</span> ( less(a[++i], v) ) <span class="keyword">if</span> ( i == right ) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> ( less(v, a[--j]) ) <span class="keyword">if</span> ( j == left ) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( i &gt;= j ) <span class="keyword">break</span>;</span><br><span class="line">        exch(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    exch(a, left, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="II-三向切分的快速排序"><a href="#II-三向切分的快速排序" class="headerlink" title="(II) 三向切分的快速排序"></a>(II) 三向切分的快速排序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三向切分的快速排序</span></span><br><span class="line"><span class="comment"> * 用于存在 大量重复元素 的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( left &gt;= right ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> small = left, i = left + <span class="number">1</span>, big = right;</span><br><span class="line">    Comparable v = a[left];</span><br><span class="line">    <span class="comment">// 索引small左侧的元素均小于v，索引big右侧的元素均大于v</span></span><br><span class="line">    <span class="comment">// [small, big]中的元素均等于v</span></span><br><span class="line">    <span class="keyword">while</span> ( i &lt;= big ) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = a[i].compareTo(v);</span><br><span class="line">        <span class="keyword">if</span> ( cmp &lt; <span class="number">0</span> ) exch(a, small++, i++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( cmp &gt; <span class="number">0</span> ) exch(a, i, big--);</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, left, small - <span class="number">1</span>);</span><br><span class="line">    sort(a, big + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="(5) 堆排序"></a>(5) 堆排序</h4><p><strong>动画演示</strong></p>
<img src="/2020/05/18/sort/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" class>

<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="comment">// 堆的构造</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; --k ) &#123;</span><br><span class="line">        sink(a, k, N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下沉排序</span></span><br><span class="line">    <span class="keyword">while</span> ( N &gt; <span class="number">1</span> ) &#123;</span><br><span class="line">        exch(a, <span class="number">1</span>, N--);</span><br><span class="line">        sink(a, <span class="number">1</span>, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由下至上的堆有序化（下沉）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 破坏堆有序元素的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> N 待排序数组的最大索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(Comparable[] a, <span class="keyword">int</span> k, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">2</span> * k &lt;= N ) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">        <span class="keyword">if</span> ( j &lt; N &amp;&amp; less(a, j, j + <span class="number">1</span>) ) j++;</span><br><span class="line">        <span class="keyword">if</span> ( !less(a, k, j) ) <span class="keyword">break</span>;</span><br><span class="line">        exch(a, k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对元素进行比较</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 堆中两个元素的比较</span></span><br><span class="line">    <span class="keyword">return</span> a[i - <span class="number">1</span>].compareTo(a[j - <span class="number">1</span>]) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换数组中的两个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    Comparable t = a[i - <span class="number">1</span>];</span><br><span class="line">    a[i - <span class="number">1</span>] = a[j - <span class="number">1</span>];</span><br><span class="line">    a[j - <span class="number">1</span>] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-基数排序"><a href="#6-基数排序" class="headerlink" title="(6) 基数排序"></a>(6) 基数排序</h4><p><strong>动画演示</strong></p>
<img src="/2020/05/18/sort/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.gif" class>

<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 得到数组中最大的数的位数</span></span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];  <span class="comment">// 假设第一个数是最大数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxLength = (max + <span class="string">""</span>).length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 定义一个二维数组，表示10个桶，每个桶就是一个一维数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 定义一个一维数组，记录每个桶中存放了多少数据</span></span><br><span class="line">    <span class="keyword">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">// 4. 针对每个元素的对应位进行排序，第一次是个位、第二次是十位。。。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 取出每个元素对应位的值</span></span><br><span class="line">            <span class="keyword">int</span> digitOfElement = arr[j] / n % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 放入对应的桶中</span></span><br><span class="line">            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">            bucketElementCounts[digitOfElement]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来的数组)</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketElementCounts.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucketElementCounts[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketElementCounts[j]; k++) &#123;</span><br><span class="line">                    arr[index++] = bucket[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            bucketElementCounts[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-各种排序算法的性能特点"><a href="#3-各种排序算法的性能特点" class="headerlink" title="3. 各种排序算法的性能特点"></a>3. 各种排序算法的性能特点</h3><table>
<thead>
<tr>
<th>算法</th>
<th>是否稳定</th>
<th>是否为原地排序</th>
<th>时间复杂度(平均)</th>
<th>时间复杂度(最好)</th>
<th>时间复杂度(最坏)</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>选择排序</td>
<td>否</td>
<td>是</td>
<td>N<sup>2</sup></td>
<td>N<sup>2</sup></td>
<td>N<sup>2</sup></td>
<td>1</td>
</tr>
<tr>
<td>插入排序</td>
<td>是</td>
<td>是</td>
<td>N<sup>2</sup></td>
<td>N</td>
<td>N<sup>2</sup></td>
<td>1</td>
</tr>
<tr>
<td>希尔排序</td>
<td>否</td>
<td>是</td>
<td>N<sup>1.3</sup></td>
<td>N</td>
<td>N<sup>2</sup></td>
<td>1</td>
</tr>
<tr>
<td>归并排序</td>
<td>是</td>
<td>否</td>
<td>NlogN</td>
<td>NlogN</td>
<td>NlogN</td>
<td>N</td>
</tr>
<tr>
<td>快速排序</td>
<td>否</td>
<td>是</td>
<td>NlogN</td>
<td>NlogN</td>
<td>N<sup>2</sup></td>
<td>logN</td>
</tr>
<tr>
<td>堆排序</td>
<td>否</td>
<td>是</td>
<td>NlogN</td>
<td>NlogN</td>
<td>NlogN</td>
<td>1</td>
</tr>
<tr>
<td>基数排序</td>
<td>是</td>
<td>否</td>
<td>N * k</td>
<td>N * k</td>
<td>N * k</td>
<td>N + k</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#230--二叉搜索树中第K小的元素</title>
    <url>/2020/05/19/leetcode230/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#230–二叉搜索树中第K小的元素</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉搜索树中第K小的元素（中等）"><a href="#1-题目：二叉搜索树中第K小的元素（中等）" class="headerlink" title="1.题目：二叉搜索树中第K小的元素（中等）"></a>1.题目：二叉搜索树中第K小的元素（中等）</h3><p>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p>
<p>说明：<br>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p>
<h3 id="2-题解-中序遍历"><a href="#2-题解-中序遍历" class="headerlink" title="2.题解(中序遍历)"></a>2.题解(中序遍历)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> || !stk.empty() ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                stk.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            res = node-&gt;val;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="keyword">if</span> ( count == k ) <span class="keyword">return</span> res;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#235--二叉搜索树的最近公共祖先</title>
    <url>/2020/05/20/leetcode235/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#235–二叉搜索树的最近公共祖先</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉搜索树的最近公共祖先（简单）"><a href="#1-题目：二叉搜索树的最近公共祖先（简单）" class="headerlink" title="1.题目：二叉搜索树的最近公共祖先（简单）"></a>1.题目：二叉搜索树的最近公共祖先（简单）</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( (root-&gt;val - p-&gt;val) * (root-&gt;val - q-&gt;val) &lt;= <span class="number">0</span> ) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;val &lt; root-&gt;val ) <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">if</span> ( p-&gt;val &gt; root-&gt;val ) <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#236--二叉树的最近公共祖先</title>
    <url>/2020/05/22/leetcode236/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#235–二叉树的最近公共祖先</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树的最近公共祖先（中等）"><a href="#1-题目：二叉树的最近公共祖先（中等）" class="headerlink" title="1.题目：二叉树的最近公共祖先（中等）"></a>1.题目：二叉树的最近公共祖先（中等）</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> ( root == p || root == q ) <span class="keyword">return</span> root;</span><br><span class="line">            </span><br><span class="line">        TreeNode* left =  lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span> ( left == <span class="literal">nullptr</span> ) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> ( right == <span class="literal">nullptr</span> ) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span> ( left &amp;&amp; right ) <span class="keyword">return</span> root;  <span class="comment">// p和q在两侧</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 必须有返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#257--二叉树的所有路径</title>
    <url>/2020/05/23/leetcode257/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#257–二叉树的所有路径</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树的所有路径（简单）"><a href="#1-题目：二叉树的所有路径（简单）" class="headerlink" title="1.题目：二叉树的所有路径（简单）"></a>1.题目：二叉树的所有路径（简单）</h3><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<h3 id="2-题解-回溯"><a href="#2-题解-回溯" class="headerlink" title="2.题解(回溯)"></a>2.题解(回溯)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        dfs(root, <span class="built_in">string</span>(), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="built_in">string</span> path, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            path.append(to_string(node-&gt;val));</span><br><span class="line">            res.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;left != <span class="literal">nullptr</span> ) dfs(node-&gt;left, path + to_string(node-&gt;val) + <span class="string">"-&gt;"</span>, res);</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;right != <span class="literal">nullptr</span> ) dfs(node-&gt;right, path +  to_string(node-&gt;val) + <span class="string">"-&gt;"</span>, res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#297--二叉树的序列化与反序列化</title>
    <url>/2020/05/24/leetcode297/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#297–二叉树的序列化与反序列化</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树的序列化与反序列化（困难）"><a href="#1-题目：二叉树的序列化与反序列化（困难）" class="headerlink" title="1.题目：二叉树的序列化与反序列化（困难）"></a>1.题目：二叉树的序列化与反序列化（困难）</h3><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() ) &#123;</span><br><span class="line">            TreeNode* p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> ( p != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                res += to_string(p-&gt;val);</span><br><span class="line">                res += <span class="string">','</span>;</span><br><span class="line">                q.push(p-&gt;left);</span><br><span class="line">                q.push(p-&gt;right);</span><br><span class="line">            &#125; <span class="keyword">else</span> res += <span class="string">"null,"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vals = split(data, <span class="string">','</span>);</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="keyword">if</span> ( vals[<span class="number">0</span>] == <span class="string">"null"</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        q.push(<span class="keyword">new</span> TreeNode(stoi(vals[<span class="number">0</span>])));</span><br><span class="line">        TreeNode* res = q.front();</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vals.<span class="built_in">size</span>(); ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( vals[i] != <span class="string">"null"</span> ) &#123;</span><br><span class="line">                TreeNode* p = <span class="keyword">new</span> TreeNode(stoi(vals[i]));</span><br><span class="line">                q.push(p);</span><br><span class="line">                q.front()-&gt;left = p;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">            <span class="keyword">if</span> ( vals[i] != <span class="string">"null"</span> ) &#123;</span><br><span class="line">                TreeNode* p = <span class="keyword">new</span> TreeNode(stoi(vals[i]));</span><br><span class="line">                q.push(p);</span><br><span class="line">                q.front()-&gt;right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串分割函数，分割符为token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">split</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">char</span> token)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">iss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> <span class="keyword">word</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs;</span><br><span class="line">        <span class="keyword">while</span> ( getline(iss, <span class="keyword">word</span>, token) ) &#123;</span><br><span class="line">            vs.push_back(<span class="keyword">word</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#337--打家劫舍 III</title>
    <url>/2020/05/25/leetcode337/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#337–打家劫舍 III</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：打家劫舍-III（中等）"><a href="#1-题目：打家劫舍-III（中等）" class="headerlink" title="1.题目：打家劫舍 III（中等）"></a>1.题目：打家劫舍 III（中等）</h3><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// first : 自己不偷</span></span><br><span class="line">    <span class="comment">// second : 自己偷</span></span><br><span class="line">    <span class="comment">// 类似后续遍历 === 自底向上</span></span><br><span class="line">    pair&lt;int, int&gt; helper(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> make_pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; left = helper(root-&gt;left);</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; right = helper(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> make_pair(<span class="built_in">max</span>(left.first, left.second) + <span class="built_in">max</span>(right.first, right.second),</span><br><span class="line">                         left.first + right.first + root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; res = helper(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res.first, res.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#404--左叶子之和</title>
    <url>/2020/05/26/leetcode404/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#404–左叶子之和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：左叶子之和（简单）"><a href="#1-题目：左叶子之和（简单）" class="headerlink" title="1.题目：左叶子之和（简单）"></a>1.题目：左叶子之和（简单）</h3><p>计算给定二叉树的所有左叶子之和。</p>
<h3 id="2-题解-层序遍历"><a href="#2-题解-层序遍历" class="headerlink" title="2.题解(层序遍历)"></a>2.题解(层序遍历)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() ) &#123;</span><br><span class="line">            TreeNode* node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> ( node-&gt;left ) &#123;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;left-&gt;right == <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                    res += node-&gt;left-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( node-&gt;right ) q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#429--N叉树的层序遍历</title>
    <url>/2020/05/27/leetcode429/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#429–N叉树的层序遍历</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：N叉树的层序遍历（中等）"><a href="#1-题目：N叉树的层序遍历（中等）" class="headerlink" title="1.题目：N叉树的层序遍历（中等）"></a>1.题目：N叉树的层序遍历（中等）</h3><p>给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。</p>
<h3 id="2-题解-层序遍历"><a href="#2-题解-层序遍历" class="headerlink" title="2.题解(层序遍历)"></a>2.题解(层序遍历)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() ) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i ) &#123;</span><br><span class="line">                Node* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; node-&gt;children.<span class="built_in">size</span>(); ++j ) &#123;</span><br><span class="line">                    q.push(node-&gt;children[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                level.push_back(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#437--路径总和 III</title>
    <url>/2020/05/28/leetcode437/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#437–路径总和 III</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：路径总和-III（简单）"><a href="#1-题目：路径总和-III（简单）" class="headerlink" title="1.题目：路径总和 III（简单）"></a>1.题目：路径总和 III（简单）</h3><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p>
<p>找出路径和等于给定数值的路径总数。</p>
<p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = countPath(root, sum);</span><br><span class="line">        <span class="keyword">int</span> left = pathSum(root-&gt;left, sum);</span><br><span class="line">        <span class="keyword">int</span> right = pathSum(root-&gt;right, sum);</span><br><span class="line">        <span class="keyword">return</span> num + left + right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算从root节点出发，路径和为sum的路径数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPath</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum = sum - root-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> num = sum == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> num + countPath(root-&gt;left,sum) + countPath(root-&gt;right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#449--序列化和反序列化二叉搜索树</title>
    <url>/2020/05/29/leetcode449/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#449–序列化和反序列化二叉搜索树</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：序列化和反序列化二叉搜索树（中等）"><a href="#1-题目：序列化和反序列化二叉搜索树（中等）" class="headerlink" title="1.题目：序列化和反序列化二叉搜索树（中等）"></a>1.题目：序列化和反序列化二叉搜索树（中等）</h3><p>序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。</p>
<p>设计一个算法来序列化和反序列化二叉搜索树。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。</p>
<p>编码的字符串应尽可能紧凑。</p>
<p>注意：不要使用类成员/全局/静态变量来存储状态。 你的序列化和反序列化算法应该是无状态的。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;  <span class="comment">// 前序遍历</span></span><br><span class="line">        <span class="keyword">while</span> ( root != <span class="literal">nullptr</span> || !stk.empty() ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( root != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                stk.push(root-&gt;right);</span><br><span class="line">                res += to_string(root-&gt;val) + <span class="string">","</span>;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( data == <span class="string">"null"</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder = split(data);  <span class="comment">// 前序遍历结果</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder;</span><br><span class="line">        inorder.assign(preorder.cbegin(), preorder.cend());</span><br><span class="line">        sort(inorder.<span class="built_in">begin</span>(), inorder.<span class="built_in">end</span>());  <span class="comment">// 中序遍历结果</span></span><br><span class="line">        <span class="keyword">return</span> restore(preorder.cbegin(), preorder.cend(), inorder.cbegin(), inorder.cend());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> viter = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">restore</span><span class="params">(viter pre_begin, viter pre_end, viter in_begin, viter in_end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过前序遍历与中序遍历恢复一棵二叉树</span></span><br><span class="line">        <span class="keyword">if</span> ( pre_begin == pre_end ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(*pre_begin);</span><br><span class="line">        <span class="keyword">int</span> rootVal = root-&gt;val;</span><br><span class="line">        viter rootAddr = <span class="built_in">find</span>(in_begin, in_end, rootVal);</span><br><span class="line">        <span class="keyword">auto</span> diff = rootAddr - in_begin;</span><br><span class="line">        root-&gt;left = restore(pre_begin + <span class="number">1</span>, pre_begin + <span class="number">1</span> + diff, in_begin, rootAddr);</span><br><span class="line">        root-&gt;right = restore(pre_begin + <span class="number">1</span> + diff, pre_end, rootAddr + <span class="number">1</span>, in_end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">split</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">string</span> val;</span><br><span class="line">        <span class="keyword">while</span> ( getline(in, val, <span class="string">','</span>) ) &#123;</span><br><span class="line">            res.push_back(stoi(val));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#450--删除二叉搜索树中的节点</title>
    <url>/2020/05/30/leetcode450/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#449–删除二叉搜索树中的节点</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：删除二叉搜索树中的节点（中等）"><a href="#1-题目：删除二叉搜索树中的节点（中等）" class="headerlink" title="1.题目：删除二叉搜索树中的节点（中等）"></a>1.题目：删除二叉搜索树中的节点（中等）</h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<p>首先找到需要删除的节点；<br>如果找到了，删除它。<br>说明： 要求算法时间复杂度为 O(h)，h 为树的高度。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;val == key ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( root-&gt;right == <span class="literal">nullptr</span> ) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> ( root-&gt;left == <span class="literal">nullptr</span> ) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            TreeNode* node = minNode(root-&gt;right);</span><br><span class="line">            node-&gt;right = deleteMinNode(root-&gt;right);</span><br><span class="line">            node-&gt;left = root-&gt;left;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;val &gt; key ) root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">else</span> root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">minNode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找最小节点</span></span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;left != <span class="literal">nullptr</span> ) <span class="keyword">return</span> minNode(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteMinNode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除最小节点</span></span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;left == <span class="literal">nullptr</span> ) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">        root-&gt;left = deleteMinNode(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#501--二叉搜索树中的众数</title>
    <url>/2020/05/31/leetcode501/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#501–二叉搜索树中的众数</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉搜索树中的众数（简单）"><a href="#1-题目：二叉搜索树中的众数（简单）" class="headerlink" title="1.题目：二叉搜索树中的众数（简单）"></a>1.题目：二叉搜索树中的众数（简单）</h3><p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p>假定 BST 有如下定义：</p>
<p>结点左子树中所含结点的值小于等于当前结点的值<br>结点右子树中所含结点的值大于等于当前结点的值<br>左子树和右子树都是二叉搜索树</p>
<h3 id="2-题解-中序遍历"><a href="#2-题解-中序遍历" class="headerlink" title="2.题解(中序遍历)"></a>2.题解(中序遍历)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root, TreeNode*&amp; pre, <span class="keyword">int</span>&amp; curTimes, <span class="keyword">int</span>&amp; maxTimes, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root-&gt;left, pre, curTimes, maxTimes, res);</span><br><span class="line">        <span class="keyword">if</span> ( pre != <span class="literal">nullptr</span> )</span><br><span class="line">            curTimes = (root-&gt;val == pre-&gt;val) ? curTimes + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( curTimes == maxTimes )</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( curTimes &gt; maxTimes ) &#123;</span><br><span class="line">            res.<span class="built_in">clear</span>();</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            maxTimes = curTimes;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        inOrder(root-&gt;right, pre, curTimes, maxTimes, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> res;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> curTimes = <span class="number">1</span>, maxTimes = <span class="number">0</span>;</span><br><span class="line">        inOrder(root, pre, curTimes, maxTimes, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#508--出现次数最多的子树元素和</title>
    <url>/2020/06/01/leetcode508/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#508–出现次数最多的子树元素和</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：出现次数最多的子树元素和（中等）"><a href="#1-题目：出现次数最多的子树元素和（中等）" class="headerlink" title="1.题目：出现次数最多的子树元素和（中等）"></a>1.题目：出现次数最多的子树元素和（中等）</h3><p>给你一个二叉树的根结点，请你找出出现次数最多的子树元素和。一个结点的「子树元素和」定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。</p>
<p>你需要返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findFrequentTreeSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        findFrequentTreeSum(root, vec);</span><br><span class="line">        sort(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.push_back(vec[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vec.<span class="built_in">size</span>(); ++i ) &#123;</span><br><span class="line">            count = (vec[i] == vec[i - <span class="number">1</span>]) ? count + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> ( count &gt; maxCount ) &#123;</span><br><span class="line">                res.<span class="built_in">clear</span>();</span><br><span class="line">                res.push_back(vec[i]);</span><br><span class="line">                maxCount = count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( count == maxCount ) res.push_back(vec[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findFrequentTreeSum</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = findFrequentTreeSum(root-&gt;left, vec);</span><br><span class="line">        <span class="keyword">int</span> right = findFrequentTreeSum(root-&gt;right, vec);</span><br><span class="line">        <span class="keyword">int</span> sum = left + right + root-&gt;val;</span><br><span class="line">        vec.push_back(sum);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#513--找树左下角的值</title>
    <url>/2020/06/02/leetcode513/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#513–找树左下角的值</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：找树左下角的值（中等）"><a href="#1-题目：找树左下角的值（中等）" class="headerlink" title="1.题目：找树左下角的值（中等）"></a>1.题目：找树左下角的值（中等）</h3><p>给定一个二叉树，在树的最后一行找到最左边的值。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-DFS"><a href="#1-DFS" class="headerlink" title="(1) DFS"></a>(1) DFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLevel = <span class="number">0</span>;</span><br><span class="line">        helper(root, level, maxLevel, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span> level, <span class="keyword">int</span>&amp; maxLevel, <span class="keyword">int</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span>;</span><br><span class="line">        ++level;</span><br><span class="line">        <span class="keyword">if</span> ( level &gt; maxLevel ) &#123;</span><br><span class="line">            maxLevel = level;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先左后右</span></span><br><span class="line">        helper(root-&gt;left, level, maxLevel, res);</span><br><span class="line">        helper(root-&gt;right, level, maxLevel, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-BFS"><a href="#2-BFS" class="headerlink" title="(2) BFS"></a>(2) BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        TreeNode* p = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() ) &#123;</span><br><span class="line">            p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">// 先右后左</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right) q.push(p-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left) q.push(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>BFS</tag>
        <tag>树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#515--在每个树行中找最大值</title>
    <url>/2020/06/03/leetcode515/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#515–在每个树行中找最大值</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：在每个树行中找最大值（中等）"><a href="#1-题目：在每个树行中找最大值（中等）" class="headerlink" title="1.题目：在每个树行中找最大值（中等）"></a>1.题目：在每个树行中找最大值（中等）</h3><p>您需要在二叉树的每一行中找到最大的值。</p>
<h3 id="2-题解-层序遍历"><a href="#2-题解-层序遍历" class="headerlink" title="2.题解(层序遍历)"></a>2.题解(层序遍历)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">int</span> maxValue = q.front()-&gt;val;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i ) &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;val &gt; maxValue ) maxValue = node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;left ) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;right ) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(maxValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#530--二叉搜索树的最小绝对差</title>
    <url>/2020/06/04/leetcode530/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#530–二叉搜索树的最小绝对差</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉搜索树的最小绝对差（中等）"><a href="#1-题目：二叉搜索树的最小绝对差（中等）" class="headerlink" title="1.题目：二叉搜索树的最小绝对差（中等）"></a>1.题目：二叉搜索树的最小绝对差（中等）</h3><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
<h3 id="2-题解-中序遍历"><a href="#2-题解-中序遍历" class="headerlink" title="2.题解(中序遍历)"></a>2.题解(中序遍历)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minDiff = INT32_MAX;</span><br><span class="line">        <span class="keyword">while</span> ( root != <span class="literal">nullptr</span> || !stk.empty() ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( root != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode* node = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            <span class="keyword">if</span> ( pre ) &#123;</span><br><span class="line">                diff = node-&gt;val - pre-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> ( diff &lt; minDiff ) minDiff = diff;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = node;</span><br><span class="line">            root = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minDiff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#538--把二叉搜索树转换为累加树</title>
    <url>/2020/06/05/leetcode538/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#538–把二叉搜索树转换为累加树</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：把二叉搜索树转换为累加树（中等）"><a href="#1-题目：把二叉搜索树转换为累加树（中等）" class="headerlink" title="1.题目：把二叉搜索树转换为累加树（中等）"></a>1.题目：把二叉搜索树转换为累加树（中等）</h3><p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p>
<h3 id="2-题解-反中序遍历"><a href="#2-题解-反中序遍历" class="headerlink" title="2.题解(反中序遍历)"></a>2.题解(反中序遍历)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preValue = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> || !stk.empty() ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( node != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                stk.push(node);</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode* tmp = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            tmp-&gt;val += preValue;</span><br><span class="line">            preValue = tmp-&gt;val;</span><br><span class="line">            node = tmp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#543--二叉树的直径</title>
    <url>/2020/06/06/leetcode543/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#543–二叉树的直径</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树的直径（简单）"><a href="#1-题目：二叉树的直径（简单）" class="headerlink" title="1.题目：二叉树的直径（简单）"></a>1.题目：二叉树的直径（简单）</h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        diameterOfBinaryTree(root, maxLength);</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* node, <span class="keyword">int</span>&amp; maxLength)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftMaxLength = <span class="number">0</span>, rightMaxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;left != <span class="literal">nullptr</span> ) leftMaxLength = diameterOfBinaryTree(node-&gt;left, maxLength) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;right != <span class="literal">nullptr</span> ) rightMaxLength = diameterOfBinaryTree(node-&gt;right, maxLength) + <span class="number">1</span>;</span><br><span class="line">        length = leftMaxLength + rightMaxLength;</span><br><span class="line">        <span class="keyword">if</span> ( length &gt; maxLength ) maxLength = length;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftMaxLength, rightMaxLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#559--N叉树的最大深度</title>
    <url>/2020/06/07/leetcode559/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#559–N叉树的最大深度</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：N叉树的最大深度（简单）"><a href="#1-题目：N叉树的最大深度（简单）" class="headerlink" title="1.题目：N叉树的最大深度（简单）"></a>1.题目：N叉树的最大深度（简单）</h3><p>给定一个 N 叉树，找到其最大深度。</p>
<p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-回溯"><a href="#1-回溯" class="headerlink" title="(1) 回溯"></a>(1) 回溯</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxDepthValue = <span class="number">0</span>;</span><br><span class="line">        dfs(root, maxDepthValue, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> maxDepthValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node* root, <span class="keyword">int</span>&amp; maxDepthValue, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;children.empty() ) &#123;</span><br><span class="line">            ++depth;</span><br><span class="line">            <span class="keyword">if</span> ( depth &gt; maxDepthValue ) maxDepthValue = depth;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( Node* node : root-&gt;children ) &#123;</span><br><span class="line">            dfs(node, maxDepthValue, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-BFS"><a href="#2-BFS" class="headerlink" title="(2) BFS"></a>(2) BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> max_depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() ) &#123;</span><br><span class="line">            max_depth++;</span><br><span class="line">            <span class="keyword">int</span> sz = q.<span class="built_in">size</span>();		</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i ) &#123;</span><br><span class="line">                Node* curr = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span> ( Node* it : curr-&gt;children ) q.push(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>BFS</tag>
        <tag>树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#563--二叉树的坡度</title>
    <url>/2020/06/08/leetcode563/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#563–二叉树的坡度</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树的坡度（简单）"><a href="#1-题目：二叉树的坡度（简单）" class="headerlink" title="1.题目：二叉树的坡度（简单）"></a>1.题目：二叉树的坡度（简单）</h3><p>给定一个二叉树，计算整个树的坡度。</p>
<p>一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。</p>
<p>整个树的坡度就是其所有节点的坡度之和。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = helper(root-&gt;left, res);</span><br><span class="line">        <span class="keyword">int</span> right = helper(root-&gt;right, res);</span><br><span class="line">        res += <span class="built_in">abs</span>(left - right);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + left + right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#572--另一个树的子树</title>
    <url>/2020/06/09/leetcode572/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#572–另一个树的子树</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：另一个树的子树（简单）"><a href="#1-题目：另一个树的子树（简单）" class="headerlink" title="1.题目：另一个树的子树（简单）"></a>1.题目：另一个树的子树（简单）</h3><p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( s == <span class="literal">nullptr</span> &amp;&amp; t == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ( s == <span class="literal">nullptr</span> || t == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(s, t) || isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( s == <span class="literal">nullptr</span> &amp;&amp; t == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ( s == <span class="literal">nullptr</span> || t == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;val == t-&gt;val &amp;&amp; isSameTree(s-&gt;left, t-&gt;left) &amp;&amp; isSameTree(s-&gt;right, t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#589--N叉树的前序遍历</title>
    <url>/2020/06/10/leetcode589/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#589–N叉树的前序遍历</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：N叉树的前序遍历（简单）"><a href="#1-题目：N叉树的前序遍历（简单）" class="headerlink" title="1.题目：N叉树的前序遍历（简单）"></a>1.题目：N叉树的前序遍历（简单）</h3><p>给定一个 N 叉树，返回其节点值的前序遍历。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="keyword">while</span> ( !stk.empty() ) &#123;</span><br><span class="line">            Node* node = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            res.push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> ( !node-&gt;children.empty() ) &#123;</span><br><span class="line">                <span class="keyword">int</span> sz = node-&gt;children.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span> ( <span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i ) stk.push(node-&gt;children[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#590--N叉树的后序遍历</title>
    <url>/2020/06/11/leetcode590/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#590–N叉树的后序遍历</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：N叉树的后序遍历（简单）"><a href="#1-题目：N叉树的后序遍历（简单）" class="headerlink" title="1.题目：N叉树的后序遍历（简单）"></a>1.题目：N叉树的后序遍历（简单）</h3><p>给定一个 N 叉树，返回其节点值的后序遍历。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Node*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="keyword">while</span> ( !stk.empty() ) &#123;</span><br><span class="line">            Node* node = stk.top();</span><br><span class="line">            <span class="keyword">if</span> ( node == <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                Node* tmp = stk.top();</span><br><span class="line">                res.push_back(tmp-&gt;val);</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !node-&gt;children.empty() ) &#123;</span><br><span class="line">                <span class="keyword">int</span> sz = node-&gt;children.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span> ( <span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i ) stk.push(node-&gt;children[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#606--根据二叉树创建字符串</title>
    <url>/2020/06/20/leetcode606/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#606–根据二叉树创建字符串</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：根据二叉树创建字符串（简单）"><a href="#1-题目：根据二叉树创建字符串（简单）" class="headerlink" title="1.题目：根据二叉树创建字符串（简单）"></a>1.题目：根据二叉树创建字符串（简单）</h3><p>你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。</p>
<p>空节点则用一对空括号 “()” 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tree2str</span><span class="params">(TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( t == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        res += to_string(t-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> ( t-&gt;left == <span class="literal">nullptr</span> &amp;&amp; t-&gt;right == <span class="literal">nullptr</span> ) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span> ( t-&gt;left != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            res += <span class="string">"("</span>;</span><br><span class="line">            res += tree2str(t-&gt;left);</span><br><span class="line">            res += <span class="string">")"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> res += <span class="string">"()"</span>;</span><br><span class="line">        <span class="keyword">if</span> ( t-&gt;right != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            res += <span class="string">"("</span>;</span><br><span class="line">            res += tree2str(t-&gt;right);</span><br><span class="line">            res += <span class="string">")"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#617--合并二叉树</title>
    <url>/2020/06/21/leetcode617/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#617–合并二叉树</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：合并二叉树（简单）"><a href="#1-题目：合并二叉树（简单）" class="headerlink" title="1.题目：合并二叉树（简单）"></a>1.题目：合并二叉树（简单）</h3><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( t1 == <span class="literal">nullptr</span> &amp;&amp; t2 == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ( t1 != <span class="literal">nullptr</span> ) root-&gt;val += t1-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> ( t2 != <span class="literal">nullptr</span> ) root-&gt;val += t2-&gt;val;</span><br><span class="line">        root-&gt;left = mergeTrees(t1 != <span class="literal">nullptr</span> ? t1-&gt;left : <span class="literal">nullptr</span>, t2 != <span class="literal">nullptr</span> ? t2-&gt;left : <span class="literal">nullptr</span>);</span><br><span class="line">        root-&gt;right = mergeTrees(t1 != <span class="literal">nullptr</span> ? t1-&gt;right : <span class="literal">nullptr</span>, t2 != <span class="literal">nullptr</span> ? t2-&gt;right : <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#623--在二叉树中增加一行</title>
    <url>/2020/06/22/leetcode623/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#623–在二叉树中增加一行</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：在二叉树中增加一行（中等）"><a href="#1-题目：在二叉树中增加一行（中等）" class="headerlink" title="1.题目：在二叉树中增加一行（中等）"></a>1.题目：在二叉树中增加一行（中等）</h3><p>给定一个二叉树，根节点为第1层，深度为 1。在其第 d 层追加一行值为 v 的节点。</p>
<p>添加规则：给定一个深度值 d （正整数），针对深度为 d-1 层的每一非空节点 N，为 N 创建两个值为 v 的左子树和右子树。</p>
<p>将 N 原先的左子树，连接为新节点 v 的左子树；将 N 原先的右子树，连接为新节点 v 的右子树。</p>
<p>如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">addOneRow</span><span class="params">(TreeNode* root, <span class="keyword">int</span> v, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( d == <span class="number">1</span> ) &#123;</span><br><span class="line">            TreeNode* preRoot = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">            preRoot-&gt;left = root;</span><br><span class="line">            <span class="keyword">return</span> preRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() &amp;&amp; depth &lt; d - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i ) &#123;</span><br><span class="line">                TreeNode* tmp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> ( tmp-&gt;left ) q.push(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> ( tmp-&gt;right ) q.push(tmp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ++depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() ) &#123;</span><br><span class="line">            TreeNode* node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            TreeNode* left = node-&gt;left;</span><br><span class="line">            TreeNode* right = node-&gt;right;</span><br><span class="line">            node-&gt;left = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">            node-&gt;right = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">            node-&gt;left-&gt;left = left;</span><br><span class="line">            node-&gt;right-&gt;right = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#637--二叉树的层平均值</title>
    <url>/2020/06/23/leetcode637/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#637–二叉树的层平均值</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树的层平均值（简单）"><a href="#1-题目：二叉树的层平均值（简单）" class="headerlink" title="1.题目：二叉树的层平均值（简单）"></a>1.题目：二叉树的层平均值（简单）</h3><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组.</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i ) &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;left ) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;right ) q.push(node-&gt;right);</span><br><span class="line">                sum = sum + node-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(sum / sz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#652--寻找重复的子树</title>
    <url>/2020/06/24/leetcode652/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#652–寻找重复的子树</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：寻找重复的子树（简单）"><a href="#1-题目：寻找重复的子树（简单）" class="headerlink" title="1.题目：寻找重复的子树（简单）"></a>1.题目：寻找重复的子树（简单）</h3><p>给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。</p>
<p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        dfs(root, res, mp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; res, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&amp; mp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="comment">//二叉树先序序列化</span></span><br><span class="line">        <span class="built_in">string</span> str = to_string(root-&gt;val) + <span class="string">","</span> + dfs(root-&gt;left, res, mp) + <span class="string">","</span> + dfs(root-&gt;right, res, mp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(mp[str]==<span class="number">1</span>)&#123;</span><br><span class="line">            res.push_back(root);</span><br><span class="line">        &#125; </span><br><span class="line">        mp[str]++;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#653--两数之和 IV - 输入 BST</title>
    <url>/2020/06/25/leetcode653/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#653–两数之和 IV - 输入 BST</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：两数之和-IV-输入-BST简单）"><a href="#1-题目：两数之和-IV-输入-BST简单）" class="headerlink" title="1.题目：两数之和 IV - 输入 BST简单）"></a>1.题目：两数之和 IV - 输入 BST简单）</h3><p>给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line">        inorder(root, <span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="built_in">list</span>.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( left &lt; right ) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="built_in">list</span>[left] + <span class="built_in">list</span>[right];</span><br><span class="line">            <span class="keyword">if</span> ( sum == k ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( sum &lt; k ) ++left;</span><br><span class="line">            <span class="keyword">else</span> --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="keyword">while</span> ( root != <span class="literal">nullptr</span> || !stk.empty() ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( root != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            <span class="built_in">list</span>.push_back(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#654--最大二叉树</title>
    <url>/2020/06/26/leetcode654/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#654–最大二叉树</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：最大二叉树（中等）"><a href="#1-题目：最大二叉树（中等）" class="headerlink" title="1.题目：最大二叉树（中等）"></a>1.题目：最大二叉树（中等）</h3><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p>
<p>二叉树的根是数组中的最大元素。<br>左子树是通过数组中最大值左边部分构造出的最大二叉树。<br>右子树是通过数组中最大值右边部分构造出的最大二叉树。<br>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> constructMaximumBinaryTree(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">using</span> viter = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(viter left, viter right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( left == right ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        viter rootPos = max_element(left, right);</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(*rootPos);</span><br><span class="line">        root-&gt;left = constructMaximumBinaryTree(left, rootPos);</span><br><span class="line">        root-&gt;right = constructMaximumBinaryTree(rootPos + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#655--输出二叉树</title>
    <url>/2020/06/27/leetcode655/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#655–输出二叉树</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：输出二叉树（中等）"><a href="#1-题目：输出二叉树（中等）" class="headerlink" title="1.题目：输出二叉树（中等）"></a>1.题目：输出二叉树（中等）</h3><p>在一个 m*n 的二维字符串数组中输出二叉树，并遵守以下规则：</p>
<p>(1) 行数 m 应当等于给定二叉树的高度。<br>(2) 列数 n 应当总是奇数。<br>(3) 根节点的值（以字符串格式给出）应当放在可放置的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分（左下部分和右下部分）。你应该将左子树输出在左下部分，右子树输出在右下部分。左下和右下部分应当有相同的大小。即使一个子树为空而另一个非空，你不需要为空的子树输出任何东西，但仍需要为另一个子树留出足够的空间。然而，如果两个子树都为空则不需要为它们留出任何空间。<br>(4) 每个未使用的空间应包含一个空的字符串””。<br>(5) 使用相同的规则输出子树。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">printTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = maxDepth(root);</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; depth; ++i ) length = <span class="number">2</span> * length + <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">res</span><span class="params">(depth, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;(length))</span></span>;</span><br><span class="line">        printTree(res, <span class="number">0</span>, length - <span class="number">1</span>, root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; res, <span class="keyword">int</span> leftLim, <span class="keyword">int</span> rightLim, TreeNode* root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = (leftLim + rightLim) / <span class="number">2</span>;</span><br><span class="line">        res[depth][pos] = to_string(root-&gt;val);</span><br><span class="line">        printTree(res, leftLim, pos - <span class="number">1</span>, root-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">        printTree(res, pos + <span class="number">1</span>, rightLim, root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#662--二叉树最大宽度</title>
    <url>/2020/06/28/leetcode662/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#662–二叉树最大宽度</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树最大宽度（中等）"><a href="#1-题目：二叉树最大宽度（中等）" class="headerlink" title="1.题目：二叉树最大宽度（中等）"></a>1.题目：二叉树最大宽度（中等）</h3><p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。</p>
<p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt; lists;</span><br><span class="line">        lists.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() ) &#123;</span><br><span class="line">            <span class="keyword">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i ) &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> first = lists.front();</span><br><span class="line">                lists.pop_front();</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;left ) &#123;</span><br><span class="line">                   q.push(node-&gt;left);</span><br><span class="line">                   lists.push_back(<span class="number">2</span> * first);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;right ) &#123;</span><br><span class="line">                   q.push(node-&gt;right);</span><br><span class="line">                   lists.push_back(<span class="number">2</span> * first + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( lists.<span class="built_in">size</span>() &gt; <span class="number">1</span> ) res = <span class="built_in">max</span>(res, lists.back() - lists.front() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#669--修剪二叉搜索树</title>
    <url>/2020/06/29/leetcode669/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#669–修剪二叉搜索树</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：修剪二叉搜索树（简单）"><a href="#1-题目：修剪二叉搜索树（简单）" class="headerlink" title="1.题目：修剪二叉搜索树（简单）"></a>1.题目：修剪二叉搜索树（简单）</h3><p>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> ( L &gt; root-&gt;val ) <span class="keyword">return</span> trimBST(root-&gt;right, L, R);</span><br><span class="line">        <span class="keyword">if</span> ( R &lt; root-&gt;val ) <span class="keyword">return</span> trimBST(root-&gt;left, L, R);</span><br><span class="line">        root-&gt;left = trimBST(root-&gt;left, L, R);</span><br><span class="line">        root-&gt;right = trimBST(root-&gt;right, L, R);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#671--二叉树中第二小的节点</title>
    <url>/2020/06/30/leetcode671/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#671–二叉树中第二小的节点</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树中第二小的节点（简单）"><a href="#1-题目：二叉树中第二小的节点（简单）" class="headerlink" title="1.题目：二叉树中第二小的节点（简单）"></a>1.题目：二叉树中第二小的节点（简单）</h3><p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p>
<p>给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;left == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = root-&gt;left-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> right = root-&gt;right-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> ( left == root-&gt;val ) left = findSecondMinimumValue(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> ( right == root-&gt;val ) right = findSecondMinimumValue(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> ( left != <span class="number">-1</span> &amp;&amp; right != <span class="number">-1</span> ) <span class="keyword">return</span> <span class="built_in">min</span>(left, right);</span><br><span class="line">        <span class="keyword">if</span> ( left != <span class="number">-1</span> ) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#684--冗余连接</title>
    <url>/2020/07/01/leetcode684/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#684–冗余连接</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：冗余连接（中等）"><a href="#1-题目：冗余连接（中等）" class="headerlink" title="1.题目：冗余连接（中等）"></a>1.题目：冗余连接（中等）</h3><p>在本问题中, 树指的是一个连通且无环的无向图。</p>
<p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。</p>
<p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u &lt; v。</p>
<h3 id="2-题解-并查集"><a href="#2-题解-并查集" class="headerlink" title="2.题解(并查集)"></a>2.题解(并查集)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rp</span><span class="params">(<span class="number">1001</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> sz = edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 初始化各元素为单独的集合，代表节点就是其本身</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++ ) rp[i] = i;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz; j++ ) &#123;</span><br><span class="line">            <span class="comment">// 找到边上两个节点所在集合的代表节点</span></span><br><span class="line">            <span class="keyword">int</span> set1 = <span class="built_in">find</span>(edges[j][<span class="number">0</span>], rp);</span><br><span class="line">            <span class="keyword">int</span> set2 = <span class="built_in">find</span>(edges[j][<span class="number">1</span>], rp);</span><br><span class="line">            <span class="keyword">if</span> ( set1 == set2 )  <span class="comment">// 两个集合代表节点相同，说明出现环，返回答案</span></span><br><span class="line">                <span class="keyword">return</span> edges[j]; </span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">// 两个集合独立，合并集合。将前一个集合代表节点戳到后一个集合代表节点上</span></span><br><span class="line">                rp[set1] = set2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找路径并返回代表节点，实际上就是给定当前节点，返回该节点所在集合的代表节点</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;rp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = n;</span><br><span class="line">        <span class="keyword">while</span> ( rp[num] != num )</span><br><span class="line">            num = rp[num];</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#685--冗余连接II</title>
    <url>/2020/07/02/leetcode685/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#685–冗余连接II</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：冗余连接II（困难）"><a href="#1-题目：冗余连接II（困难）" class="headerlink" title="1.题目：冗余连接II（困难）"></a>1.题目：冗余连接II（困难）</h3><p>在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。</p>
<p>输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以边组成的二维数组。 每一个边 的元素是一对 [u, v]，用以表示有向图中连接顶点 u 和顶点 v 的边，其中 u 是 v 的一个父节点。</p>
<p>返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>
<h3 id="2-题解-并查集"><a href="#2-题解-并查集" class="headerlink" title="2.题解(并查集)"></a>2.题解(并查集)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantDirectedConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        n = edges.<span class="built_in">size</span>(); </span><br><span class="line">        fa.resize(n + <span class="number">1</span>);  <span class="comment">//从1开始标号</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">degree</span><span class="params">(n + <span class="number">1</span>)</span></span>;  <span class="comment">//入度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : edges) &#123;  <span class="comment">//统计每个点的入度</span></span><br><span class="line">            ++degree[v[<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i ) &#123;  <span class="comment">//从后往前遍历</span></span><br><span class="line">            <span class="keyword">if</span> ( degree[edges[i][<span class="number">1</span>]] == <span class="number">2</span> ) &#123;  <span class="comment">//如果这条边的入节点入度为2，即通向了一条已经连通的点</span></span><br><span class="line">                <span class="keyword">if</span> ( helper(edges, i) )  <span class="comment">//注意，一定要判断去除以后是否连同，因为入节点虽然必然连通，但是不保证出节点在刪除边以后仍为连接状态</span></span><br><span class="line">                    <span class="keyword">return</span> edges[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( degree[edges[i][<span class="number">1</span>]] == <span class="number">1</span> ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( helper(edges, i) ) <span class="keyword">return</span> edges[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;  <span class="comment">//边的数目，也是节点数(树，节点数目=边的数目+1，因为多出一条边所以两者相等)</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa;  <span class="comment">//father</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断连通性所用的并查集的findFather</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( fa[x] == x ) <span class="keyword">return</span> x;</span><br><span class="line">        x = fa[x];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去除excpt边以后，判断剩下的图是否是一个连通图（符合树的定义，（边=点-1）+连通图）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; e, <span class="keyword">int</span> except)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) fa[i] = i;  <span class="comment">//初始化每个节点，为独立的点</span></span><br><span class="line">        <span class="keyword">int</span> cnt = n;  <span class="comment">//统计连通分量</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        思路基于一些前提：</span></span><br><span class="line"><span class="comment">        1.孤立节点仅和自己连同，因此n个节点有n个连通分量</span></span><br><span class="line"><span class="comment">        2.对于每条边，情況有：</span></span><br><span class="line"><span class="comment">            1.连接了两个孤立点</span></span><br><span class="line"><span class="comment">            2.连接了两个已通点</span></span><br><span class="line"><span class="comment">        3.只有边将孤立点连接才能使连通分量减少</span></span><br><span class="line"><span class="comment">        4.只有当连通分量为1时图才是连通图</span></span><br><span class="line"><span class="comment">        5.只有n个点n-1个边的连通图是树</span></span><br><span class="line"><span class="comment">        因此，统计cnt,当连接两个不连通的点时，连通分量减1（两个连通分量和二为一），</span></span><br><span class="line"><span class="comment">        最后由cnt是否减少至1判断去掉except的图是否为树</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( i == except ) <span class="keyword">continue</span>;  <span class="comment">//除去except</span></span><br><span class="line">            <span class="keyword">int</span> fx = <span class="built_in">find</span>(e[i][<span class="number">0</span>]), fy = <span class="built_in">find</span>(e[i][<span class="number">1</span>]);  <span class="comment">//连通分量</span></span><br><span class="line">            <span class="keyword">if</span> ( fx != fy ) &#123;  <span class="comment">//判断是否属于同一个连通分量</span></span><br><span class="line">                --cnt; <span class="comment">//如果不是，则连通分量減1</span></span><br><span class="line">                fa[fy] = fx;  <span class="comment">//合并两个连通分量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">1</span>;  <span class="comment">//判断是否连通分量为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>图</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#687--最长同值路径</title>
    <url>/2020/07/03/leetcode687/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#687–最长同值路径</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：最长同值路径（简单）"><a href="#1-题目：最长同值路径（简单）" class="headerlink" title="1.题目：最长同值路径（简单）"></a>1.题目：最长同值路径（简单）</h3><p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。</p>
<p>注意：两个节点之间的路径长度由它们之间的边数表示。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = helper(root-&gt;left, res);</span><br><span class="line">        <span class="keyword">int</span> right = helper(root-&gt;right, res);</span><br><span class="line">        <span class="keyword">int</span> arrowLeft = <span class="number">0</span>, arrowRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;left &amp;&amp; root-&gt;val == root-&gt;left-&gt;val ) &#123;</span><br><span class="line">            arrowLeft = left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;right &amp;&amp; root-&gt;val == root-&gt;right-&gt;val ) &#123;</span><br><span class="line">            arrowRight = right + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, arrowLeft + arrowRight);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(arrowLeft, arrowRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#700--二叉搜索树中的搜索</title>
    <url>/2020/07/04/leetcode700/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#700–二叉搜索树中的搜索</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉搜索树中的搜索（简单）"><a href="#1-题目：二叉搜索树中的搜索（简单）" class="headerlink" title="1.题目：二叉搜索树中的搜索（简单）"></a>1.题目：二叉搜索树中的搜索（简单）</h3><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;val == val ) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;val &gt; val ) <span class="keyword">return</span> searchBST(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;val &lt; val ) <span class="keyword">return</span> searchBST(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#701--二叉搜索树中的插入操作</title>
    <url>/2020/07/05/leetcode701/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#701–二叉搜索树中的插入操作</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉搜索树中的插入操作（中等）"><a href="#1-题目：二叉搜索树中的插入操作（中等）" class="headerlink" title="1.题目：二叉搜索树中的插入操作（中等）"></a>1.题目：二叉搜索树中的插入操作（中等）</h3><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p>
<h3 id="2-题解-递归"><a href="#2-题解-递归" class="headerlink" title="2.题解(递归)"></a>2.题解(递归)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="keyword">return</span> insertIntoBST(root, node);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;val &lt; root-&gt;val ) root-&gt;left = insertIntoBST(root-&gt;left, node);</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;val &gt; root-&gt;val ) root-&gt;right = insertIntoBST(root-&gt;right, node);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#783--二叉搜索树节点最小距离</title>
    <url>/2020/07/06/leetcode783/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#783–二叉搜索树节点最小距离</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉搜索树节点最小距离（简单）"><a href="#1-题目：二叉搜索树节点最小距离（简单）" class="headerlink" title="1.题目：二叉搜索树节点最小距离（简单）"></a>1.题目：二叉搜索树节点最小距离（简单）</h3><p>给定一个二叉搜索树的根节点 root，返回树中任意两节点的差的最小值。</p>
<h3 id="2-题解-中序遍历"><a href="#2-题解-中序遍历" class="headerlink" title="2.题解(中序遍历)"></a>2.题解(中序遍历)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDiffInBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> minDiff = INT32_MAX, diff = <span class="number">0</span>;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> ( root != <span class="literal">nullptr</span> || !stk.empty() ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( root != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            <span class="keyword">if</span> ( pre != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                diff = root-&gt;val - pre-&gt;val;</span><br><span class="line">                minDiff = diff &lt; minDiff ? diff : minDiff;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minDiff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#814--二叉树剪枝</title>
    <url>/2020/07/07/leetcode814/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#814–二叉树剪枝</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：二叉树剪枝（中等）"><a href="#1-题目：二叉树剪枝（中等）" class="headerlink" title="1.题目：二叉树剪枝（中等）"></a>1.题目：二叉树剪枝（中等）</h3><p>给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。</p>
<p>返回移除了所有不包含 1 的子树的原二叉树。</p>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-后序遍历"><a href="#1-后序遍历" class="headerlink" title="(1) 后序遍历"></a>(1) 后序遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">pruneTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        root-&gt;left = pruneTree(root-&gt;left);</span><br><span class="line">        root-&gt;right = pruneTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;val == <span class="number">0</span> &amp;&amp; root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-前序遍历"><a href="#2-前序遍历" class="headerlink" title="(2) 前序遍历"></a>(2) 前序遍历</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">pruneTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> ( isAllZero(root) ) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        root-&gt;left = pruneTree(root-&gt;left);</span><br><span class="line">        root-&gt;right = pruneTree(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAllZero</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ( root-&gt;val != <span class="number">0</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isAllZero(root-&gt;left) &amp;&amp; isAllZero(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/2020/07/09/binaryTreeTraversal/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了二叉树的前序遍历、中序遍历、后序遍历以及层序遍历等四种遍历的方式</p>
<a id="more"></a>
</blockquote>
<h3 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1. 前序遍历"></a>1. 前序遍历</h3><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="(1) 递归"></a>(1) 递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder;  <span class="comment">//保存前序遍历结果</span></span><br><span class="line">        preorderTraversal(root, preorder);  <span class="comment">//前序遍历</span></span><br><span class="line">        <span class="keyword">return</span> preorder;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span>;</span><br><span class="line">        preorder.push_back(root-&gt;val);</span><br><span class="line">        preorderTraversal(root-&gt;left, preorder);</span><br><span class="line">        preorderTraversal(root-&gt;right, preorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-迭代"><a href="#2-迭代" class="headerlink" title="(2) 迭代"></a>(2) 迭代</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="keyword">while</span> ( root != <span class="literal">nullptr</span> || !stk.empty() ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( root != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                stk.push(root-&gt;right);</span><br><span class="line">                preorder.push_back(root-&gt;val);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preorder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2. 中序遍历"></a>2. 中序遍历</h3><h4 id="1-递归-1"><a href="#1-递归-1" class="headerlink" title="(1) 递归"></a>(1) 递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder;</span><br><span class="line">        inorderTraversal(root, inorder);</span><br><span class="line">        <span class="keyword">return</span> inorder;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span>;</span><br><span class="line">        inorderTraversal(root-&gt;left, inorder);</span><br><span class="line">        inorder.push_back(root-&gt;val);</span><br><span class="line">        inorderTraversal(root-&gt;right, inorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-迭代-1"><a href="#2-迭代-1" class="headerlink" title="(2) 迭代"></a>(2) 迭代</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder;</span><br><span class="line">		<span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">		<span class="keyword">while</span> ( root != <span class="literal">nullptr</span> || !stk.empty() ) &#123;</span><br><span class="line">			<span class="keyword">while</span> ( root != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">				stk.push(root);</span><br><span class="line">				root = root-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            inorder.push_back(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;  <span class="comment">//不要忘了</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> inorder;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3. 后序遍历"></a>3. 后序遍历</h3><h4 id="1-递归-2"><a href="#1-递归-2" class="headerlink" title="(1) 递归"></a>(1) 递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorder;</span><br><span class="line">        postorderTraversal(root, postorder);</span><br><span class="line">        <span class="keyword">return</span> postorder;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span>;</span><br><span class="line">        postorderTraversal(root-&gt;left, postorder);</span><br><span class="line">        postorderTraversal(root-&gt;right, postorder);</span><br><span class="line">        postorder.push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-迭代-2"><a href="#2-迭代-2" class="headerlink" title="(2) 迭代"></a>(2) 迭代</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorder;</span><br><span class="line">        <span class="keyword">while</span> ( !stk.empty() ) &#123;</span><br><span class="line">            TreeNode* node = stk.top();</span><br><span class="line">            <span class="keyword">if</span> ( node == <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                postorder.push_back(stk.top()-&gt;val);</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(<span class="literal">nullptr</span>);  <span class="comment">//关键，用来标记父节点</span></span><br><span class="line">            <span class="keyword">if</span> ( node-&gt;right ) stk.push(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> ( node-&gt;left ) stk.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> postorder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-层序遍历"><a href="#4-层序遍历" class="headerlink" title="4. 层序遍历"></a>4. 层序遍历</h3><h4 id="1-递归-3"><a href="#1-递归-3" class="headerlink" title="(1) 递归"></a>(1) 递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        levelOrder(root, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* node, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( res.<span class="built_in">size</span>() == level ) res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        res[level].push_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;left != <span class="literal">nullptr</span> ) levelOrder(node-&gt;left, res, level + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( node-&gt;right != <span class="literal">nullptr</span> ) levelOrder(node-&gt;right, res, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-广度优先搜索"><a href="#2-广度优先搜索" class="headerlink" title="(2) 广度优先搜索"></a>(2) 广度优先搜索</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( root == <span class="literal">nullptr</span> ) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> ( !q.empty() ) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">int</span> count = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i ) &#123;</span><br><span class="line">                TreeNode* node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;left != <span class="literal">nullptr</span> ) q.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> ( node-&gt;right != <span class="literal">nullptr</span> ) q.push(node-&gt;right);</span><br><span class="line">                level.push_back(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>查找算法</title>
    <url>/2020/07/15/search/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了常用的查找算法</p>
</blockquote>
<a id="more"></a>

<h3 id="1-抽象数据类型"><a href="#1-抽象数据类型" class="headerlink" title="1. 抽象数据类型"></a>1. 抽象数据类型</h3><p><strong>符号表：</strong>一种存储<em>键值对</em>的数据结构，核心操作有两种：<br>(1) 插入(put)，即将一组新的键值对存入表中；<br>(2) 查找(get)，即根据给定的键得到相应的值；</p>
<h3 id="2-各种符号表及相应的查找算法"><a href="#2-各种符号表及相应的查找算法" class="headerlink" title="2. 各种符号表及相应的查找算法"></a>2. 各种符号表及相应的查找算法</h3><h4 id="1-无序链表"><a href="#1-无序链表" class="headerlink" title="(1) 无序链表"></a>(1) 无序链表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialSearchST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node first;  <span class="comment">// 链表首节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;  <span class="comment">// 链表节点类</span></span><br><span class="line">        Key key;  <span class="comment">// 键</span></span><br><span class="line">        Value val;  <span class="comment">// 值</span></span><br><span class="line">        Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value val, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找给定的键，返回相关联的值</span></span><br><span class="line">        <span class="keyword">for</span> ( Node x = first; x != <span class="keyword">null</span>; x = x.next ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( key.equals(x.key) ) <span class="keyword">return</span> x.val;  <span class="comment">// 命中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  <span class="comment">// 未命中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找给定的键，找到则更新其值，否则在表中新建节点</span></span><br><span class="line">        <span class="keyword">for</span> ( Node x = first; x != <span class="keyword">null</span>; x = x.next ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( key.equals(x.key) ) &#123;  <span class="comment">// 命中，更新</span></span><br><span class="line">                x.val = val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        first = <span class="keyword">new</span> Node(key, val, first);  <span class="comment">// 未命中，新建节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-有序数组及二分查找"><a href="#2-有序数组及二分查找" class="headerlink" title="(2) 有序数组及二分查找"></a>(2) 有序数组及二分查找</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Key[] keys;  <span class="comment">// 键数组</span></span><br><span class="line">    <span class="keyword">private</span> Value[] vals;  <span class="comment">// 值数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;  <span class="comment">// 数组长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化一个有序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 有序数组的容量(不是长度)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchST</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        keys = (Key[]) <span class="keyword">new</span> Comparable[capacity];</span><br><span class="line">        vals = (Value[]) <span class="keyword">new</span> Comparable[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回有序数组的长度</span></span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断有序数组是否为空</span></span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 二分查找</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = N - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( left &lt;= right ) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + ( right - left ) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cmp = key.compareTo(keys[mid]);</span><br><span class="line">            <span class="keyword">if</span> ( cmp &lt; <span class="number">0</span> ) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( cmp &gt; <span class="number">0</span> ) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找给定的键，返回相关联的值</span></span><br><span class="line">        <span class="keyword">if</span> ( isEmpty() ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> i = rank(key);</span><br><span class="line">        <span class="keyword">if</span> ( i &lt; N &amp;&amp; keys[i].compareTo(key) == <span class="number">0</span> ) <span class="keyword">return</span> vals[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找键，找到则更新值，否则创建新元素</span></span><br><span class="line">        <span class="keyword">int</span> i = rank(key);</span><br><span class="line">        <span class="comment">// 1. 若命中，更新值</span></span><br><span class="line">        <span class="keyword">if</span> ( i &lt; N &amp;&amp; keys[i].compareTo(key) == <span class="number">0</span> ) &#123;</span><br><span class="line">            vals[i] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 若未命中，在位置i处创建新元素</span></span><br><span class="line">        <span class="comment">// (1) 将位置i后的所有元素向后移动一个位置，为待插入元素移出空间</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = N; j &gt; i; j-- ) &#123;</span><br><span class="line">            keys[j] = keys[j - <span class="number">1</span>];</span><br><span class="line">            vals[j] = vals[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (2) 插入元素</span></span><br><span class="line">        keys[i] = key;</span><br><span class="line">        vals[i] = val;</span><br><span class="line">        N++;  <span class="comment">// 更新数组长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-二叉搜索树"><a href="#3-二叉搜索树" class="headerlink" title="(3) 二叉搜索树"></a>(3) 二叉搜索树</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;  <span class="comment">// 二叉查找树的根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;  <span class="comment">// 二叉树节点类</span></span><br><span class="line">        <span class="keyword">private</span> Key key;  <span class="comment">// 键</span></span><br><span class="line">        <span class="keyword">private</span> Value val;  <span class="comment">// 值</span></span><br><span class="line">        <span class="keyword">private</span> Node left, right;  <span class="comment">// 指向子树的链接</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> N;  <span class="comment">// 以该节点为根的子树中的节点总数</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value val, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.N = N;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回二叉搜索树的节点数</span></span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回以x为根节点的二叉搜索树的节点数</span></span><br><span class="line">        <span class="keyword">if</span> ( x == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回key所对应的值</span></span><br><span class="line">        <span class="keyword">return</span> get(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在以x为根节点的子树中查找并返回key所对应的值</span></span><br><span class="line">        <span class="comment">// 若找不到就返回null</span></span><br><span class="line">        <span class="keyword">if</span> ( x == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> ( cmp &lt; <span class="number">0</span> ) <span class="keyword">return</span> get(x.left, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( cmp &gt; <span class="number">0</span> ) <span class="keyword">return</span> get(x.right, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找key，找到则更新经的值，否则为它创建一个新的节点</span></span><br><span class="line">        root = put(root, key, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, Key key, Value val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果key存在于以x为根节点的子树中则更新它的值；</span></span><br><span class="line">        <span class="comment">// 否则将以key和val为键值对的新节点插入到该子树中；</span></span><br><span class="line">        <span class="keyword">if</span> ( x == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="keyword">new</span> Node(key, val, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> ( cmp &lt; <span class="number">0</span> ) x.left = put(x.left, key, val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( cmp &gt; <span class="number">0</span> ) x.right = put(x.right, key, val);</span><br><span class="line">        <span class="keyword">else</span> x.val = val;</span><br><span class="line">        x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 寻找最小键</span></span><br><span class="line">        <span class="keyword">return</span> min(root).key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">min</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 寻找以x为根节点的子树中的最小键</span></span><br><span class="line">        <span class="keyword">if</span> ( x.left == <span class="keyword">null</span> ) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> min(x.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除二叉查找树中最小键的节点</span></span><br><span class="line">        root = deleteMin(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除以x为根节点的子树中最小键的节点</span></span><br><span class="line">        <span class="keyword">if</span> ( x.left == <span class="keyword">null</span> ) <span class="keyword">return</span> x.right;</span><br><span class="line">        x.left = deleteMin(x.left);</span><br><span class="line">        x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除二叉查找树中键为key的节点</span></span><br><span class="line">        root = delete(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( x == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span> ( cmp &lt; <span class="number">0</span> ) x.left = delete(x.left, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( cmp &gt; <span class="number">0</span> ) x.right = delete(x.right, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ( x.right == <span class="keyword">null</span> ) <span class="keyword">return</span> x.left;</span><br><span class="line">            <span class="keyword">if</span> ( x.left == <span class="keyword">null</span> ) <span class="keyword">return</span> x.right;</span><br><span class="line">            Node t = x;</span><br><span class="line">            x = min(t.right);</span><br><span class="line">            x.right = deleteMin(t.right);</span><br><span class="line">            x.left = t.left;</span><br><span class="line">        &#125;</span><br><span class="line">        x.N = size(x.left) + size(x.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-红黑树"><a href="#4-红黑树" class="headerlink" title="(4) 红黑树"></a>(4) 红黑树</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBlackBST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;  <span class="comment">// 红黑树的根节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value val;</span><br><span class="line">        Node left, right;</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="keyword">boolean</span> color;  <span class="comment">// 红黑树节点的颜色</span></span><br><span class="line"></span><br><span class="line">        Node(Key key, Value val, <span class="keyword">int</span> N, <span class="keyword">boolean</span> color) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.N = N;</span><br><span class="line">            <span class="keyword">this</span>.color = color;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断节点颜色是否是红色</span></span><br><span class="line">        <span class="keyword">if</span> ( x == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> x.color == RED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotateLeft</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对h节点进行左旋操作</span></span><br><span class="line">        Node x = h.right;</span><br><span class="line">        h.right = x.left;</span><br><span class="line">        x.left = h;</span><br><span class="line">        x.color = h.color;</span><br><span class="line">        h.color = RED;</span><br><span class="line">        x.N = h.N;</span><br><span class="line">        h.N = <span class="number">1</span> + size(h.left) + size(h.right);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotateRight</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对h节点进行右旋操作</span></span><br><span class="line">        Node x = h.left;</span><br><span class="line">        h.left = x.right;</span><br><span class="line">        x.right = h;</span><br><span class="line">        x.color = h.color;</span><br><span class="line">        h.color = RED;</span><br><span class="line">        x.N = h.N;</span><br><span class="line">        h.N = <span class="number">1</span> + size(h.left) + size(h.right);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node h)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对h节点进行变换选颜色操作</span></span><br><span class="line">        h.color = RED;</span><br><span class="line">        h.left.color = BLACK;</span><br><span class="line">        h.right.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回红黑树的节点数</span></span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回以x节点为根节点的子树的节点数</span></span><br><span class="line">        <span class="keyword">if</span> ( x == <span class="keyword">null</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> x.N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找key，找到则更新其值，否则为它新建一个节点</span></span><br><span class="line">        root = put(root, key, val);</span><br><span class="line">        root.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node h, Key key, Value val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( h == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key, val, <span class="number">1</span>, RED);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(h.key);</span><br><span class="line">        <span class="keyword">if</span> ( cmp &lt; <span class="number">0</span> ) h.left = put(h.left, key, val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( cmp &gt; <span class="number">0</span> ) h.right = put(h.right, key, val);</span><br><span class="line">        <span class="keyword">else</span> h.val = val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( isRed(h.right) &amp;&amp; !isRed(h.left) ) h = rotateLeft(h);</span><br><span class="line">        <span class="keyword">if</span> ( isRed(h.left) &amp;&amp; isRed(h.left.left) ) h = rotateRight(h);</span><br><span class="line">        <span class="keyword">if</span> ( isRed(h.left) &amp;&amp; isRed(h.right) ) flipColors(h);</span><br><span class="line"></span><br><span class="line">        h.N = size(h.left) + size(h.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-散列表"><a href="#5-散列表" class="headerlink" title="(5) 散列表"></a>(5) 散列表</h4><h5 id="a-基于拉链法的散列表"><a href="#a-基于拉链法的散列表" class="headerlink" title="(a) 基于拉链法的散列表"></a>(a) 基于拉链法的散列表</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparateChainingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;  <span class="comment">// 键值对总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;  <span class="comment">// 散列表大小</span></span><br><span class="line">    <span class="keyword">private</span> SequentialSearchST&lt;Key, Value&gt;[] st;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparateChainingHashST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">997</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparateChainingHashST</span><span class="params">(<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.M = M;</span><br><span class="line">        st = (SequentialSearchST&lt;Key, Value&gt;[]) <span class="keyword">new</span> SequentialSearchST[M];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++ ) &#123;</span><br><span class="line">            st[i] = <span class="keyword">new</span> SequentialSearchST&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 散列函数</span></span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回key所对应的值</span></span><br><span class="line">        <span class="keyword">return</span> (Value) st[hash(key)].get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找key，找到则更新其值，否则插入该键值对</span></span><br><span class="line">        st[hash(key)].put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="b-基于线性探测法的散列表"><a href="#b-基于线性探测法的散列表" class="headerlink" title="(b) 基于线性探测法的散列表"></a>(b) 基于线性探测法的散列表</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;  <span class="comment">// 符号表中键值对总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;  <span class="comment">// 线性探测表的大小</span></span><br><span class="line">    <span class="keyword">private</span> Key[] keys;  <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">private</span> Value[] vals;  <span class="comment">// 值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        keys = (Key[]) <span class="keyword">new</span> Object[M];</span><br><span class="line">        vals = (Value[]) <span class="keyword">new</span> Object[M];</span><br><span class="line">        M = cap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 散列函数</span></span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调整数组大小</span></span><br><span class="line">        LinearProbingHashST&lt;Key, Value&gt; t;</span><br><span class="line">        t = <span class="keyword">new</span> LinearProbingHashST&lt;Key, Value&gt;(cap);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( keys[i] != <span class="keyword">null</span> ) t.put(keys[i], vals[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        keys = t.keys;</span><br><span class="line">        vals = t.vals;</span><br><span class="line">        M = t.M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找key，找到则更新其值，否则插入该键值对</span></span><br><span class="line">        <span class="keyword">if</span> ( N &gt;= M / <span class="number">2</span> ) resize(<span class="number">2</span> * M);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> ( i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i + <span class="number">1</span>) % M ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( keys[i].equals(key) ) &#123;</span><br><span class="line">                vals[i] = val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        keys[i] = key;</span><br><span class="line">        vals[i] = val;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回key所对应的值</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i + <span class="number">1</span>) % M ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( keys[i].equals(key) ) <span class="keyword">return</span> vals[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-各种符号表实现的性能总结"><a href="#3-各种符号表实现的性能总结" class="headerlink" title="3. 各种符号表实现的性能总结"></a>3. 各种符号表实现的性能总结</h3><table style="float:center">
    <tr>
        <td rowspan="2">算法(数据结构)</td>
        <td colspan="2">最坏情况下的运行时间的增长数量级<br>(N次插入之后)</td>
        <td colspan="2">平均情况下的运行时间的增长数量级<br>(N次插入之后)</td>
        <td rowspan="2">是否支持有序性相关的操作</td>
    </tr>
    <tr>
        <td>查找</td>
        <td>插入</td>
        <td>查找</td>
        <td>插入</td>
    </tr>
    <tr>
        <td>顺序查询(无序链表)</td>
        <td>N</td>
        <td>N</td>
        <td>N/2</td>
        <td>N</td>
        <td>否</td>
    </tr>
    <tr>
        <td>二分查找(有序数组)</td>
        <td>lgN</td>
        <td>N</td>
        <td>lgN</td>
        <td>N/2</td>
        <td>是</td>
    </tr>
    <tr>
        <td>二叉树查找(BST)</td>
        <td>N</td>
        <td>N</td>
        <td>1.39lgN</td>
        <td>1.39lgN</td>
        <td>是</td>
    </tr>
    <tr>
        <td>红黑树查找(红黑树)</td>
        <td>2lgN</td>
        <td>2lgN</td>
        <td>1.00lgN</td>
        <td>1.00lgN</td>
        <td>是</td>
    </tr>
    <tr>
        <td>拉链法散列表<br>(链表数组)</td>
        <td>&#60lgN</td>
        <td>&#60lgN</td>
        <td>N/(2M)</td>
        <td>N/M</td>
        <td>否</td>
    </tr>
    <tr>
        <td>线性探测法散列表<br>(并行数组)</td>
        <td>clgN</td>
        <td>clgN</td>
        <td>&#60 1.5</td>
        <td>&#60 2.5</td>
        <td>否</td>
    </tr>

</table>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#4--寻找两个正序数组的中位数</title>
    <url>/2020/07/20/leetcode4/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#4–寻找两个正序数组的中位数</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：寻找两个正序数组的中位数（困难）"><a href="#1-题目：寻找两个正序数组的中位数（困难）" class="headerlink" title="1.题目：寻找两个正序数组的中位数（困难）"></a>1.题目：寻找两个正序数组的中位数（困难）</h3><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p>
<p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
<p>你可以假设 nums1 和 nums2 不会同时为空。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>nums1 = [1, 3]<br>nums2 = [2]</p>
<p>则中位数是 2.0</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> left = (n + m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> right = (n + m + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。</span></span><br><span class="line">        <span class="keyword">return</span> (getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, left) + getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, right)) * <span class="number">0.5</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = end1 - start1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = end2 - start2 + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1 </span></span><br><span class="line">        <span class="keyword">if</span> ( len1 &gt; len2 ) <span class="keyword">return</span> getKth(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line">        <span class="keyword">if</span> ( len1 == <span class="number">0</span> ) <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( k == <span class="number">1</span> ) <span class="keyword">return</span> <span class="built_in">min</span>(nums1[start1], nums2[start2]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = start1 + <span class="built_in">min</span>(len1, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = start2 + <span class="built_in">min</span>(len2, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( nums1[i] &gt; nums2[j] ) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#10--正则表达式匹配</title>
    <url>/2020/07/21/leetcode10/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#10–正则表达式匹配</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：正则表达式匹配（困难）"><a href="#1-题目：正则表达式匹配（困难）" class="headerlink" title="1.题目：正则表达式匹配（困难）"></a>1.题目：正则表达式匹配（困难）</h3><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p>
<p>‘.’ 匹配任意单个字符<br>‘*’ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<p>说明:</p>
<p>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:<br>s = “aa”<br>p = “a*”<br>输出: true</p>
</blockquote>
<h3 id="2-题解-动态规划"><a href="#2-题解-动态规划" class="headerlink" title="2.题解(动态规划)"></a>2.题解(动态规划)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        s = <span class="string">" "</span> + s;</span><br><span class="line">        p = <span class="string">" "</span> + p;</span><br><span class="line">        <span class="keyword">int</span> m = s.<span class="built_in">size</span>(), n = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n + <span class="number">1</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">'.'</span> ) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( p[j - <span class="number">1</span>] == <span class="string">'*'</span> ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( s[i - <span class="number">1</span>] != p[j - <span class="number">2</span>] &amp;&amp; p[j - <span class="number">2</span>] != <span class="string">'.'</span> )</span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">1</span>] || dp[i][j - <span class="number">2</span>] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#23--合并K个排序链表</title>
    <url>/2020/07/22/leetcode23/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#23–合并K个排序链表</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：合并K个排序链表（困难）"><a href="#1-题目：合并K个排序链表（困难）" class="headerlink" title="1.题目：合并K个排序链表（困难）"></a>1.题目：合并K个排序链表（困难）</h3><p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入:<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
</blockquote>
<h3 id="2-题解-分治思想"><a href="#2-题解-分治思想" class="headerlink" title="2.题解(分治思想)"></a>2.题解(分治思想)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( lists.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 类似归并排序，分而治之</span></span><br><span class="line">        <span class="keyword">if</span> ( left == right ) <span class="keyword">return</span> lists[left];</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        ListNode* l1 = merge(lists, left, mid);</span><br><span class="line">        ListNode* l2 = merge(lists, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 合并两个有序链表</span></span><br><span class="line">        <span class="keyword">if</span> ( l1 == <span class="literal">nullptr</span> ) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> ( l2 == <span class="literal">nullptr</span> ) <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* ptr = dummy;</span><br><span class="line">        ListNode* ptr1 = l1, * ptr2 = l2;</span><br><span class="line">        <span class="keyword">while</span> ( l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( l1-&gt;val &lt; l2-&gt;val ) &#123;</span><br><span class="line">                ptr-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ptr-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( l1 == <span class="literal">nullptr</span> ) ptr-&gt;next = l2;</span><br><span class="line">        <span class="keyword">else</span> ptr-&gt;next = l1;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#32--最长有效括号</title>
    <url>/2020/07/23/leetcode32/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#32–最长有效括号</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：最长有效括号（困难）"><a href="#1-题目：最长有效括号（困难）" class="headerlink" title="1.题目：最长有效括号（困难）"></a>1.题目：最长有效括号（困难）</h3><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>输入: “(()”<br>输出: 2<br>解释: 最长有效括号子串为 “()”</p>
</blockquote>
<h3 id="2-题解"><a href="#2-题解" class="headerlink" title="2.题解"></a>2.题解</h3><h4 id="1-动态规划"><a href="#1-动态规划" class="headerlink" title="(1) 动态规划"></a>(1) 动态规划</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxans = <span class="number">0</span>, n = s.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxans = <span class="built_in">max</span>(maxans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-栈"><a href="#2-栈" class="headerlink" title="(2) 栈"></a>(2) 栈</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        stk.push(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">                stk.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">if</span> (stk.empty()) &#123;</span><br><span class="line">                    stk.push(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    maxans = <span class="built_in">max</span>(maxans, i - stk.top());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-正向逆向结合"><a href="#3-正向逆向结合" class="headerlink" title="(3) 正向逆向结合"></a>(3) 正向逆向结合</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, maxlength = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 正向遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = <span class="built_in">max</span>(maxlength, <span class="number">2</span> * right);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逆向遍历</span></span><br><span class="line">        left = right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>)s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                maxlength = <span class="built_in">max</span>(maxlength, <span class="number">2</span> * left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">                left = right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#42--接雨水</title>
    <url>/2020/07/24/leetcode42/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#42–接雨水</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：接雨水（困难）"><a href="#1-题目：接雨水（困难）" class="headerlink" title="1.题目：接雨水（困难）"></a>1.题目：接雨水（困难）</h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<h3 id="2-题解-动态规划"><a href="#2-题解-动态规划" class="headerlink" title="2.题解(动态规划)"></a>2.题解(动态规划)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">height</span>.empty() ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">max_left</span><span class="params">(<span class="built_in">height</span>.<span class="built_in">size</span>())</span></span>;   <span class="comment">// 左侧最高的板</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">max_right</span><span class="params">(<span class="built_in">height</span>.<span class="built_in">size</span>())</span></span>;  <span class="comment">// 右侧最高的板</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">height</span>.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            max_left[i] = <span class="built_in">max</span>(max_left[i - <span class="number">1</span>], <span class="built_in">height</span>[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">height</span>.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            max_right[i] = <span class="built_in">max</span>(max_right[i + <span class="number">1</span>], <span class="built_in">height</span>[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">height</span>.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> less = <span class="built_in">min</span>(max_left[i], max_right[i]);</span><br><span class="line">            <span class="keyword">if</span> (less &gt; <span class="built_in">height</span>[i]) &#123;</span><br><span class="line">                sum = sum + (less - <span class="built_in">height</span>[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#72--编辑距离</title>
    <url>/2020/07/25/leetcode72/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#72–编辑距离</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：编辑距离（困难）"><a href="#1-题目：编辑距离（困难）" class="headerlink" title="1.题目：编辑距离（困难）"></a>1.题目：编辑距离（困难）</h3><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符</p>
<h3 id="2-题解-动态规划"><a href="#2-题解-动态规划" class="headerlink" title="2.题解(动态规划)"></a>2.题解(动态规划)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = word1.length();</span><br><span class="line">        <span class="keyword">int</span> n2 = word2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 第一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">                <span class="comment">// 状态转移方程</span></span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#76--最小覆盖子串</title>
    <url>/2020/07/27/leetcode76/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#76–最小覆盖子串</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：最小覆盖子串（困难）"><a href="#1-题目：最小覆盖子串（困难）" class="headerlink" title="1.题目：最小覆盖子串（困难）"></a>1.题目：最小覆盖子串（困难）</h3><p>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p>
<h3 id="2-题解-动态规划"><a href="#2-题解-动态规划" class="headerlink" title="2.题解(动态规划)"></a>2.题解(动态规划)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s == <span class="string">""</span> || t == <span class="keyword">null</span> || t == <span class="string">""</span> || s.length() &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//维护两个数组，记录已有字符串指定字符的出现次数，和目标字符串指定字符的出现次数</span></span><br><span class="line">        <span class="comment">//ASCII表总长128</span></span><br><span class="line">        <span class="keyword">int</span>[] need = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span>[] have = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将目标字符串指定字符的出现次数记录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            need[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分别为左指针，右指针，最小长度(初始值为一定不可达到的长度)</span></span><br><span class="line">        <span class="comment">//已有字符串中目标字符串指定字符的出现总频次以及最小覆盖子串在原字符串中的起始位置</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, min = s.length() + <span class="number">1</span>, count = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> r = s.charAt(right);</span><br><span class="line">            <span class="comment">//说明该字符不被目标字符串需要，此时有两种情况</span></span><br><span class="line">            <span class="comment">// 1.循环刚开始，那么直接移动右指针即可，不需要做多余判断</span></span><br><span class="line">            <span class="comment">// 2.循环已经开始一段时间，此处又有两种情况</span></span><br><span class="line">            <span class="comment">//  2.1 上一次条件不满足，已有字符串指定字符出现次数不满足目标字符串指定字符出现次数，那么此时</span></span><br><span class="line">            <span class="comment">//      如果该字符还不被目标字符串需要，就不需要进行多余判断，右指针移动即可</span></span><br><span class="line">            <span class="comment">//  2.2 左指针已经移动完毕，那么此时就相当于循环刚开始，同理直接移动右指针</span></span><br><span class="line">            <span class="keyword">if</span> (need[r] == <span class="number">0</span>) &#123;</span><br><span class="line">                right++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当且仅当已有字符串目标字符出现的次数小于目标字符串字符的出现次数时，count才会+1</span></span><br><span class="line">            <span class="comment">//是为了后续能直接判断已有字符串是否已经包含了目标字符串的所有字符，不需要挨个比对字符出现的次数</span></span><br><span class="line">            <span class="keyword">if</span> (have[r] &lt; need[r]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//已有字符串中目标字符出现的次数+1</span></span><br><span class="line">            have[r]++;</span><br><span class="line">            <span class="comment">//移动右指针</span></span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">//当且仅当已有字符串已经包含了所有目标字符串的字符，且出现频次一定大于或等于指定频次</span></span><br><span class="line">            <span class="keyword">while</span> (count == t.length()) &#123;</span><br><span class="line">                <span class="comment">//当窗口的长度比已有的最短值小时，更改最小值，并记录起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; min) &#123;</span><br><span class="line">                    min = right - left;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> l = s.charAt(left);</span><br><span class="line">                <span class="comment">//如果左边即将要去掉的字符不被目标字符串需要，那么不需要多余判断，直接可以移动左指针</span></span><br><span class="line">                <span class="keyword">if</span> (need[l] == <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果左边即将要去掉的字符被目标字符串需要，且出现的频次正好等于指定频次，那么如果去掉了这个字符，</span></span><br><span class="line">                <span class="comment">//就不满足覆盖子串的条件，此时要破坏循环条件跳出循环，即控制目标字符串指定字符的出现总频次(count）-1</span></span><br><span class="line">                <span class="keyword">if</span> (have[l] == need[l]) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//已有字符串中目标字符出现的次数-1</span></span><br><span class="line">                have[l]--;</span><br><span class="line">                <span class="comment">//移动左指针</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最小长度还为初始值，说明没有符合条件的子串</span></span><br><span class="line">        <span class="keyword">if</span> (min == s.length() + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回的为以记录的起始位置为起点，记录的最短长度为距离的指定字符串中截取的子串</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#84--柱状图中的最大矩形</title>
    <url>/2020/07/28/leetcode84/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#84–柱状图中的最大矩形</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：柱状图中的最大矩形（困难）"><a href="#1-题目：柱状图中的最大矩形（困难）" class="headerlink" title="1.题目：柱状图中的最大矩形（困难）"></a>1.题目：柱状图中的最大矩形（困难）</h3><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<h3 id="2-题解-单调栈"><a href="#2-题解-单调栈" class="headerlink" title="2.题解(单调栈)"></a>2.题解(单调栈)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理特殊情况</span></span><br><span class="line">        <span class="keyword">int</span> len = heights.length;</span><br><span class="line">        <span class="keyword">if</span> ( len == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( len == <span class="number">1</span> ) <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加哨兵，重新构造柱状图</span></span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] newHeights = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i ) &#123;</span><br><span class="line">            newHeights[i + <span class="number">1</span>] = heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        len += <span class="number">2</span>;</span><br><span class="line">        heights = newHeights;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造单调栈</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        stack.addLast(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( heights[stack.peekLast()] &gt; heights[i] ) &#123;</span><br><span class="line">                <span class="keyword">int</span> height = heights[stack.removeLast()];</span><br><span class="line">                <span class="keyword">int</span> width = i - stack.peekLast() - <span class="number">1</span>;</span><br><span class="line">                area = Math.max(area, width * height);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode#85--最大矩形</title>
    <url>/2020/07/29/leetcode85/</url>
    <content><![CDATA[<blockquote>
<p>LeetCode#85–最大矩形</p>
</blockquote>
<a id="more"></a>

<h3 id="1-题目：最大矩形（困难）"><a href="#1-题目：最大矩形（困难）" class="headerlink" title="1.题目：最大矩形（困难）"></a>1.题目：最大矩形（困难）</h3><p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p>
<h3 id="2-题解-单调栈"><a href="#2-题解-单调栈" class="headerlink" title="2.题解(单调栈)"></a>2.题解(单调栈)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] heights = <span class="keyword">new</span> <span class="keyword">int</span>[matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; matrix.length; row++) &#123;</span><br><span class="line">            <span class="comment">//遍历每一列，更新高度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; matrix[<span class="number">0</span>].length; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[row][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    heights[col] += <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    heights[col] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调用上一题的解法，更新函数</span></span><br><span class="line">            maxArea = Math.max(maxArea, largestRectangleArea(heights));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理特殊情况</span></span><br><span class="line">        <span class="keyword">int</span> len = heights.length;</span><br><span class="line">        <span class="keyword">if</span> ( len == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( len == <span class="number">1</span> ) <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加哨兵，重新构造柱状图</span></span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] newHeights = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i ) &#123;</span><br><span class="line">            newHeights[i + <span class="number">1</span>] = heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        len += <span class="number">2</span>;</span><br><span class="line">        heights = newHeights;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造单调栈</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        stack.addLast(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i ) &#123;</span><br><span class="line">            <span class="keyword">while</span> ( heights[stack.peekLast()] &gt; heights[i] ) &#123;</span><br><span class="line">                <span class="keyword">int</span> height = heights[stack.removeLast()];</span><br><span class="line">                <span class="keyword">int</span> width = i - stack.peekLast() - <span class="number">1</span>;</span><br><span class="line">                area = Math.max(area, width * height);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>fastJSON常用方法</title>
    <url>/2020/10/10/fastjson/</url>
    <content><![CDATA[<blockquote>
<p>fastJSON是阿里巴巴开源的一个JSON解析库<br>本文总结了fastJSON中的常用方法</p>
</blockquote>
<a id="more"></a>

<h3 id="1-JSON字符串-gt-JSON对象-JSON对象数组"><a href="#1-JSON字符串-gt-JSON对象-JSON对象数组" class="headerlink" title="(1) JSON字符串 -&gt; JSON对象/JSON对象数组"></a>(1) JSON字符串 -&gt; JSON对象/JSON对象数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSONObject jsonObject = <span class="keyword">new</span> JSONObject (String str);</span><br><span class="line">JSONObject jsonObject = JSON.parseObject(String str);  <span class="comment">// 使用</span></span><br><span class="line"></span><br><span class="line">JSONArray jsonArray = <span class="keyword">new</span> JSONArray(String str);</span><br><span class="line">JSONArray jsonArray = JSON.parseArray(String str);  <span class="comment">// 使用</span></span><br></pre></td></tr></table></figure>

<h3 id="2-JSON对象-JSON对象数组-gt-JSON字符串"><a href="#2-JSON对象-JSON对象数组-gt-JSON字符串" class="headerlink" title="(2) JSON对象/JSON对象数组 -&gt; JSON字符串"></a>(2) JSON对象/JSON对象数组 -&gt; JSON字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = JSON.toJSONString(Object jsonObj);</span><br></pre></td></tr></table></figure>

<h3 id="3-判断是否是有效的JSON字符串-JSON对象-JSON数组"><a href="#3-判断是否是有效的JSON字符串-JSON对象-JSON数组" class="headerlink" title="(3) 判断是否是有效的JSON字符串/JSON对象/JSON数组"></a>(3) 判断是否是有效的JSON字符串/JSON对象/JSON数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSON.isValid(String str);</span><br><span class="line">JSON.isValidObject(String str);</span><br><span class="line">JSON.isValidArray(String str);</span><br></pre></td></tr></table></figure>

<h3 id="4-JSONObject-的常用方法"><a href="#4-JSONObject-的常用方法" class="headerlink" title="(4) JSONObject 的常用方法"></a>(4) JSONObject 的常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.添加/删除 一个键值对</span></span><br><span class="line">Object obj = jsonObject.put(String key, Object value);</span><br><span class="line">Object obj = jsonObject.remove(Object key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.根据key值获取JSONObject对象中对应的value值</span></span><br><span class="line">Object obj = jsonObject.get(String key);</span><br><span class="line">String str = jsonObject.getString(String key);</span><br><span class="line">JSONObject obj = jsonObject.getJSONObject(String key);</span><br><span class="line">JSONArray obj = jsonObject.getJSONArray(String key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.其它常用方法</span></span><br><span class="line"><span class="keyword">int</span> size = jsonObject.size();  <span class="comment">// 获取JSONObject对象中键值对的数量</span></span><br><span class="line"><span class="keyword">boolean</span> empty = jsonObject.isEmpty();  <span class="comment">// 判断该JSONObject对象是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> containsKey = jsonObject.containsKey(Object key);  <span class="comment">// 判断是否有需要的key值</span></span><br><span class="line"><span class="keyword">boolean</span> containsValue = jsonObject.containsValue(Object val);  <span class="comment">// 判断是否有需要的value值</span></span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; keySet = jsonObject.keySet();  <span class="comment">// 获取JSONObject中的key，并将其放入Set集合中</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, Object&gt;&gt; entries = jsonObject.entrySet();  <span class="comment">// 取得键和值的映射关系</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>common-csv常用方法</title>
    <url>/2020/10/15/common-csv/</url>
    <content><![CDATA[<blockquote>
<p>common-csv是Apache开源组织提供的用于读写CSV文件的工具包<br>本文总结了common-csv中的常用方法</p>
</blockquote>
<a id="more"></a>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot整合mybatis</title>
    <url>/2020/11/18/springboot-mybatis-druid/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了springboot整合mybatis，并使用druid数据库连接池，操作mysql数据库的方法</p>
</blockquote>
<a id="more"></a>

<h3 id="1-需要的-maven-依赖"><a href="#1-需要的-maven-依赖" class="headerlink" title="(1) 需要的 maven 依赖"></a>(1) 需要的 maven 依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mysql 驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mybatis 整合 springboot 的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- druid 数据库连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-springboot-配置文件的设置-application-yml"><a href="#2-springboot-配置文件的设置-application-yml" class="headerlink" title="(2) springboot 配置文件的设置(application.yml)"></a>(2) springboot 配置文件的设置(application.yml)</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 程序端口号设置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8181</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据源设置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://&#123;ip&#125;:&#123;port&#125;/&#123;databaseName&#125;?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mybatis配置文件 和 sql映射文件 的路径</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">config-location:</span> <span class="string">classpath:config/mybatis-config.xml</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印mybatis中执行的sql语句</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.zjume.kgspringboot.mapper:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<h3 id="3-mybatis-相关文件的设置"><a href="#3-mybatis-相关文件的设置" class="headerlink" title="(3) mybatis 相关文件的设置"></a>(3) mybatis 相关文件的设置</h3><p>mybatis共包括两个xml文件：<strong>mybatis配置文件</strong> 以及 <strong>sql映射文件</strong></p>
<h4 id="3-1-mybatis配置文件"><a href="#3-1-mybatis配置文件" class="headerlink" title="3.1 mybatis配置文件"></a>3.1 mybatis配置文件</h4><p><strong>推荐存放路径</strong>：src文件夹 -&gt; resources文件夹 -&gt; config文件夹 -&gt; mybatis-config.xml<br><strong>注意</strong>：必须与 application.yml 配置文件中 mybatis:config-location 中的路径一致！<br><strong>内容</strong>：参考<a href="https://mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="noopener">官方文档</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-sql映射文件"><a href="#3-2-sql映射文件" class="headerlink" title="3.2 sql映射文件"></a>3.2 sql映射文件</h4><p><strong>推荐存放路径</strong>：src文件夹 -&gt; resources文件夹 -&gt; mapper文件夹 -&gt; ···Mapper.xml<br><strong>注意</strong>：必须与 application.yml 配置文件中 mybatis:mapper-locations 中的路径一致！<br><strong>内容</strong>：参考<a href="https://mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="noopener">官方文档</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.zjume.kgspringboot.mapper.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--向表中添加一条记录--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUser"</span>&gt;</span></span><br><span class="line">        insert into user_info(`id`, `username`, `password`)</span><br><span class="line">        values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中：<br>mapper 标签中的 namespace 属性 是 该xml文件 映射到的 接口的全类名<br>insert 标签中的 id 属性中是 该条 sql语句 映射到的 函数名；</p>
<h3 id="4-在-mysql-中创建一张表，并创建与之对应的实体类"><a href="#4-在-mysql-中创建一张表，并创建与之对应的实体类" class="headerlink" title="(4) 在 mysql 中创建一张表，并创建与之对应的实体类"></a>(4) 在 mysql 中创建一张表，并创建与之对应的实体类</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="string">`user_info`</span>(</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span> auto_increment,</span><br><span class="line">    <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">30</span>),</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="string">`id`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserInfo</span><span class="params">(Integer id, String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-编写与-xml映射文件-对应的-mapper接口"><a href="#5-编写与-xml映射文件-对应的-mapper接口" class="headerlink" title="(5) 编写与 xml映射文件 对应的 mapper接口"></a>(5) 编写与 xml映射文件 对应的 mapper接口</h3><p>在 启动类所在的package下 新建 mapper 包，新建 ···Mapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 向 mysql 数据库的表中添加一条记录</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">(UserInfo userInfo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-扫描-···Mapper-接口"><a href="#6-扫描-···Mapper-接口" class="headerlink" title="(6) 扫描 ···Mapper 接口"></a>(6) 扫描 ···Mapper 接口</h3><p><strong>方法一(推荐)：</strong>在启动类上加 @MapperScan(“{mapper包的路径}”) 注解，可扫描该文件夹下的所有···Mapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.zjume.kgspringboot.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KgspringbootApplication</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(KgspringbootApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：</strong>在所有的···Mapper接口上加 @Mapper 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">(UserInfo userInfo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-当前工程目录"><a href="#7-当前工程目录" class="headerlink" title="(7) 当前工程目录"></a>(7) 当前工程目录</h3><img src="/2020/11/18/springboot-mybatis-druid/springboot_mybatis_project.png" class>

<h3 id="8-单元测试"><a href="#8-单元测试" class="headerlink" title="(8) 单元测试"></a>(8) 单元测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo(<span class="keyword">null</span>, <span class="string">"admin"</span>, <span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">        userMapper.addUser(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-其它"><a href="#9-其它" class="headerlink" title="(9) 其它"></a>(9) 其它</h3><h4 id="9-1-idea中Mapper自动注入警告"><a href="#9-1-idea中Mapper自动注入警告" class="headerlink" title="9.1 idea中Mapper自动注入警告"></a>9.1 idea中Mapper自动注入警告</h4><img src="/2020/11/18/springboot-mybatis-druid/mapper_autowired_error.png" class>

<p><strong>解决方法：</strong>可以在···Mapper接口上加 @Repository 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addUser</span><span class="params">(UserInfo userInfo)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-插件"><a href="#9-2-插件" class="headerlink" title="9.2 插件"></a>9.2 插件</h4><p>MyBatisCodeHelperPro<br>MyBatis Log Plugin</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot 实现唯一登录和过期重新登录</title>
    <url>/2020/12/20/springboot-session/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了Springboot + SpringSession + Redis 实现唯一登录和过期重新登录的方法，并针对其中的跨域问题做出说明。</p>
</blockquote>
<a id="more"></a>

<h3 id="1-需要的-maven-依赖"><a href="#1-需要的-maven-依赖" class="headerlink" title="(1) 需要的 maven 依赖"></a>(1) 需要的 maven 依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- springboot 整合 redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 实现使用 redis 管理 session --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-application-yml配置"><a href="#2-application-yml配置" class="headerlink" title="(2) application.yml配置"></a>(2) application.yml配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">(主机ip地址)</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">session:</span></span><br><span class="line">    <span class="attr">store-type:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure>

<h3 id="3-登录时将用户id和sessionId存入redis中"><a href="#3-登录时将用户id和sessionId存入redis中" class="headerlink" title="(3) 登录时将用户id和sessionId存入redis中"></a>(3) 登录时将用户id和sessionId存入redis中</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将该用户及其对应的sessionId存入redis中</span></span><br><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.setAttribute(<span class="string">"loginUserId"</span>, userInfo.getId());</span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">"loginUser:"</span> + userInfo.getId(), session.getId());</span><br></pre></td></tr></table></figure>

<h3 id="4-编写登录状态拦截器-RedisSessionInterceptor"><a href="#4-编写登录状态拦截器-RedisSessionInterceptor" class="headerlink" title="(4) 编写登录状态拦截器 RedisSessionInterceptor"></a>(4) 编写登录状态拦截器 RedisSessionInterceptor</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSessionInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拦截器1: 解决唯一登录和过期重新登录问题"</span>);</span><br><span class="line"></span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        <span class="keyword">if</span> (session.getAttribute(<span class="string">"loginUserId"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//验证当前请求的session是否是已登录的session</span></span><br><span class="line">                String loginSessionId = redisTemplate.opsForValue().get(<span class="string">"loginUser:"</span> + session.getAttribute(<span class="string">"loginUserId"</span>));</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"当前sessionId = "</span> + loginSessionId);</span><br><span class="line">                <span class="keyword">if</span> (loginSessionId != <span class="keyword">null</span> &amp;&amp; loginSessionId.equals(session.getId())) &#123;</span><br><span class="line">                    redisTemplate.opsForValue().set(<span class="string">"loginUser:"</span> + session.getAttribute(<span class="string">"loginUserId"</span>), loginSessionId);</span><br><span class="line">                    System.out.println(<span class="string">".....成功通过拦截"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        response401(response);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">response401</span><span class="params">(HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        response.setContentType(<span class="string">"application/json; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response.getWriter().print(JSON.toJSONString(<span class="keyword">new</span> CommonResult&lt;&gt;(<span class="number">401</span>, <span class="string">"用户未登录"</span>, <span class="keyword">null</span>)));</span><br><span class="line">            System.out.println(<span class="string">"........被拦截了！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-配置拦截器"><a href="#5-配置拦截器" class="headerlink" title="(5) 配置拦截器"></a>(5) 配置拦截器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisSessionInterceptor <span class="title">getSessionInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisSessionInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CrosInterceptor <span class="title">getCrosInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CrosInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 注册 拦截器：解决跨域问题</span></span><br><span class="line">        registry.addInterceptor(getCrosInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">        <span class="comment">// 2. 注册 拦截器：解决过期重新登录问题</span></span><br><span class="line">        registry.addInterceptor(getSessionInterceptor()).addPathPatterns(<span class="string">"/userInfo/**"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 添加所有注册过的拦截器</span></span><br><span class="line">        WebMvcConfigurer.<span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-配置-spring-session-redis"><a href="#6-配置-spring-session-redis" class="headerlink" title="(6) 配置 spring-session-redis"></a>(6) 配置 spring-session-redis</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span>(maxInactiveIntervalInSeconds = <span class="number">1800</span>)  <span class="comment">// 设置session过期时间为1800秒(默认)</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSessionConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigureRedisAction <span class="title">configureRedisAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 让springSession不再执行config命令</span></span><br><span class="line">        <span class="keyword">return</span> ConfigureRedisAction.NO_OP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/xjj1040249553/article/details/82658889" target="_blank" rel="noopener">参考</a></p>
<h3 id="7-前后端维持同一个session-重要"><a href="#7-前后端维持同一个session-重要" class="headerlink" title="(7) 前后端维持同一个session(重要)"></a>(7) 前后端维持同一个session(重要)</h3><h4 id="1-前端"><a href="#1-前端" class="headerlink" title="1. 前端"></a>1. 前端</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">"axios"</span>;</span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span>;  <span class="comment">//允许跨域携带cookie信息</span></span><br></pre></td></tr></table></figure>

<h4 id="2-后端"><a href="#2-后端" class="headerlink" title="2. 后端"></a>2. 后端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="8-跨域问题-重要"><a href="#8-跨域问题-重要" class="headerlink" title="(8) 跨域问题(重要)"></a>(8) 跨域问题(重要)</h3><p>包含自定义header字段的跨域请求，浏览器会先向服务器发送OPTIONS请求，探测该服务器是否允许自定义的跨域字段。<br>因此在解决跨域问题时需要对OPTIONS方法进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrosInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;ACCESS_CONTROL_ALLOW_ORIGIN&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String ACCESS_CONTROL_ALLOW_ORIGIN;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拦截器0: 解决跨域问题"</span>);</span><br><span class="line"></span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, ACCESS_CONTROL_ALLOW_ORIGIN);  <span class="comment">// 不能写"*"，而要写具体的客户端的url，如http://120.0.0.1:8080 --- 十分重要！！！</span></span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);</span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS"</span>);</span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Max-Age"</span>, <span class="string">"86400"</span>);</span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"*"</span>);</span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"Content-Type,XFILENAME,XFILECATEGORY,XFILESIZE"</span>); <span class="comment">// 服务端需要对OPTIONS请求做出应答 --- 关键</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/xuedapeng/article/details/79076704" target="_blank" rel="noopener">参考</a></p>
<h3 id="8-浏览器中的-session-id-和-redis-中的-session-id-不一致的问题-不重要"><a href="#8-浏览器中的-session-id-和-redis-中的-session-id-不一致的问题-不重要" class="headerlink" title="(8) 浏览器中的 session id 和 redis 中的 session id 不一致的问题(不重要)"></a>(8) 浏览器中的 session id 和 redis 中的 session id 不一致的问题(不重要)</h3><p>这里两个session其实是一致的，只是浏览器保存的sessionId是经过服务器base64编码之后返回的。其实看似不一致，但是前端传入这个编码后的服务器也会解码处理，不会出现找不到的情况。</p>
<p>如果希望服务器与浏览器的sessionId一模一样，只需要自己去注册 DefaultCookieSerializer 并且设置变量 useBase64Encoding 为false即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 保证浏览器中的sessionId和服务器中的保存的sessionId保持一致</span></span><br><span class="line"><span class="comment">    * defaultCookieSerializer.setUseBase64Encoding(false);</span></span><br><span class="line"><span class="comment">    * 其实没有必要</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultCookieSerializer <span class="title">getDefaultCookieSerializer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DefaultCookieSerializer defaultCookieSerializer = <span class="keyword">new</span> DefaultCookieSerializer();</span><br><span class="line">    defaultCookieSerializer.setUseBase64Encoding(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> defaultCookieSerializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/wzygis/article/details/103509840" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>在Docker中配置PyTorch-gpu环境</title>
    <url>/2021/01/08/pytorch-gpu-docker/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了在 Docker 中配置 PyTorch-gpu 环境的方式</p>
</blockquote>
<a id="more"></a>

<h3 id="1-安装-nvidia-docker"><a href="#1-安装-nvidia-docker" class="headerlink" title="(1) 安装 nvidia-docker"></a>(1) 安装 nvidia-docker</h3><p>nvidia-docker是docker引擎的一个应用插件，专门面向nvidia的GPU，允许用户构建和运行GPU加速的Docker容器。<br>安装方法参考<a href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker" target="_blank" rel="noopener">官网</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 设置稳定的存储库和GPG密钥(官网翻译来的)</span></span><br><span class="line">distribution=$(. /etc/os-release;<span class="built_in">echo</span> <span class="variable">$ID</span><span class="variable">$VERSION_ID</span>)</span><br><span class="line">curl -s -L https://nvidia.github.io/nvidia-docker/<span class="variable">$distribution</span>/nvidia-docker.repo | sudo tee /etc/yum.repos.d/nvidia-docker.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 安装nvidia-docker2及其依赖</span></span><br><span class="line">sudo yum install -y nvidia-container-toolkit nvidia-docker2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 重启docker</span></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="2-拉取合适的pytorch镜像"><a href="#2-拉取合适的pytorch镜像" class="headerlink" title="(2) 拉取合适的pytorch镜像"></a>(2) 拉取合适的pytorch镜像</h3><p>从 DockerHub 中拉取版本合适的，集成了 anaconda 的 python 环境、pytorch、cuda 和 cudnn 的 docker <a href="https://registry.hub.docker.com/r/pytorch/pytorch/tags?page=1&ordering=last_updated" target="_blank" rel="noopener">镜像</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull pytorch/pytorch:1.6.0-cuda10.1-cudnn7-runtime</span><br></pre></td></tr></table></figure>

<h3 id="3-通过nvidia-docker启动容器"><a href="#3-通过nvidia-docker启动容器" class="headerlink" title="(3) 通过nvidia-docker启动容器"></a>(3) 通过nvidia-docker启动容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 通过 nvidia-docker 启动容器，而不是通过 docker 启动容器</span></span><br><span class="line"><span class="comment"># 2. 端口15732(随便写的)是 docker 中的服务映射出来的端口号</span></span><br><span class="line"><span class="comment"># 3. 端口23是 docker 中的 ssh 的服务端口 22 映射出来的端口号，用于在 PyCharm 通过 ssh 远程连接使用 docker 中的 python环境(不是必要的)</span></span><br><span class="line"><span class="comment"># 4. docker 中的目录 /workspace 是用来放置待运行的 python 程序的目录，最好挂载到本机上，方便查看与修改 docker 中运行的 python 程序</span></span><br><span class="line">sudo nvidia-docker run -it -d --name=<span class="string">'[容器名称]'</span> -p 15732:15732 -p :23:22 -v [服务器中的目录]:/workspace [镜像名称/镜像id]</span><br></pre></td></tr></table></figure>

<h3 id="4-测试在-docker-是否可以使用-nvidia-显卡"><a href="#4-测试在-docker-是否可以使用-nvidia-显卡" class="headerlink" title="(4) 测试在 docker 是否可以使用 nvidia 显卡"></a>(4) 测试在 docker 是否可以使用 nvidia 显卡</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 进入容器，其中 qa 是容器名称</span></span><br><span class="line">sudo docker <span class="built_in">exec</span> -it qa bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 进入 python 环境</span></span><br><span class="line">python</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3. 测试 nvidia 显卡是否可用</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure>

<img src="/2021/01/08/pytorch-gpu-docker/test_docker_available.png" class>

<p><strong>注</strong>：可能出现由于版本问题导致 nvidia 驱动不可用的情况，这时需要调整 pytorch 镜像的版本，重新拉取版本合适的镜像</p>
<h3 id="5-配置-docker-容器中的-ssh-服务-不是必要的"><a href="#5-配置-docker-容器中的-ssh-服务-不是必要的" class="headerlink" title="(5) 配置 docker 容器中的 ssh 服务(不是必要的)"></a>(5) 配置 docker 容器中的 ssh 服务(不是必要的)</h3><p>为了开发和调试的方便，我们希望在 PyCharm 中能够通过 ssh 远程连接的方式直接使用 docker 中的 python 环境，这时就需要在 docker 中配置 ssh 服务，配置过程<a href="https://zhuanlan.zhihu.com/p/76469329" target="_blank" rel="noopener">参考</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 进入容器，其中 qa 是容器名称</span></span><br><span class="line">sudo docker <span class="built_in">exec</span> -it qa bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 更新容器的apt源，安装ssh和vim</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install openssh-server</span><br><span class="line">apt-get install vim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 使用vim打开并修改配置文件</span></span><br><span class="line"><span class="comment">#    找到PermitRootLogin prohibit-password这一行，修改为PermitRootLogin yes，允许通过ssh远程访问docker</span></span><br><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 创建docker中root用户的密码</span></span><br><span class="line">passwd root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 启动ssh服务，至此，服务器端配置完毕</span></span><br><span class="line">service ssh restart</span><br></pre></td></tr></table></figure>

<p>然后，在 PyCharm 中配置 ssh 远程访问即可</p>
<p>以后在每次启动该 docker 容器的时候，都要开启 ssh 服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 启动容器</span></span><br><span class="line">sudo docker start qa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 启动容器中的 ssh 服务</span></span><br><span class="line">sudo docker <span class="built_in">exec</span> -it qa service ssh start</span><br></pre></td></tr></table></figure>

<h3 id="6-将容器提交为镜像"><a href="#6-将容器提交为镜像" class="headerlink" title="(6) 将容器提交为镜像"></a>(6) 将容器提交为镜像</h3><p>在实际运行的过程中，难免会在 docker 中安装一些其它的 python 库，如果希望将这个 docker 中的 python 环境保存下来，则需要将配置好的容器提交为本地镜像，以便于迁移或复用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker commit [容器名] [镜像名]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-compose 的使用方法简介</title>
    <url>/2021/01/12/docker-compose/</url>
    <content><![CDATA[<blockquote>
<p>本文总结了使用docker-compose同时启动springboot+redis+elasticsearch+mysql+pytorch-gpu镜像的方法</p>
</blockquote>
<a id="more"></a>

<h3 id="1-docker-compose-简介"><a href="#1-docker-compose-简介" class="headerlink" title="(1) docker-compose 简介"></a>(1) docker-compose 简介</h3><ul>
<li>Docker-Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。</li>
<li>Docker-Compose的工程配置文件默认为docker-compose.yml，可通过环境变量COMPOSE_FILE或-f参数自定义配置文件，其定义了多个有依赖关系的服务及每个服务运行的容器。</li>
<li>Docker-Compose项目由Python编写，调用Docker服务提供的API来对容器进行管理。因此，只要所操作的平台支持Docker API，就可以在其上利用Compose来进行编排管理。</li>
</ul>
<h3 id="2-制作镜像"><a href="#2-制作镜像" class="headerlink" title="(2) 制作镜像"></a>(2) 制作镜像</h3><p>分别将 springboot 的镜像、redis 的镜像、elasticsearch 的镜像、mysql 的镜像和 <a href="https://shuoshuo666.github.io/2021/01/08/pytorch-gpu-docker/">pytorch-gpu</a> 的镜像准备好</p>
<img src="/2021/01/12/docker-compose/images.png" class>

<h3 id="3-安装-docker-compose"><a href="#3-安装-docker-compose" class="headerlink" title="(3) 安装 docker-compose"></a>(3) 安装 docker-compose</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pip install docker-compose</span><br></pre></td></tr></table></figure>

<h3 id="4-使-docker-compose-支持-nvidia-docker"><a href="#4-使-docker-compose-支持-nvidia-docker" class="headerlink" title="(4) 使 docker-compose 支持 nvidia-docker"></a>(4) 使 docker-compose 支持 nvidia-docker</h3><p>修改配置文件/etc/docker/daemon.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"default-runtime"</span>: <span class="string">"nvidia"</span>,  <span class="comment">// 增加这一行，这样执行 docker 就相当于执行 nvidia-docker，就可以用 docker-compose 管理 nvidia gpu 容器了</span></span><br><span class="line">    <span class="attr">"runtimes"</span>: &#123;</span><br><span class="line">        <span class="attr">"nvidia"</span>: &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"nvidia-container-runtime"</span>,</span><br><span class="line">            <span class="attr">"runtimeArgs"</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改配置文件后，重新加载 daemon，重启 docker 服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="5-编写-docker-compose-yml-文件"><a href="#5-编写-docker-compose-yml-文件" class="headerlink" title="(5) 编写 docker-compose.yml 文件"></a>(5) 编写 docker-compose.yml 文件</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span>  <span class="comment"># 指定 docker-compose.yml 的版本</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span>  <span class="comment"># 配置每一个 docker 容器启动的参数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># mysql 容器启动参数</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kg-mysql</span>  <span class="comment"># 容器名</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">shuo/mysql-kg:3.0</span>  <span class="comment"># 容器由哪个镜像生成</span></span><br><span class="line">    <span class="attr">ports:</span>  <span class="comment"># 端口映射</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">3306</span><span class="string">:3306</span></span><br><span class="line">    <span class="attr">environment:</span>  <span class="comment"># 环境变量配置，设置root用户的登录密码</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># reids 容器启动参数</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kg-redis</span>  <span class="comment"># 容器名</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">shuo/redis:1.0</span>  <span class="comment"># 容器由哪个镜像生成</span></span><br><span class="line">    <span class="attr">ports:</span>  <span class="comment"># 端口映射</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">6379</span><span class="string">:6379</span></span><br><span class="line">    <span class="attr">volumes:</span>  <span class="comment"># 挂载目录映射</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/data/zhangshuo/my_software/redis_docker/redis.conf:/etc/redis/redis.conf</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/data/zhangshuo/my_software/redis_dockerdata:/data</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/etc/redis/redis.conf</span> <span class="string">--appendonly</span> <span class="literal">yes</span>  <span class="comment"># 容器启动时执行的命令</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># elasticsearch 容器启动参数</span></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kg-elasticsearch</span>  <span class="comment"># 容器名</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elasticsearch:7.6.2</span>  <span class="comment"># 容器由哪个镜像生成</span></span><br><span class="line">    <span class="attr">ports:</span>  <span class="comment"># 端口映射</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">9300</span><span class="string">:9300</span></span><br><span class="line">    <span class="attr">environment:</span>  <span class="comment"># 环境变量配置，单机模式启动</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">discovery.type=single-node</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># pytorch-gpu 容器启动参数</span></span><br><span class="line">  <span class="attr">qa:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kg-qa</span>  <span class="comment"># 容器名</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">shuo/qa:1.0</span>  <span class="comment"># 容器由哪个镜像生成</span></span><br><span class="line">    <span class="attr">ports:</span>  <span class="comment"># 端口映射，使用了变量</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"$&#123;qa_port&#125;:15732"</span></span><br><span class="line">    <span class="attr">volumes:</span>  <span class="comment"># 挂载目录映射</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/data/zhangshuo/my_software/torch_docker:/workspace</span></span><br><span class="line">    <span class="comment"># 以下两行等价于 docker run -it 中的 -it，防止容器启动后立即关闭</span></span><br><span class="line">    <span class="attr">stdin_open:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 容器启动时执行的命令，启动 python 程序，/bin/bash 命令是防止容器启动后立即退出</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">-c</span> <span class="string">"/workspace/run_server.sh 15732 python /workspace/ &amp;&amp; /bin/bash"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># springboot 容器启动参数</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kg-app</span>  <span class="comment"># 容器名</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">shuo/app:1.3</span>  <span class="comment"># 容器由哪个镜像生成</span></span><br><span class="line">    <span class="attr">ports:</span>  <span class="comment"># 端口映射</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7474</span><span class="string">:7474</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">7687</span><span class="string">:7687</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">8181</span><span class="string">:8181</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">5005</span><span class="string">:5005</span></span><br><span class="line">    <span class="attr">depends_on:</span>  <span class="comment"># 在启动该容器之前，先启动以下容器</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">qa</span></span><br><span class="line">    <span class="comment"># 容器启动时执行的命令，启动 neo4j 数据库，并启动 springboot 的 jar 包，并传入一个参数(使用了变量)</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">-c</span> <span class="string">"neo4j start &amp;&amp; java -Ddruid.mysql.usePingMethod=false -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005 -jar /root/app.jar $&#123;qa_port&#125;"</span></span><br></pre></td></tr></table></figure>

<h3 id="6-在-docker-compose-yml-文件中使用变量"><a href="#6-在-docker-compose-yml-文件中使用变量" class="headerlink" title="(6) 在 docker-compose.yml 文件中使用变量"></a>(6) 在 docker-compose.yml 文件中使用变量</h3><p>在 docker-compose.yml 同级目录中新建文件 .env，并在该文件中定义变量的值</p>
<img src="/2021/01/12/docker-compose/pwd.png" class>
<img src="/2021/01/12/docker-compose/var.png" class>

<p>然后，在 docker-compose.yml 文件中就可以以 “${变量名}” 的方式使用该变量</p>
<h3 id="7-常用命令"><a href="#7-常用命令" class="headerlink" title="(7) 常用命令"></a>(7) 常用命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker-compose up -d  <span class="comment"># 从当前目录中的 docker-compose.yml 文件创建并启动各个 docker 容器，-d 代表后台运行</span></span><br><span class="line">sudo docker-compose down  <span class="comment"># 关闭并删除当前目录中的 docker-compose.yml 文件中指定的各个 docker 容器</span></span><br></pre></td></tr></table></figure>

<p>运行 <code>sudo docker-compose up -d</code> 后:</p>
<img src="/2021/01/12/docker-compose/docker_ps.png" class>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
</search>
